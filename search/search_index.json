{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bpod","text":"<p>         Bpod     </p> <p> Rodent behavior with Bpod: low-cost, extensible, open-source. </p> <p>Bpod_Gen2 source code: https://github.com/sanworks/Bpod_Gen2</p> <p>Documentation: https://sites.google.com/site/bpoddocumentation/</p> <p>Computer Aided Design (CAD) files: https://github.com/sanworks/Bpod-CAD</p> <p>Legacy release (state machine 0.5 only): https://github.com/sanworks/Bpod/tree/master</p> <p>Warning</p> <p> This is a test version of the Bpod wiki to examine the feasibility of moving it to Github. The official wiki maintained by Sanworks is hosted here.</p> <p> All of the content on the existing wiki should have been moved across, and only a few new additions remain incomplete.</p> <p>Bpod is an open source rodent behavioral platform used in over 100 publications since 2013.</p> <p>The key features include:</p> <ul> <li>Hardware and software open-sourced under GNU General Public License v3</li> <li>Optimized for rodent behavior measurement and closed-loop control</li> <li>Arduino based architecture for user extendibility and easy integration into existing setups</li> <li>Existing modules support common behavioral approaches</li> </ul>"},{"location":"#about-bpod","title":"About Bpod","text":"<p>Bpod is an open source system for real-time behavior measurement in tasks consisting of multiple experimental trials. Experiment software is written in MATLAB, and device firmware is written in Arduino. Hardware can be assembled with DIY desktop manufacturing methods - hand-soldering, 3-D printing, laser cutting and hand-tapping. The system architecture is low cost, and supremely hackable - precisely what is necessary to explore a space of behavioral metrics, or to train test subjects with high throughput. This wiki contains instructions for assembly and programming.</p> <p>Bpod was initially developed in Kepecs Lab at Cold Spring Harbor Laboratory, as a project alongside the lead developer's thesis research. It is maintained by Sanworks LLC, a company dedicated to developing Bpod and other open neuroscience tools.</p> <p>Bpod builds on the central design concept of B-control, a system provided by Brody Lab at Princeton University for rodent behavior measurement. Experimental trials are constructed in MATLAB as finite state machines, and executed on a separate real-time Linux computer. Bpod combines this parallel processing model with the accessibility of embedded computing in the Arduino language. Bpod provides a rich suite of software tools in high level interpreted computing environments for protocol development and online analysis, while real-time processing is delegated to an Arduino microcontroller network governed by finite state machine firmware.</p> <pre><code>---\ntitle: Bpod's design concept\n---\nsequenceDiagram\nactor e as Experimenter\nparticipant matlab as Computer\nparticipant bpod as Bpod State Machine\nparticipant external as External devices\n\ne-&gt;&gt;matlab: Start protocol\nNote over matlab: Prepare session\nmatlab -&gt;&gt; external: Configure with user-friendly functions\nloop\nNote over matlab: Prepare state machine\nmatlab -&gt;&gt; bpod: Run state machine\nactivate bpod\nNote over bpod: Rodent behavior\nbpod --&gt;external: High speed interaction\nbpod -&gt;&gt; matlab: Send trial data\ndeactivate bpod\nNote over matlab: Save data\nend</code></pre> <p>We love hearing about the awesome science that is generated with Bpod! </p> <p>Please post on the Forums with your questions and feedback, or email us directly.</p>"},{"location":"assembly/","title":"General build guide","text":"<p>The Assembly section contains supporting information for assembling Bpod state machines, peripheral modules, and other peripheral hardware.</p> <p>Devices are assembled by soldering components from the bill of materials to their matching locations indicated  on the printed circuit board. A more in-depth assembly guide is provided for the Bpod Finite State Machine here, and can be extrapolated to any Bpod device.</p> <p>The different devices are accessed from the navigation bar on the left. </p>"},{"location":"assembly/analog-input-module-assembly/","title":"Analog Input Module","text":"<p>The analog input module records voltage waveforms from 8 input channels, and sends voltage threshold crossing events to the Bpod state machine.</p> <p>Firmware for the analog input module is available here.</p>"},{"location":"assembly/analog-input-module-assembly/#hardware-specs-v1","title":"Hardware Specs (v1):","text":"<ul> <li>Arduino-compatible 180MHz ARM Cortex M4 processor (Teensy 3.6)</li> <li>Integrated analog to digital (ADC) - Analog Devices AD7327 </li> <li>Voltage precision: 12-bit</li> <li>4\u00a0 single-ended input range settings: -10V:10V, -5V:5V, -2.5V:2.5V, 0V:10V</li> <li>8MB/s USB data transfer</li> <li>16GB microSD memory for logging waveform data</li> <li>Max sampling rate: 10kHz</li> <li>Configurable voltage thresholds for generating behavior events, to control the Bpod State Machine.</li> <li>Dedicated port to stream analog data directly to the analog output module (for closed loop applications)</li> </ul>"},{"location":"assembly/analog-input-module-assembly/#hardware-specs-v2","title":"Hardware Specs (v2):","text":"<ul> <li>Arduino-compatible 600MHz ARM Cortex M7 processor (Teensy 4.1)</li> <li>Highly integrated analog to digital (ADC) - Analog Devices AD7606C</li> <li>Voltage precision: 16-bit</li> <li>7 single-ended input range settings: -12.5V:12.5V, -10V:10V, -6.5V:6.5V, -5V:5V, -2.5V:2.5V, 0V:5V, 0V:10V</li> <li>8MB/s USB data transfer</li> <li>16GB microSD memory for logging waveform data</li> <li>Max sampling rate: 50kHz</li> <li>Configurable voltage thresholds for generating behavior events, to control the Bpod State Machine.</li> <li>Dedicated port to stream analog data directly to the analog output module (for closed loop applications)</li> <li>Galvanic isolation divides analog interface from USB and MCU</li> <li>Anti-Alias filtering and oversampling on-chip</li> <li>True-differential mode selectable per-channel, w/ certain voltage ranges</li> <li>5V reference source included to simplify connection of resistive sensors</li> </ul>"},{"location":"assembly/analog-input-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/analog-input-module-assembly/#aim-v1","title":"AIM v1","text":""},{"location":"assembly/analog-input-module-assembly/#aim-v2","title":"AIM v2","text":""},{"location":"assembly/analog-output-module-assembly/","title":"Analog Output Module","text":"<p>The analog output module plays voltage sequences on 4 or 8 output channels. Output is driven by the Analog Devices AD5754R DAC.</p> <p>Version 1 was released in 2017. It is powered by PJRC Teensy 3.6.</p> <p>Version 2 was released in 2023. It is powered by PJRC Teensy 4.1.</p> <p>Several firmware versions are available for the device:</p> <ul> <li>WavePlayer firmware (default) plays from a programmable library of sampled waveforms on trigger.</li> <li>AudioPlayer firmware is specialized for stereo sound*, sampled at up to 96kHz.</li> <li>PulsePal firmware plays parametric waveforms using the Pulse Pal Parameters.</li> </ul> <p>Hardware Specs:</p> <ul> <li>V1: Arduino-compatible 180MHz ARM Cortex M4 processor with 12Mb/s USB data transfer</li> <li>V2: Arduino-compatible 600MHz ARM Cortex M7 processor with 480Mb/s USB data transfer</li> <li>Highly integrated digital to analog converter (DAC) - AD5754R.</li> <li>16 bit voltage precision</li> <li>6 output range settings: 0:5V, 0:10V, 0:12V, -5:+5V, -10:+10V, -12:+12V</li> <li>16GB microSD memory for waveform data</li> </ul> <p>Specs with WavePlayer firmware (arbitrary waveform playback on trigger):</p> <ul> <li>Max sampling rate: 100kHz (2 channels active), 50kHz (4 channels active)</li> <li>Playback latency on trigger: &lt;100\u03bcs (waveform pre-selection not required)</li> <li>Max waveform size: 1M samples</li> <li>Trigger signals from Bpod can replace or toggle the currently playing waveform</li> </ul> <p>Firmware for the analog output module is available here.</p> <p>*The analog output module is a general purpose DAC. High definition sound playback is available via the HiFi module.</p>"},{"location":"assembly/analog-output-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/analog-output-module-assembly/#4ch-aom-v1","title":"4Ch AOM v1","text":""},{"location":"assembly/analog-output-module-assembly/#4ch-aom-v2","title":"4Ch AOM v2","text":""},{"location":"assembly/analog-output-module-assembly/#8ch-aom","title":"8Ch AOM","text":""},{"location":"assembly/arduino-shield-0-5-assembly/","title":"Arduino Shield 0.5","text":"<p>The Bpod/Arduino shield allows Bpod to control Arduino devices. It's very simple to build. Here's how.</p> <ol> <li>Order all parts in the Bill of Materials.<ul> <li>These parts can be purchased from commercial suppliers except for the printed circuit board.</li> <li>We have previously used SeeedStudio's FusionPCB service as follows:<ul> <li>QTY: 10</li> <li>PCB Layer: 2</li> <li>PCB Thickness: 1.6mm</li> <li>PCB Dimension: 5cm max X 10cm max</li> <li>PCB Color: green</li> <li>Surface Finish: HASL</li> </ul> </li> <li>This should work out to ~$2.39 per board for an order of 10 boards (Jan 2014). Select \"Next\".</li> <li>Select: C:\\Bpod\\CAD\\PCB\\BpodArduinoShield\\BpodArduinoShield_r1_Gerber.zip and finish the order.</li> </ul> </li> <li>Gather tools. You'll need:<ul> <li>A clean soldering iron and sponge</li> <li>Solder</li> </ul> </li> <li>Follow the assembly instructions</li> </ol>"},{"location":"assembly/arduino-shield-0-5-assembly/#assembly-instructions","title":"Assembly Instructions","text":"<ul> <li>Solder the components into the board as shown. </li> <li>DO NOT cut the legs from the bottom of the strip headers after soldering - they will plug into Arduino.</li> </ul>"},{"location":"assembly/arduino-shield-0-5-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/arduino-shield-gen2-assembly/","title":"Arduino Shield Gen2","text":"<p>Bpod Arduino shield for Bpod 0.7+, designed by Sanworks.</p> <p></p> <p>The Arduino shield interfaces the Bpod state machine with Arduino M0, Arduino Zero, Arduino Due or Adafruit Metro M4.</p> <p>It is an interface for making custom Arduino-based modules, encapsulating different sensors and actuators.</p> <p>The shield exchanges UART messages via Arduino serial objects: Serial1 (Arduino M0, Zero, Metro M4) or Serial (Arduino Due).</p> <p>It uses only Arduino digital pins 0 and 1. Pin 13's LED is broken out to the top of the shield for visibility.</p> <p>The UART stream is buffered to full-duplex RS-485 via a converter IC. An identical chip on the state machine restores the message to single-ended 3.3V logic levels.</p> <p>Example Arduino files for use with the Bpod shield + Arduino are available here.</p>"},{"location":"assembly/arduino-shield-gen2-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/dds-module-assembly/","title":"DDS Module","text":"<p> The DDS (direct digitzal synthezier) module outputs a continuous sine or triangle wave, with frequency and amplitude modulated by the state machine, a separate Bpod module or both in parallel.</p> <p>Specs:</p> <ul> <li>Arduino-compatible 96MHz ARM Cortex M4 processor (Teensy 3.2)</li> <li>Direct digital synthesis IC (DDS) - AD9834.<ul> <li>Driven by 10MHz oscillator, anticipating output frequencies between 1 and 100kHz</li> </ul> </li> <li>12 bit digital amplitude control with an external DAC IC: AD5620<ul> <li>Output amplitude from 150mV to 650mV peak-to-peak</li> </ul> </li> <li>1 Bpod state machine port.</li> <li>1 Bpod module port (most often used for streaming digital inputs, with configurable mapping to frequency outputs).</li> <li>BNC output connector</li> <li>Module can optionally derive its power supply from pocket state machine (using an on-board jumper).</li> </ul> <p>Note: This module loosely implements Analog Devices Circuit Note CN0156 for amplitude control. The output channel is directly driven by the DDS IC, resulting in a DC offset that varies slightly with the amplitude setting. See the amplitude adjustment section in the MATLAB plugin documentation for more info.</p> <p>Firmware for the DDS module is available here.</p>"},{"location":"assembly/dds-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/ethernet-module-assembly/","title":"Ethernet Module","text":"<p>The Bpod Ethernet module allows devices on the local network to exchange messages with the state machine (v0.7-0.9, 2.0).</p> <p>For state machine v2, it can also act as the primary communication channel, replacing the USB cable. This allows computers to be significantly more distant from the rigs they control. To do this, upload SM_Relay firmware to the Ethernet module, Ethernet-routed state machine firmware to the state machine, and call Bpod with an IP address argument - e.g. Bpod('192.168.1.110'). Note: you must have Bpod Console v1.5.3 or newer.</p> <p>NOTE: Currently, the module requires the MATLAB instrument control toolbox. An alternative (free and open) interface via PsychToolbox is under development.</p>"},{"location":"assembly/ethernet-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/hifi-module-assembly/","title":"HiFi Module","text":"<p>The Bpod HiFi Module stores audio waveforms and play them back on trigger.</p> <p>Audio waveforms are rendered by HiFiBerry DAC2 Pro and DAC2 HD cards.</p> <p>Our firmware directly interfaces these cards with Teensy 4.1 for superior timing\\n\\s+\\n precision.</p> <p>An isolated TTL output channel signals audio playback onset and offset.</p> <p>Synth functions are provided for programmatic control of white noise and pure tones.</p> <p>Hardware for the two modules is identical except for the enclosure and HiFiBerry card used.</p> <p>A single firmware file can be set to compile for either module.</p> <p>Key specs are:</p> <ul> <li>Sampling rate: 44.1, 48, 96 or 192kHz</li> <li>Bit depth: 16</li> <li>Audio channels: 2 (Stereo)</li> <li>Audio waveform slots: 20</li> <li>Max audio samples per slot: 5,760,000</li> <li>Playback latency on trigger: 0.22ms +/- 0.01ms</li> <li>USB audio data transfer speed: 40-50Mb/s</li> <li>Audio signal voltage range: +/- 3V</li> <li>TTL sync voltage: 3.3V</li> <li>Max AM onset/offset Envelope samples: 2000</li> <li>Synth waveforms supported: White Noise, Sinef</li> </ul> <p>The HiFi module is controlled from MATLAB with the BpodHiFi class.</p> <p>Its interfaces to the Bpod State Machine and USB are documented here.</p> <p>This table contrasts the HiFiBerry cards in the 'SD' and 'HD' versions of the module:</p>"},{"location":"assembly/hifi-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/lickometer-assembly/","title":"Lickometer","text":"<p>The lickometer measures the precise time of lick events, and provides a steel tube to deliver liquid reward.</p> <p>The lickometer uses a photogate created from an infrared emitter with a narrow (10 degree) beam angle and a spectrally matched phototransistor. A white LED angled towards the subject is provided, to be used as a cue or for feedback.</p> <p>The lickometer interfaces with the state machine via the port interface board.</p> <p></p> <p>The lickometer design file contains two 3D printable parts:</p> <ul> <li>a scaffolding to hold the LED, sensor, emitter and 15ga drink tube</li> <li>a sheath to block ambient light and to mount the lickometer.</li> </ul> <p>When printed with an FDM printer using a 0.4mm extruder, the components press-fit into the scaffolding, and the sheath press-fits over it.</p> <p>The lickometer shown above was printed from gray ColorFabb XT Copolyester.</p> <p>A 4-40 nut press-fits into a pocket in the sheath, to mount it to a ThorLabs mini-series post.</p> <p>Print settings are specified in a text document that accompanies the design files on Github.</p> <p>The mount shown in the images above provides coarse adjustment in 3 axes, and rotation about 2 axes. Its components are:</p> <ul> <li>1 Imperial MS series post (MS3R shown; 6mm mini-series post with 4-40 threaded end; choose length to match your assay)</li> <li>1 RA90TR (1/2\" to 6mm post clamp)</li> <li>1 Imperial 1/2\" optical post (TR2 shown, choose length to match your assay)</li> <li>1 Imperial 1/2\" post holder (PH2 shown, choose length to match your assay)</li> <li>1 Imperial BA1S mounting base</li> </ul> <p>The bill of materials for the lickometer is shown below:</p>"},{"location":"assembly/mouse-behavior-port-assembly/","title":"Mouse Behavior Port","text":"<p>The mouse behavior port combines a photo-gate with a steel tube for delivering liquid reward, in a 3D-printed housing.</p> <p>It allows freely moving subjects to indicate decisions and collect rewards.</p> <p>The behavior port uses a photogate created from an infrared emitter with a narrow (10 degree) beam angle and a spectrally matched phototransistor.</p> <p>A white LED embedded in the port illuminates it, to be used as a decision cue or for feedback.</p> <p>The behavior port interfaces with the Bpod state machine via the port interface board.</p> <p></p>"},{"location":"assembly/mouse-behavior-port-assembly/#assembly-instructions","title":"Assembly Instructions","text":"<p>Top row (from the left):</p> <ul> <li>6x 12mm lengths of heat shrink tubing</li> <li>IR emitter</li> <li>Phototransistor</li> <li>White 3mm LED</li> <li>A 35mm length of 15ga stainless steel hypodermic tubing (deburred)</li> <li>2x M4, 16mm screws</li> <li>3x red 22Ga solid-core wires 70mm long</li> <li>3x purple 22Ga solid-core wires 70mm long</li> </ul> <p>Bottom row (from the left):</p> <ul> <li>3D printed Port (using clear XT Copolyester)</li> <li>3D printed sheath.</li> </ul> <p>You will also need: a soldering iron, a wire stripper, a wire cutter, a third hand, an M3 bottoming tap and a heat gun.</p> <p>Step 1: With the wire stripper (using the 22ga hole), remove 4mm from each end of each wire:</p> <p></p> <p>Step 2: Mount the infrared emitter in the 3rd hand, facing you, and trim its leads. </p> <p>Next, solder the purple (ground) wire to the left lead, and the red (power) wire to the right lead.</p> <p></p> <p>Step 4: Repeat steps 2 and 3 for the phototransistor and the white LED. For the white LED, the longer leg (before you clip them) should be attached to the red wire.</p> <p></p> <p>Step 5: Carefully tap the two M4 holes on the back-side of the port. Ensure that the nylon M4 screws can be inserted to ~2/3 of their length:</p> <p></p> <p>Step 6: Remove the screws and insert the steel tube into the hole matching its size. This may require some force initially.</p> <p></p> <p>Step 7: Press the white LED into place. It is a press-fit, so you may need a small screwdriver to assist.</p> <p></p> <p>Step 8: Reinsert the M4 screws.</p> <p>Next, Press the IR emitter and photo-transistor into place. When the steel tube is on the bottom and you are facing the port (see image from Step 6), the IR emitter (blue) should go on the right, and the photo-transistor (black) should go on the left:</p> <p></p> <p>Step 9: Press the port into the sheath:</p> <p></p> <p>Congratulations, your port is complete!</p> <p></p> <p>Next, connect it to a port interface board and test it with Bpod.</p> <p>Note: The port design shown here has a thin layer of XT covering the sensor and emitter. However, we found that the optical clarity of the material is not always guaranteed in the print, occasionally producing a port that could not be used. The current design revision available in the Bpod repository has the sensor and emitter directly exposed, a configuration that has worked well in several labs.</p>"},{"location":"assembly/mouse-behavior-port-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/mouse-box-assembly/","title":"Mouse Box","text":"<p>Design files for a mouse behavior box have been included in the Bpod repository.</p> <p>The box allows two alternative forced choice (2AFC) and GO/NOGO tasks in freely moving mice.</p> <p>It can be constructed entirely from 3mm laser cut acrylic and 3-d printed material (PLA preferred)</p> <p></p> <p>The box is designed to work with Bpod Mouse Ports. It features a floor with an easy release mechanism, and side-walls that are sound-permeable near the ports. A clear acrylic roof slides into place on a track, for imaging of the mouse during behavior.</p> <p></p> <p>The box uses 4 rubber feet. Aside from this, it requires no independent bill of materials. </p>"},{"location":"assembly/mouse-box-assembly/#bill-of-materials","title":"Bill of Materials","text":"<p>Here it is shown with the recommended solenoid valve for Bpod (part#LHDA1231115H). You will have to block the bottom valve port.</p> <p>This version of the nosepoke board uses a trimmer potentiometer to adjust the LED current. This will enable you to set the maximum intensity of each port to some value with a light meter. Intensity is also controlled programmatically within Bpod via PWM.</p>"},{"location":"assembly/neuralynx-sync-board-assembly/","title":"Bpod/Neuralynx Sync Board","text":"<p>The Neuralynx sync board allows behavior and events logged by Bpod v0.5 to be sent to a Neuralynx electrophysiology system.</p> <p>Note: Bpod state machine 0.7+ Does not require the sync board.</p> <p>It's very simple to build. Here's how.</p> <ol> <li>Order all parts in the Bill of Materials<ul> <li>These parts can be purchased from commercial suppliers except for the printed circuit board.</li> <li>We have previously used SeeedStudio's FusionPCB service as follows:<ul> <li>QTY: 10</li> <li>PCB Layer: 2</li> <li>PCB Thickness: 1.6mm</li> <li>PCB Dimension: 5cm max X 5cm max</li> <li>PCB Color: green</li> <li>Surface Finish: HASL</li> </ul> </li> <li>This should work out to ~$2.39 per board for an order of 10 boards (Jan 2014). Select \"Next\".</li> <li>Select C:\\Bpod\\CAD\\PCB\\NeuralynxSync\\BpodNlxSync.zip and finish the order.</li> </ul> </li> <li>Gather tools. You'll need:<ul> <li>A clean soldering iron and sponge</li> <li>Solder</li> </ul> </li> <li>Follow the assembly instructions.</li> </ol>"},{"location":"assembly/neuralynx-sync-board-assembly/#assembly-instructions","title":"Assembly Instructions","text":"<p>Solder the two components into the board as shown below (left).</p> <p>Then, connect a CAT6 cable between the \"sync\" port on the Bpod device and the ethernet jack on the adapter board.</p> <p>The adapter board plugs into the Neuralynx TTL port as shown below (right).</p> <p>WARNING: On some Neuralynx systems, there is enough space below the bottom pin, for the sync board to plug into air. If you accidentally do this, your lowest bit will be lost! Make sure each row holes on the sync board header are aligned with Neuralynx pins.</p> <p>Here are images of the final product: </p>"},{"location":"assembly/neuralynx-sync-board-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/open-ephys-module-assembly/","title":"Bpod/OpenEphys Sync Board","text":"<p>The Open Ephys sync board allows behavior and events logged by Bpod to be sent to an Open Ephys electrophysiology system.</p> <p>Note: Bpod state machine 0.7+ does not require the sync board.</p> <p>It's very simple to build. Here's how.</p> <ol> <li>Order all parts in the Bill of Materials<ul> <li>These parts can be purchased from commercial suppliers except for the printed circuit board.</li> <li>We have previously used SeeedStudio's FusionPCB service as follows:<ul> <li>QTY: 10</li> <li>PCB Layer: 2</li> <li>PCB Thickness: 1.6mm</li> <li>PCB Dimension: 5cm max X 5cm max</li> <li>PCB Color: green</li> <li>Surface Finish: HASL</li> </ul> </li> <li>This should work out to ~$2.39 per board for an order of 10 boards (Jan 2014). Select \"Next\".</li> <li>Select C:\\Bpod\\CAD\\PCB\\OpenEphysSync\\OpenEphysSync_r1_Gerber.zip and finish the order.</li> </ul> </li> <li>Gather tools. You'll need:<ul> <li>A clean soldering iron and sponge</li> <li>Solder</li> </ul> </li> <li>Follow the assembly instructions.</li> </ol>"},{"location":"assembly/open-ephys-module-assembly/#assembly-instructions","title":"Assembly instructions","text":"<p>Solder the three components into the board as shown below.</p> <p>The HDMI connector pins are surface mount, and will require special soldering techniques.</p> <p>Here is an image of the final product: </p>"},{"location":"assembly/open-ephys-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/port-array-module-assembly/","title":"Port Array Module","text":"<p> The Port Array Module interfaces 4 behavior ports to a Bpod State Machine. </p> <p>Up to 5 port array modules may be used with a single state machine, for experiments requiring large numbers of behavior ports.</p> <p>The Port Array Module is compatible with state machine r0.7+</p>"},{"location":"assembly/port-array-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/port-breakout-board-assembly/","title":"Port Interface Board","text":"<p> Each port interface board connects one infrared photo-gate, one LED and one solenoid valve with the Bpod state machine via an Ethernet cable.</p>"},{"location":"assembly/port-breakout-board-assembly/#assembly","title":"Assembly","text":"<ol> <li>Solder the parts on to the board (through-hole version shown). Begin with the 3 resistors. Make sure their values match the values printed on the board. Next, solder the blue potentiometer, the 6-position screw terminal connector, the 2-position connector, and finally the Ethernet jack.</li> </ol> <ol> <li>If you have a solenoid valve and wish to mount it directly to the board, clip 2mm off from leads with a wire cutter, insert the valve into the 2-position screw terminal and screw it in to place:</li> </ol>"},{"location":"assembly/port-breakout-board-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/raspberry-pi-shim-assembly/","title":"Raspberry Pi Shim","text":"<p>The Bpod Raspberry Pi Shim interfaces the Bpod Finite State Machine r0.7 or newer with Raspberry Pi via its UART interface.</p> <p>Its 'shim' form factor is designed to avoid mechanical collisions with other Raspberry Pi hats.</p> <p>An extra-tall stacking pin header ensures compatibility with most Raspberry Pi enclosures.</p> <p>Assembly is implicit from the PCB layout, with the exception of the stacking pin header which attaches as shown in the photo below.</p>"},{"location":"assembly/raspberry-pi-shim-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/rotary-encoder-module-assembly/","title":"Rotary Encoder Module","text":"<p>Left, V1; right V2</p> <p>The Rotary encoder module interfaces a 1024-position quadrature rotary encoder (e.g. Yumo E6B2-CWZ3E) with the Bpod state machine and its governing computer. It can be used to capture paw movements, and generate behavioral events when position thresholds are crossed. There are two versions of the module with unique capabilities.</p> <p>Version 1 (left, above) can stream the current position directly to the DDS or Analog Output module for low-latency closed loop sensory feedback. It can also log data to a microSD card during each experimental trial and dump it back between trials (instead of returning data via USB) if processing bandwidth is limited in your assay.</p> <p>Version 2 (right, above) has a 2-channel analog output interface to synchronize the current wheel position and 3.3V sync pulses directly with Ephys or microscopy systems. It also has a much more powerful processor, allowing for more complex event threshold criteria.</p> <p>Both models are compatible with Bpod State Machine r0.7 or newer.</p> <p>Hardware Specs:</p> <ul> <li>Arduino-compatible ARM Cortex processors. V1: Cortex M4, 120MHz (Teensy 3.5, PJRC). V2: Cortex M7, 600MHz (Teensy 4.0, PJRC)</li> <li>Screw terminal interface connects directly to rotary encoder wires</li> <li>2 digital i/o lines exposed, capable of forming a hardware I2C interface for custom applications (V1 only)</li> <li>2 analog output channels: 12-bit, 0-4V (V2 only)</li> <li>Design files for a 3D-printable mount and paw-manipulation wheels are provided in the Sanworks Bpod-CAD repository.</li> </ul> <p>Firmware for the Rotary Encoder module is available here.</p>"},{"location":"assembly/rotary-encoder-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/rotary-encoder-module-assembly/#version-1","title":"Version 1","text":""},{"location":"assembly/rotary-encoder-module-assembly/#version-2","title":"Version 2","text":""},{"location":"assembly/snes-module-assembly/","title":"SNES Module","text":"<p>The SNES module interfaces a Super Nintendo controller with Bpod. This provides a convenient button array for psychophysics tasks using human subjects. Pressing or releasing each of the gamepad's buttons generates a unique event that can be handled by the state machine. The gamepad's button states are read by the module at ~20kHz and detected events drive the state machine in ~100 microseconds, providing excellent temporal resolution on button press events. To validate the module, we dissected the popular aftermarket controller pictured above, and soldered leads to the button footprint on its PCB, allowing us to create button press events with known onset times.</p> <p>Compatible with Bpod 0.7+</p> <p>Hardware Specs:</p> <ul> <li>Arduino-compatible 48MHz ARM Cortex M0 processor (SAMD21 Breakout, Sparkfun Electronics)</li> <li>Circuitry to optionally derive controller power from Pocket State Machine (no separate USB cable required)</li> </ul> <p>Firmware for the SNES module is available here.</p>"},{"location":"assembly/snes-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/state-machine-assembly-0_5/","title":"State Machine 0.5","text":"<p>Bpod's state machine module can be assembled in as little as one hour at a soldering bench. Here's how.</p> <ol> <li>Order all parts in the Bill of Materials<ul> <li>These parts can be purchased from commercial suppliers with two exceptions:<ul> <li>The printed circuit board. We have previously used SeeedStudio's FusionPCB service as follows:<ul> <li>QTY: 10</li> <li>PCB Layer: 2</li> <li>PCB Thickness: 1.6mm</li> <li>PCB Dimension: 10cm max X 15cm max</li> <li>PCB Color: green</li> <li>Surface Finish: HASL</li> <li>This should work out to ~$5.50 per board for an order of 10 boards (Jan 2014). Select \"Next\".</li> <li>Select C:\\Bpod\\CAD\\PCB\\BpodDevice\\BpodGerber.zip and finish the order.</li> </ul> </li> <li>The acrylic enclosure. We have previously used Pololu's Custom laser cutting service as follows:<ul> <li>Select \"Request a Quote\"</li> <li>Next to \"My Files\" click \"Browse\" and select C:\\Bpod\\CAD\\Enclosure\\BpodEnclosure_r0_5_X.cdr, where X is the latest version number available.</li> <li>Next to \"Quantity\" enter \"N copies of layout provided\" to order N Bpod enclosures.</li> <li>Under \"Material Selection\" choose \"Use This Material\" to the right of the line: 3.0mm (1/8\") / translucent / clear matte</li> <li>Acknowledge the limitations and submit the quote request. Once the quote is provided (1-2 days), place an order for the enclosure.</li> </ul> </li> </ul> </li> </ul> </li> <li>Gather tools. You'll need:<ul> <li>A clean soldering iron and sponge</li> <li>Solder</li> </ul> </li> <li>Follow the assembly instructions.</li> </ol>"},{"location":"assembly/state-machine-assembly-0_5/#assembly-instructions","title":"Assembly Instructions","text":"<p>Before assembly, ensure that you have all parts specified in the bill of materials in appropriate quantities. You will also need a soldering iron, solder, wire cutters, water, a soldering sponge, a small Phillips head screwdriver, and about one hour if this is your first time building a Bpod.</p> <p>The order of assembly below is determined by height of the components on the board, for easy positioning during soldering.</p> <p>If you are new to soldering a circuit board with ICs, see this &lt; 2-minute video tutorial for power-tips.</p> <p>First, we will solder components into the printed circuit board. It looks like this:</p> <p>Note</p> <p>Image missing in original wiki</p> <p>Figure 1: The Bpod r0.5 printed circuit board</p>"},{"location":"assembly/state-machine-assembly-0_5/#step-1-add-resistors-mosfets-and-status-led","title":"Step 1: Add resistors, MOSFETs and status LED","text":"<p>Required components: - 10K resistors x 2. (BOM Part#7) - 1K resistors x 2. (BOM Part#8) - 47 ohm resistor (BOM Part#9) - MOSFET x2 (BOM Part#18) - RGB LED (BOM Part#12)</p> <p>Instructions: - Solder the resistors as shown in Figure 2. - Solder the MOSFETS. Make sure the flat side matches the circuit board notation. Insert until they are nearly flush with the board. - The RGB LED has a flat corner. Align it with the corner on the board notation, or as shown in Figure 2.</p> <p>The board should now appear as illustrated in Figure 2.</p> <p></p> <p>Figure 2: The board after adding resistors, MOSFETs and status LEDs</p>"},{"location":"assembly/state-machine-assembly-0_5/#step-2-add-integrated-circuits","title":"Step 2: Add integrated circuits","text":"<p>Required components: - SFH6732 Optical Isolator. (BOM Part#4) - TPIC6A595 Power shift register. (BOM Part#2) - CD4050BE level shifter x3 (BOM Part#5) - 74HC595N TTL shift register (BOM Part#3)</p> <p>Instructions: - Solder the integrated circuits as shown in Figure 3. Make sure the notches in the ICs line up with the notches annotated on the board. - The optoisolator IC has a small circular indentation to indicate the end with the notch.</p> <p>The board should now appear as illustrated in Figure 3.</p> <p></p> <p>Figure 3: The board after adding ICs</p>"},{"location":"assembly/state-machine-assembly-0_5/#step-3-add-arduino-headers-rectangular-pin-headers-and-the-tdk-lambda-integrated-voltage-converter","title":"Step 3: Add Arduino headers, rectangular pin headers and the TDK Lambda integrated voltage converter","text":"<p>Required components: - 6-pin Arduino header. (BOM Part#20) - 8-pin Arduino header x4. (BOM Part#21) - 2x36-pin male rectangular header (BOM Part#10) - 2x3 pin female rectangular header (BOM Part#11) - TDK Lambda voltage converter (BOM Part#6)</p> <p>Instructions: - Solder the four 8-pin Arduino headers. They are labeled on the board: Due_Digital1, Due_Digital2, Due_Digital3 and Due_ALG. DO NOT CUT THE LEADS AFTER SOLDERING! They will be used to plug this board in to Arduino. On each header, solder one pin first, ensure the pins point straight down, then solder the others. - Solder the 6-pin Arduino header. Do not cut the leads. - Cut the 2x36-pin male header in half with a wire cutter to make a 2x18. Place the board on top of it so the silver side of the pins sticks through the board, and solder from the top as illustrated in Figure 4. - Place the board on top of the 2x3 female header, and solder from the top. - Solder the voltage converter. </p> <p>The board should now appear as illustrated in Figure 4.</p> <p></p> <p>Figure 4: The board after adding headers and voltage converter</p>"},{"location":"assembly/state-machine-assembly-0_5/#step-4-add-ethernet-jacks-spring-terminal-and-bnc-jacks","title":"Step 4: Add Ethernet jacks, spring terminal and BNC jacks","text":"<p>Required components: - Ethernet jack x11. (BOM Part#13) - Spring terminal. (BOM Part#1) - BNC jack x4 (BOM Part#14)</p> <p>Instructions: - Snap the Ethernet jacks into place and solder their leads. - Solder the spring terminal - Solder the BNC jacks, making sure they are resting on the board and pointing out at a 90 degree angle. This is important for the enclosure to fit.</p> <p>The completed board should now appear as illustrated in Figure 5.</p> <p></p> <p>Figure 5: The completed board after adding Ethernet jacks, spring terminals and BNC jacks</p>"},{"location":"assembly/state-machine-assembly-0_5/#step-5-add-stand-offs-and-arduino-due","title":"Step 5: Add stand-offs and Arduino Due","text":"<p>Required components: - 1\" 4-40 screw x4. (BOM Part#22) - 3/4\" 4-40 stand-off. (BOM Part#24) - Arduino Due Microcontroller (BOM Part#25)</p> <p>Instructions: - Place a screw in each corner hole, pointing down through the board. - Screw a stand-off on each corner screw until it is flush with the board. - Plug Arduino Due into the bottom of the board. The 18x2 pin header will resist - squeezing from above the header and below Arduino will help.</p> <p>The completed board should now appear as shown from above:</p> <p></p>"},{"location":"assembly/state-machine-assembly-0_5/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/state-machine-assembly-0_9-1_0/","title":"State Machine 0.9 - 1.0","text":"<p>The difference between 0.9 and 0.8 only affects the BNC input channels.</p> <p>On v0.5-0.8, an optoisolator IC was used to isolate the BNC inputs (and also the wire terminal inputs, as of Bpod 0.7).</p> <p>Unfortunately, that part was discontinued by the manufacturer.</p> <p>For v0.9, we switched to a different, pin-compatible optoisolator IC. We provided a series resistor with a different value (1k, previously 220 ohm) and a decoupling capacitor for each IC.  From the perspective of the MATLAB/Python software these hardware versions are identical.</p>"},{"location":"assembly/state-machine-assembly-0_9-1_0/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/state-machine-assembly-2%2B/","title":"State Machine 2+","text":"<p>Bpod Finite State Machine r2+ builds on r2.5 with additional onboard I/O: - 4 Flex I/O Channels can each be configured as:     - Digital Output (5V TTL)     - Digital Input (5V tolerant)     - Analog Input (12-bit, 0-5V range, 1kHz sampling)     - Analog Output (12-bit, 0-5V range) - 1 additional behavior port, for a total of 5</p> <p>Version 2+ also has an improved enclosure developed in collaboration with BZDesign. The new enclosure's 3D-printed scaffolding secures its laser-cut panels.</p>"},{"location":"assembly/state-machine-assembly-2%2B/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/state-machine-assembly-2_3-2_4/","title":"State Machine 2.3-2.4","text":"<p>Bpod Finite State Machine r2.3 is a minor hardware revision of r2.0.</p> <ul> <li>r2.3 adds pull-up resistors to the mouse port input channels, stabilizing them when disconnected from the port interface board (note: disconnected ports should still be disabled in software for optimized data processing).</li> <li>r2.3 does not have jumpers to disconnect the DC converters on module ports 1-3, as these were deemed unnecessary.</li> </ul> <p>Bpod Finite State Machine r2.4 improves on r2.3 with several minor improvements and component substitutions: - 2.4 adds light termination resistors to the RS-485 receive lines for the 5 module interfaces. On previous versions, if no module was connected to a module port, some ports would receive an occasional spurious byte 255, which is an invalid event code and is ignored in firmware.  - r2.4 replaces the BNC output isolator (Analog Devices ADUM5240) with a more energy-efficient chip: ADUM6200. - r2.4 replaces the module 5V-&gt;9V DC/DC converter (Murata MTU1S0509MC) with a more readily available converter: Murata MEE1S0509SC.</p> <p>Beginning with r2.4, an array of microcontroller pins is used to read out the board revision number. Bits in the array are grounded, and the version number is incremented with each board revision. State machine firmware v23 reads the board revision number, and the PC software saves it with each dataset.</p> <p>Note: r2.1 and r2.2 were minor tweaks to the 2.0 PCB that did not affect the BOM (e.g. silkscreen updates, widening of certain solder pads, changes to the barrel jack solder pad shape).</p>"},{"location":"assembly/state-machine-assembly-2_3-2_4/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/state-machine-assembly-2_3-2_4/#23","title":"2.3","text":""},{"location":"assembly/state-machine-assembly-2_3-2_4/#24","title":"2.4","text":""},{"location":"assembly/state-machine-assembly-2_5/","title":"State Machine 2.5","text":"<p>Bpod Finite State Machine r2.5 is a significant hardware revision of r2.4.</p> <ul> <li>r2.5 upgrades the Teensy 3.6 microcontroller to Teensy 4.1.  Improvements relevant to Bpod are:<ul> <li>Significantly faster processing (600MHz, up from 180MHz)</li> <li>Significantly more SRAM memory (1MB, up from 256KB)</li> <li>Significantly faster USB data transfer (480Mbit/s, up from 12Mbit/s)</li> </ul> </li> <li>r2.5 has a dual footprint for the 5V-&gt;9V DC/DC converters (required for each module port), allowing the board to be populated with either Murata MTU1S0509MC or Murata MEE1S0509SC. This increases robustness against supply chain interruptions.</li> <li>Due to the change in microcontroller pinout, r2.5 must be run with State Machine Firmware v23 or newer.</li> </ul>"},{"location":"assembly/state-machine-assembly-2_5/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/teensy-shield-assembly/","title":"Teensy Shield","text":"<p>A shield is now available to interface Teensy 3.X with the Bpod state machine.</p> <p>It uses Teensy digital channels 0 and 1 for communication, and provides power to the Teensy board (if used with state machine r2 or newer)</p> <p>Example Arduino files for use with the Teensy shield + Teensy 3.2 are available here.</p>"},{"location":"assembly/teensy-shield-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/valve-driver-module-assembly/","title":"Valve Driver Module","text":"<p> Version 1, released November 2017</p> <p>The valve driver module controls 8 solenoid valves. Valve currents are galvanically isolated from control logic circuitry.</p> <p>The module is most often used in behavior research for temporally precise air flow control and liquid dispensing.</p> <p>Compatible with Bpod 0.7+</p> <p>Hardware Specs:</p> <ul> <li>Processor:\u00a0<ul> <li>v1: Arduino-compatible 48MHz ARM Cortex M0 processor (SAMD21 Breakout, Sparkfun Electronics)</li> <li>v2: Arduino-compatible 600MHz ARM Cortex M7 processor (Teensy 4.0, PJRC)</li> </ul> </li> <li>Highly integrated isolated high-side current driver (Infineon ISO1H815G).</li> <li>Compatible with 12V-24V solenoid valves.</li> <li>Max valve current: 250mA continuous current / channel (with spec-matched DC wall adapter)</li> <li>Valve side powered by standard DC wall adapter (2.1mm barrel jack, positive center)</li> <li>Buffered RS485 interface to Bpod State Machine</li> <li>Can be powered by Module ports 1-3 of State Machine r2 or newer (no separate USB cable required)</li> </ul> <p>Firmware for the valve driver module is available here.</p>"},{"location":"assembly/valve-driver-module-assembly/#bill-of-materials","title":"Bill of Materials","text":""},{"location":"assembly/valve-driver-module-assembly/#version-1","title":"Version 1","text":""},{"location":"assembly/valve-driver-module-assembly/#version-2","title":"Version 2","text":""},{"location":"function-reference/","title":"Function Reference","text":"<p>This section contains documentation of Bpod's functions. Bpod's functions, stored in Bpod_Gen2/Functions/, are added onto MATLAB's Path at startup when <code>Bpod</code> is used.</p> <p>The sidebar section on the left contains sections for functions, grouped into categories.</p> <p>Because all of the functions in the Functions/ folder are added onto the Path, Bpod always has access to functions like 'TrialTypeOutcomePlot()' regardless of which protocol is active. Protocol specific functions should be placed within the protocol folder.</p>"},{"location":"function-reference/bpodsystem-fields/","title":"BpodSystem fields","text":"<p><code>BpodSystem</code> exists in the workspace as a global object. It has the following fields:</p>"},{"location":"function-reference/bpodsystem-fields/#data","title":"Data","text":"<p>Description</p> <p>Stores session data as a <code>struct</code>.</p> <ul> <li>Typically stores the output of <code>AddTrialEvents</code> and other data added as subfields.</li> <li>Can be saved automatically with the <code>SaveBpodSessionData</code> function.</li> </ul> <p>Example</p> <p>This code sends \"sma\" (an existing state matrix) to Bpod, runs it 10 times, and packages the raw events for analysis.  It then saves them to disk on each trial. </p> <pre><code>SendStateMatrix(sma);\nfor i = 1:10\nRawEvents = RunStateMatrix;\nBpodSystem.Data = AddTrialEvents(BpodSystem.Data, RawEvents);\nBpodSystem.Data.arbitrarydata = rand(1,10); % Anything can be added\nSaveBpodSessionData;\nend\n</code></pre>"},{"location":"function-reference/bpodsystem-fields/#protocolsettings","title":"ProtocolSettings","text":"<p>Description</p> <p>Saves the struct BpodSystem.ProtocolSettings to disk.</p> <ul> <li>The settings in BpodSystem.ProtocolSettings are saved over the file targeted when selecting settings in the launch manager.</li> </ul> <p>Syntax</p> <p><code>SaveProtocolSettings()</code></p> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code checks the selected settings file to see if it has been populated - and if not, adds default values. <pre><code>S = BpodSystem.ProtocolSettings; % Load settings chosen in launch manager into current workspace as a struct called S\nif isempty(fieldnames(S))   % If settings file was an empty struct,\n% populate struct with default settings\nS.SoundDuration = 0.5;  % Duration of sound (s)\nS.RiotDuration = 7.5;   % Duration of riot(s)\nend\nBpodSystem.ProtocolSettings = S;\nSaveProtocolSettings; % Saves the default settings to the disk location selected in the launch manager.\n</code></pre></p>"},{"location":"function-reference/bpodsystem-fields/#softcodehandlerfunction","title":"SoftCodeHandlerFunction","text":"<p>Description</p> <p>Equal to the full path of a soft code handler m-file to use with the current protocol.</p> <p>Example</p> <p>For another example of a soft code handler, see Examples/Protocols/. PsychToolboxSound/ contains complete examples of a protocol state matrix construction using SoftCodeHandler_PlaySound.m</p> <pre><code>% 1. (main protocol file): This single-state matrix sends a byte (3) back to the\n% governing computer on state entry by setting a 'SoftCode' in Output Actions.\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'State1', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'SoftCode', 3});\n% Part 2 (in main protocol file): This code specifies which file will handle the\n% byte when it comes back.\nBpodSystem.SoftCodeHandlerFunction = 'SoftCodeHandler_Printout';\n% Part 3 (separate file in protocol folder): This code handles the byte by \n% printing it to the MATLAB command window.\nfunction SoftCodeHandler_Printout(Byte)\ndisp(Byte);\n</code></pre>"},{"location":"function-reference/bpodsystem-fields/#protocolfigures","title":"ProtocolFigures","text":"<p>Description</p> <p>A struct for handles of figures that display online data.</p> <ul> <li>Since <code>BpodSystem</code> is a global variable, the figure handles in this struct will be available in figure update functions and in the main protocol function.</li> <li>All figures in <code>BpodSystem.ProtocolFigures</code> will automatically be closed when the protocol ends.</li> </ul> <p>Example</p> <p>This code initializes a new figure to show data, and adds its handle to <code>BpodSystem.ProtocolFigures</code>. At the conclusion of the session it will be closed. <pre><code>BpodSystem.ProtocolFigures.MyPlotFig = figure('Position', [200 200 1000 200],...\n'name', 'My Plots');\n</code></pre></p>"},{"location":"function-reference/bpodsystem-fields/#emulatormode","title":"EmulatorMode","text":"<p>Description</p> <p>When no Bpod device is found, the user can launch the Bpod software in emulator mode.</p> <ul> <li>BpodSystem.EmulatorMode is automatically set to 1 in emulator mode (0 = default, actual hardware).</li> <li>Emulator mode is a tool for protocol development; timing data and sound / visual display timing may be imprecise depending on the platform. Protocols developed with the emulator should be validated on hardware prior to any experiment.</li> <li>Inputs are read and the hardware state is indicated on the Bpod console while running a state machine.</li> <li>When designing a protocol that can be run in emulator mode, block off code that interfaces with unavailable hardware (see example).</li> </ul> <p>Example</p> <p>This code connects to a remote TCP server using the SerialEthernet plugin, only if NOT in emulator mode. <pre><code>if BpodSystem.EmulatorMode == 0\nSerialEthernet('Init', 'COM65'); % Set COM port for Arduino Leonardo\npause(1);\nRemoteIP = [192 168 0 104]; RemotePort = 3336;\nSerialEthernet('Connect', RemoteIP , RemotePort);\nelse\ndisp('Fake-connected to a fake TCP server')\nend\n</code></pre></p>"},{"location":"function-reference/bpodsystem-fields/#statemachineinfo","title":"StateMachineInfo","text":"<p>Description</p> <p>A struct containing human-readable information about the currently connected state machine hardware.</p> <p>Different state machine devices will populate this struct differently, resulting in different possible events and outputs.</p> <p>It has the following fields:</p> <ul> <li>nEvents: the total number of unique events monitored from input channels</li> <li>EventNames: A character string naming each event <ul> <li>Each event is a state of an input channel</li> <li>Use these with the <code>AddState()</code> function when writing state machines.</li> </ul> </li> <li>InputChannelNames: A character string naming each input channel<ul> <li>Each channel is capable of generating multiple states</li> <li>Use these with the <code>SetCondition()</code> function</li> </ul> </li> <li>nOutputChannels: the total number of unique output channels</li> <li>OutputChannelNames: A character string naming each output channel</li> <li>Use these with the <code>AddState()</code> and <code>SetGlobalTimer()</code> functions</li> <li>MaxStates: The maximum number of states supported by the connected state machine</li> </ul> <p>Example</p> <p><code>&gt;&gt; BpodSystem.StateMachineInfo.OutputChannelNames</code> <pre><code>ans = \n\n  Columns 1 through 7\n    'Serial1'    'Serial2'    'Serial3'    'SoftCode'    'ValveState'    'BNC1'    'BNC2'\n\n  Columns 8 through 15\n    'Wire1'    'Wire2'    'Wire3'    'PWM1'    'PWM2'    'PWM3'    'PWM4'    'PWM5'\n\n  Columns 16 through 20\n    'PWM6'    'PWM7'    'PWM8'    'GlobalTimerTrig'    'GlobalTimerCancel'\n\n  Column 21\n    'GlobalCounterReset'\n</code></pre></p>"},{"location":"function-reference/bpodsystem-fields/#status","title":"Status","text":"<p>Description</p> <p><code>BpodSystem.Status</code> is a struct populated with system status variables. Most subfields are used internally by the GUI. </p> <p><code>BpodSystem.Status.BeingUsed</code> indicates whether a behavior session is running.</p> <ul> <li>BeingUsed is set to 1 when:<ul> <li>A state machine is run using <code>RunStateMachine()</code> or <code>BpodTrialManager</code></li> <li>A session is started with <code>RunProtocol()</code> or the Launch Manager</li> </ul> </li> <li>BeingUsed is set to 0 when:<ul> <li>The 'Stop' or 'Pause' buttons are pressed on the Bpod Console GUI</li> <li>The session is stopped with <code>RunProtocol('Stop')</code></li> </ul> </li> </ul> <p>Example</p> <p>When the user ends the session, this code calls a user-defined cleanup function before exiting</p> <pre><code>if BpodSystem.Status.BeingUsed == 0\nbreak\nend\n</code></pre>"},{"location":"function-reference/bpodsystem-fields/#flexioconfig","title":"FlexIOConfig","text":"<p>Description</p> <p>FlexIOConfig is a struct used to configure Flex I/O channels. Flex I/O channels can each be configured as:</p> <ul> <li>Digital Input</li> <li>Digital Output</li> <li>Analog Input (12-bit, 0-5V)</li> <li>Analog Output (12-bit, 0-5V)</li> <li>High Impedance (channel disabled)</li> </ul> <p>Other configuration settings in FlexIOConfig concern channel(s) configured as analog input:</p> <ul> <li>Sampling Rate</li> <li>ADC measurements per sample</li> <li>Threshold configuration</li> </ul> <p>FlexIOconfig is attached to a callback function. Any changes to the struct are automatically sent to the state machine.</p> <p>Properties</p> <ul> <li>channelTypes: An array containing the Flex I/O configuration. The array must specify a configuration for each Flex I/O channel.<ul> <li>Configuration values<ul> <li>0: Digital Input</li> <li>1: Digital Output</li> <li>2: Analog Input</li> <li>3: Analog Output</li> <li>4: Disabled (High Impedance)</li> </ul> </li> <li>On calling FlexIOConfig.channelTypes(), the composition of valid state machine events and output actions will be updated to match the requested channel types.</li> <li>Note: a GUI is provided to set the Flex I/O configuration manually, from the settings menu on the Bpod Console. If set from the GUI, the configuration will be loaded automatically to the device each time Bpod is started. FlexIOconfig.channelTypes is useful for reconfiguring the Flex I/O channels when launching an experimental protocol.</li> </ul> </li> <li>analogSamplingRate: The rate of sample acquisition for all Flex I/O channels configured as analog input<ul> <li>Units: Hz</li> <li>Range: [1, 1000]</li> </ul> </li> <li>nReadsPerSample: The number of ADC reads to average for each sample acquired. ADC reads are measured consecutively, and each read takes ~2 microseconds. Increasing reads per sample reduces the effect of high-frequency noise.<ul> <li>Range: [1, 4]</li> </ul> </li> <li>threshold1, threshold2: A 1x4 array specifying an event threshold for each channel. Each Flex I/O channel has two configurable thresholds, contained in threshold1 and threshold2 respectively.</li> <li>Unit  s: Volts</li> <li>polarity1, polarity2: A 1x4 array specifying the polarity of each channel's threshold. <ul> <li>0: An event is generated when voltage is above the threshold</li> <li>1: An event is generated when voltage is below the threshold</li> </ul> </li> <li>thresholdMode: A 1x4 array specifying the mode of each threshold. All thresholds are disabled when reached.<ul> <li>0: Thresholds must be manually re-enabled using the 'AnalogThreshEnable' output action.</li> <li>1: For a single Flex I/O channel, crossing threshold 1 enables threshold 2. Crossing threshold 2 enables threshold 1.</li> </ul> </li> </ul> <p>Examples</p> <p>This code configures channel 1 as an analog input and channel 2 as an analog output. All other channels are configured as high impedance. <pre><code>BpodSystem.FlexIOConfig.channelTypes = [2 3 4 4];\n</code></pre></p> <p>This code configures channel 1's two thresholds to 4V (threshold 1) and 2V (threshold 2). Threshold 2 is set to detect voltage below 2V. Thresholds are set to enable each other when crossed. This setup can be used to generate an event on the rising and falling phases of a cyclic signal.</p> <pre><code>Chan = 1;\nBpodSystem.FlexIOConfig.channelTypes(Chan) = 2; % Set Flex I/O Ch1 as analog input\nBpodSystem.FlexIOConfig.threshold1(Chan) = 4;\nBpodSystem.FlexIOConfig.threshold2(Chan) = 2;\nBpodSystem.FlexIOConfig.polarity1(Chan) = 0;\nBpodSystem.FlexIOConfig.polarity2(Chan) = 1;\nBpodSystem.FlexIOConfig.thresholdMode(Chan) = 1;\n</code></pre> <p>This code configures the sampling rate and number of ADC reads per sample for all analog inputs. <pre><code>BpodSystem.FlexIOConfig.analogSamplingRate = 100; % Set Flex I/O analog input sampling rate to 100Hz\nBpodSystem.FlexIOConfig.nReadsPerSample = 2; % Set Flex I/O analog input to 2 averaged ADC reads per sample\n</code></pre></p> <p>A behavior protocol demonstrating use of Flex I/O channels for analog acquisition is given in the Bpod_Gen2 repository here.</p> <p>Note</p> <p>Flex I/O channels were introduced with Bpod State Machine 2+ in 2022, and may also exist on newer models.</p>"},{"location":"function-reference/bpodsystem-functions/","title":"BpodSystem functions","text":""},{"location":"function-reference/bpodsystem-functions/#assertmodule","title":"<code>assertModule()</code>","text":"<p>Description</p> <p>Throws an error if a given Bpod module is not present. - An optional argument specifies whether the module must also be paired with its USB serial port via the USB pairing UI. - After connecting a new module, you must press the 'refresh' button on the [Bpod console GUI] to make it visible to <code>assertModule()</code>.</p> <p>Syntax</p> <p><code>BpodSystem.assertModule(moduleNames, USBPaired)</code></p> <p>Parameters</p> <ul> <li><code>moduleNames</code>: a character array containing the name of the module. A cell array of strings may also be provided to assert multiple modules. Note: The names of connected modules are given in BpodSystem.Modules</li> <li><code>USBPaired</code>: optional, an array of 1s and 0s with one value for each module in moduleNames. <ul> <li>1 = the module must be paired with its USB serial port. </li> <li>0 = the module does not have to be paired.</li> </ul> </li> </ul> <p>Return</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code will throw an error if the HiFi or ValveDriver modules are missing. It will also throw an error if the HiFi module is not paired with its USB serial port. <pre><code>BpodSystem.AssertModule({'HiFi', 'ValveDriver'}, [1 0]);\n</code></pre></p>"},{"location":"function-reference/bpodsystem-functions/#setstatusled","title":"<code>setStatusLED()</code>","text":"<p>Description</p> <p>Enables or disables the status indicator LED on the Bpod finite state machine.</p> <ul> <li>If disabled, the status LED will remain off until the state machine is power cycled, or until re-enabled with <code>setStatusLED()</code></li> <li><code>setStatusLED()</code> requires state machine firmware v23 or newer</li> </ul> <p>Syntax <pre><code>BpodSystem.setStatusLED(status) </code></pre></p> <p>Parameters</p> <ul> <li>status<ul> <li>0 = LED off</li> <li>1 = LED on</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code will disable the state machine status LED <pre><code>BpodSystem.setStatusLED(0);\n</code></pre></p>"},{"location":"function-reference/bpodsystem-functions/#startanalogviewer","title":"<code>startAnalogViewer()</code>","text":"<p>Description</p> <p>Launches a viewer for Flex I/O channels configured as analog input.</p> <p></p> <ul> <li>The viewer can also be launched from the Bpod console</li> <li>The viewer can run during the behavior session for online monitoring (note: the UI may add jitter to soft-code processing if using TrialManager).</li> <li>Pushbuttons are:<ul> <li>REC: Press to record to the current analog data file. Recording starts with the next behavior session.</li> <li>Note: The analog data file is created automatically when starting a session. It has the same path and naming convention as the primary data file. It can be merged into the primary data file at the end of the session by calling AddFlexIOAnalogData().</li> </ul> </li> <li>DC: Press to subtract the DC offset from all signals (in the viewer only; logged data is unaffected)</li> <li>s/Div: Adjust seconds per division on the viewer grid. The 'Time' label on the bottom info bar shows the current time per division.</li> <li>V/Div: Adjust volts per division on the viewer grid. </li> </ul> <p>Syntax <pre><code>BpodSystem.startAnalogViewer() </code></pre></p> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code will launch the analog viewer <pre><code>BpodSystem.startAnalogViewer();\n</code></pre></p>"},{"location":"function-reference/data-storage/","title":"Data storage","text":""},{"location":"function-reference/data-storage/#savebpodsessiondata","title":"<code>SaveBpodSessionData()</code>","text":"<p>Description</p> <p>Saves the struct BpodSystem.Data to a data file.</p> <ul> <li>The file name is determined automatically based on selections made in the launch manager, and the current time.</li> <li>The file is formatted as a MATLAB .mat file.</li> </ul> <p>Syntax</p> <pre><code>SaveBpodSessionData()\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code sends \"sma\" (an existing state matrix) to Bpod, runs it 10 times, and packages the raw events for analysis. On each trial, the session data is saved to disk.</p> <pre><code>SendStateMatrix(sma);\nfor i = 1:10\nRawEvents = RunStateMachine;\nBpodSystem.Data = AddTrialEvents(BpodSystem.Data, RawEvents);\nSaveBpodSessionData;\nend\n</code></pre>"},{"location":"function-reference/data-storage/#saveprotocolsettings","title":"<code>SaveProtocolSettings()</code>","text":"<p>Description</p> <p>Saves the struct BpodSystem.ProtocolSettings to disk.</p> <ul> <li>The settings in BpodSystem.ProtocolSettings are saved over the file targeted when selecting settings in the launch manager.</li> </ul> <p>Syntax</p> <pre><code>SaveProtocolSettings()\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code checks the selected settings file to see if it has been populated - and if not, adds default values.</p> <pre><code>S = BpodSystem.ProtocolSettings; % Load settings chosen in launch manager into current workspace as a struct called S\nif isempty(fieldnames(S))  % If settings file was an empty struct, populate struct with default settings\nS.SoundDuration = 0.5; % Duration of sound (s)\nS.RiotDuration = 7.5; % Duration of riot(s)\nend\nBpodSystem.ProtocolSettings = S;\nSaveProtocolSettings; % Saves the default settings to the disk location selected in the launch manager.\n</code></pre>"},{"location":"function-reference/data-storage/#addflexioanalogdata","title":"<code>AddFlexIOAnalogData()</code>","text":"<p>Description</p> <p>Reads the current Flex I/O analog data file into memory, and adds it to a Bpod behavior data structure.</p> <p>Adding analog data is a long operation and is typically run once at the end of each session.</p> <p>This function will only work with state machine r2+ or other models with Flex I/O channels.</p> <p>Syntax</p> <pre><code>BehaviorDataOut = AddFlexIOAnalogData(BehaviorDataIn, [sampleFormat], [addSamplesByTrial]) % Note: [ ] indicates an optional argument\n</code></pre> <p>Parameters</p> <ul> <li>BehaviorDataIn: a Bpod behavior data structure. <ul> <li>During a session, use BpodSystem.Data. </li> <li>To add analog data post-hoc (e.g. for a crashed session) BehaviorDataIn is the data structure loaded to the workspace</li> </ul> </li> <li>sampleFormat: a string indicating the format to import<ul> <li>'Volts' (default): Samples are imported as double type (8 bytes per sample). Units = volts.</li> <li>'Bits': Samples are imported as uint16 type in range 0-4095 (2 bytes per sample). Bits represent volts in range 0-5.</li> <li>Note: Store samples as bits for smaller data files, and convert to volts at analysis time: <ul> <li>Volts = (double(Bits)/4095)*5</li> </ul> </li> </ul> </li> <li>addSamplesByTrial:<ul> <li>1 = add a cell array with a cell for each experimental trial, where each cell contains all samples acquired during that trial. This can also be done by user code at analysis time to save disk space.</li> <li>0 = Do not add trial-aligned duplicate data</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>BehaviorDataOut: the Bpod behavior data structure passed into the function, with added analog data</li> </ul> <p>Examples</p> <p>This code will import the current Flex I/O analog data into the primary behavior data structure at the end of a behavior session. Samples are stored as bits to save space, and a cell array of samples per trial is added.</p> <pre><code>if BpodSystem.Status.BeingUsed == 0\nBpodSystem.Data = AddFlexIOAnalogData(BpodSystem.Data, 'Bits', 1); Adds FlexI/O analog data to BpodSystem.Data\nSaveBpodSessionData; % Saves BpodSystem.Data to the current data file\nbreak\nend\n</code></pre> <p>This code will add previously acquired analog data offline. Note that his must be done on the same PC that acquired the data, and assumes that the data has not been moved from its original location on the disk. <pre><code>load MyDataFile;  % MyDataFile is a .mat file of saved Bpod session data. A struct called SessionData is         \n% created in the local workspace.\nSessionData = AddFlexIOAnalogData(SessionData, 'Volts'); % Import the analog data as volts\n</code></pre></p>"},{"location":"function-reference/general-plugins/","title":"General Plugins","text":""},{"location":"function-reference/general-plugins/#bpodparametergui","title":"<code>BpodParameterGUI()</code>","text":"<p>Description</p> <p>Displays the settings from the \"GUI\" subfield of a settings struct. Supports advanced GUI parameters and pushbutton call of user functions.</p> <ul> <li>The GUI subfield names (i.e. X in Settings.GUI.X) are displayed as labels on the left. Edit boxes populated with parameter values for each X are shown on the right.</li> <li>In the current version, only numerical parameters are valid.</li> <li>By default, text edit boxes are used to show parameters. Other UI types can be specified.</li> <li>By default, all parameters are clustered on one UI panel. Parameter groups can be specified.</li> <li>When synced, the GUI will display any programmed updates to the parameter values since the last sync. </li> <li>If the user manually edited a parameter, this becomes the new value irrespective of automated changes.</li> </ul> <p>Syntax</p> <p>On the first call (before Main Loop): <pre><code>BpodParameterGUI('init', SettingsStructure)\n</code></pre></p> <p>On subsequent calls (once per trial): <pre><code>SettingsStructure = BpodParameterGUI('sync', SettingsStructure)\n</code></pre></p> <p>Parameters</p> <ul> <li>Settings: A <code>struct</code> of settings and parameters with at least some numeric parameters in the subfield \"GUI\"</li> <li>Optionally, a GUIMeta field can be included in Settings<ul> <li>GUIMeta subfields are formatted as <code>GUIMeta.(parameterName).(attribute) = value</code></li> <li>GUIMeta attributes are:<ul> <li>Style: 'popupmenu', 'checkbox', 'pushbutton', 'text', 'edit'           - (See Examples for usage)</li> <li>String: a cell array of strings for popumenu</li> </ul> </li> </ul> </li> <li>Optionally, a GUIPanels fiels can be included in Settings<ul> <li>GUIPanels subfields are formatted as <code>GUIPanels.(panelName) = {parameterNames}</code></li> </ul> </li> </ul> <p>Return</p> <ul> <li>A settings structure, updated with any parameter changes manually entered by the user in the GUI</li> </ul> <p>Examples</p> <p>Intializes a UI for a Bpod setting struct on protocol launch, and syncs it on each of 10 trials</p> <pre><code>% Import settings or populate if empty\nS = BpodSystem.ProtocolSettings; % Load settings chosen in launch manager into current workspace as a struct called S\nif isempty(fieldnames(S))  % If an empty struct, populate struct with default settings\nS.GUI.SineWaveFrequency = 500; % Frequency of stimulus\nS.GUI.SpeakerType = 1; % Type of speaker\nend\n% Initialize parameter GUI plugin\nBpodParameterGUI('init', S);\n% Run 10 trials:\nfor currentTrial = 1:10\nS = BpodParameterGUI('sync', S); % Sync parameters with BpodParameterGUI plugin\n%...Create, send and run state matrix, \n%...add and save events\n%...update S with new parameters based on performance\nend\n</code></pre> <p>Initialize parameters with a more complex settings GUI.  'text' and 'edit' Styles are undocumented.</p> <pre><code>S = struct;\nS.nonUIsetting = 23; % A setting not in S.GUI, so not included on the UI\n% Numeric parameters with default style\nS.GUI.InitialDelay = 0.2;\nS.GUI.TimeoutDelay = 5;\n% Checkbox/togglebox between value of 1 and 0\nS.GUI.UseAntiBias = 1;\nS.GUIMeta.UseAntiBias.Style = 'checkbox';\n% Create a button that callbacks a function when pressed\nS.GUI.ManualStimulate = 'ManualStimulation(1)'; % Callback function for pushbutton\nS.GUIMeta.ManualStimulate.Style = 'pushbutton';\n% Create dropdown/popupmenu with specific options\nS.GUI.DifficultyLevel = 1; % Index of the options in .String to start with\nS.GUIMeta.DifficultyLevel.Style = 'popupmenu';\nS.GUIMeta.DifficultyLevel.String = {'Easy', 'Difficult', 'Impossible'}; % Define options in box\n% Group parameters into panels\nS.GUIPanels.Timing = {'InitialDelay', 'TimeoutDelay'};\nS.GUIPanels.Shaping = {'UseAntiBias', 'ManualStimulate', 'DifficultyLevel'};\nBpodParameterGUI('init', S);\n</code></pre> <p></p> <p>In this example the <code>S.GUI.ManualStimulate = 'ManualStimulate(1)</code> together with <code>S.GUIMeta.ManualStimuate.Style = 'pushbutton'</code> yields a button that will activate (callback) a function when pressed. </p>"},{"location":"function-reference/general-plugins/#psychtoolboxsoundserver","title":"<code>PsychToolboxSoundServer()</code>","text":"<p>Note</p> <p>PsychToolboxSoundServer will continue to be supported for legacy installations., but is not considered deprecated. For nearly all applications, the Bpod HiFi Module is a superior method for delivering auditory stimuli. We strongly recommend the HiFi module for new setups, and new projects on existing setups. </p> <p>Description</p> <p>Plays sounds from the governing computer using an Asus Xonar DX, DSX or U7 sound cards. Also compatible with HTOmega Fenix (this card is necessary for PsychToolbox versions 3.0.14 and later).</p> <ul> <li>Low latency and jitter (7-8ms) are achievable when running Bpod on Ubuntu 14.04 with the low-latency kernel and PsychToolbox installed. Comparable performance is possible on a Windows 7-10 computer (Core i7, &gt;=8GB Ram) with only MATLAB running, no processing-intensive background processes, and the latest ASUS ASIO driver installed.</li> <li>Sounds are sampled at 192kHz, 7 channel, with left and right speakers on channels 1 and 2 (\"front/left\" and \"front/right\").</li> <li>By default, channels 3-5 output a 1ms TTL pulse at the onset of each sound.  Connecting any of these channels to a BNC or wire input channel will provide a precise record of sound onset. On Linux, to ensure that the pulse can be read by Bpod, verify that you have configured ALSAmixer correctly during installation.<ul> <li>Up to 32 sounds can be loaded before each trial, and are known to the sound server as sounds 1-32. The number of sounds is currently limited in software to 32, but theoretically depends on available RAM. Sounds can be quickly re-loaded between trials to change their waveform.</li> </ul> </li> <li>Sounds are triggered by sending a soft code back to the governing computer from a trial's state matrix, and calling PsychToolboxSoundServer from a predetermined soft code handler function.</li> </ul> <p>Syntax</p> <pre><code>% To initialize:\nPsychToolboxSoundServer('init')\n% To load a sound:\nPsychToolboxSoundServer('load', SoundID, Waveform)\n% To play a sound:\nPsychToolboxSoundServer('play', SoundID)\n% To stop playback:\nPsychToolboxSoundServer('stop', SoundID)\n% To stop all playback:\nPsychToolboxSoundServer('stopall')\n% To close the sound server:\nPsychToolboxSoundServer('close')\n</code></pre> <p>Parameters</p> <ul> <li>SoundID: A byte specifying which sound to load, play or clear (1-32).</li> <li>Waveform: A vector containing the waveform of the sound to load. Samples must be between -1 and 1, and the sampling rate is 192kHz.<ul> <li>For mono, use a 1Xn vector. Both speakers will play the sound.</li> <li>For stereo, use  a 2Xn vector. Row 1 is the left channel, and row 2 is right.</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code creates a noise waveform, loads it to the sound server, plays it and then closes the server. <pre><code>SoundDuration = 3; SamplingRate = 192000; % Set parameters\nMyWaveform = rand(1,SoundDuration*SamplingRate); % Create waveform\nPsychToolboxSoundServer('init'); % Initialize sound server\nPsychToolboxSoundServer('load', 1, MyWaveform); % load the sound\nPsychToolboxSoundServer('play', 1); % Play the sound\npause(3);\nPsychToolboxSoundServer('close'); % Close sound server\n</code></pre></p> <p>This code loads a sound, sets a soft-code handler to play it, and sets a soft code to be sent from a state matrix. <pre><code>%%-------In main protocol file-------\nSoundDuration = 3; SamplingRate = 192000; % Set parameters\nMyWaveform = rand(1,SoundDuration*SamplingRate); % Create waveform\nPsychToolboxSoundServer('init'); % Initialize sound server\nPsychToolboxSoundServer('load', 3, MyWaveform); % load the sound\nsma = NewStateMatrix();\nsma = AddState(sma, 'Name', 'State1', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'SoftCode', 3});\nBpodSystem.SoftCodeHandlerFunction = 'SoftCodeHandler_PlaySound';\n%%-------Soft code handler file in protocol folder (SoftCodeHandler_PlaySound.m)-------\nfunction SoftCodeHandler_PlaySound(SoundID)\nif SoundID ~= 255\nPsychToolboxSoundServer('Play', SoundID);\nelse\nPsychToolboxSoundServer('StopAll');\nend\n</code></pre></p>"},{"location":"function-reference/general-plugins/#psychtoolboxvideoplayer","title":"<code>PsychToolboxVideoPlayer()</code>","text":"<p>Description</p> <p>Plays video stimuli on a second video monitor attached to the Bpod computer using PsychToolbox. </p> <p>A \"Sync Patch\" is automatically generated for each video frame. The patch is set to a high pixel intensity on the first frame, and alternates between \"off\" and high intensity for subsequent frames. This allows an optical sensor mounted on the corner of the screen (i.e. Frame2TTL) to indicate the actual onset time of each video frame to an acquisition system, providing high precision reaction time and visual evidence update measurements.</p> <ul> <li>Videos are matrices defined in MATLAB. <ul> <li>Each video frame is a matrix of 8-bit pixel values (0-255). </li> <li>Single frames may be a grayscale intensity matrix of dimensions (Y, X) or a color matrix of dimensions (Y, X, 3)</li> <li>The three color layers are intensity matrices for red, green and blue layers respectively.</li> </ul> </li> <li>Multiple frames are stacked in an additional dimension to create a video.<ul> <li>e.g. a color video is a 4-D matrix: Y x X x 3 x Nframes </li> </ul> </li> <li>Videos are loaded to the player and assigned an index (1 - 100).</li> <li>Videos can be played by index, allowing a byte to specify which video to start.</li> <li>Text strings can be loaded by index in place of videos, to display prompts to human subjects</li> <li>By default, playing a video blocks the MATLAB command line. <ul> <li>In default mode, a loop loads frames into the video buffer. Frames are presented at regular intervals.</li> <li>In timer mode, a MATLAB timer callback loads each frame into the video buffer. This makes the command line available during playback. </li> </ul> </li> </ul> <p>Object</p> <p>After running Bpod, a PsychToolboxVideoPlayer object is initialized with the following syntax:</p> <p><pre><code>V = PsychToolboxVideoPlayer(MonitorID, ViewPortSize, ViewPortOffset, SyncPatchSize, SyncPatchYOffset)\n</code></pre> - MonitorID = The index of the second monitor attached to the PC. This is usually 2. - ViewPortSize = [X, Y] of the video to display (in pixels). The video width must leave enough room for the sync patch. - ViewPortOffset = [X, Y] offset of the viewport from left screen edge, and bottom screen edge respectively. (units = pixels) - SyncPatchSize = [X, Y] dimensions of the sync patch (units = pixels) - SyncPatchYOffset = distance of sync patch from bottom of the window (in pixels)</p> <p>The PsychToolboxVideoPlayer is controlled in 2 ways:  - Setting the PsychToolboxVideoPlayer object's fields - Calling the PsychToolboxVideoPlayer object's functions</p> <p>Object Fields</p> <ul> <li>Window<ul> <li>PsychToolbox Window object (for advanced usage, see documentation)</li> </ul> </li> <li>DetectedFrameRate<ul> <li>Detected frame rate of the target display in Hz</li> </ul> </li> <li>Videos<ul> <li>Cell array containing videos loaded with obj.loadVideo()</li> </ul> </li> <li>TextStrings<ul> <li>Cell array containing text strings loaded with obj.loadText()</li> </ul> </li> <li>TimerMode<ul> <li>TimerMode can be one of the following:<ul> <li>0 (video buffer fed by loop, blocking the MATLAB command line)</li> <li>1 (video buffer fed by MATLAB timer object, non-blocking playback)</li> </ul> </li> </ul> </li> <li>ShowViewportBorder<ul> <li>ShowViewportBorder can be one of:<ul> <li>0 (no border)</li> <li>1 - a thin gray border is drawn around the viewport (video portion of the window).           - This is useful for initial layout, and should be disabled during stimulus presentation</li> </ul> </li> </ul> </li> <li>ViewPortDimensions<ul> <li>X,Y Dimensions of videos that can be loaded (specified on startup)</li> </ul> </li> <li>SyncPatchIntensity<ul> <li>Intensity of the sync patch pixels. Range = [0, 255]. Default = 128.</li> </ul> </li> <li>SyncPatchActiveArea<ul> <li>Fraction of the sync patch dimensions set to white when drawing a white patch. Range = [0, 1].</li> <li>Permanently dark pixels surrounding the optical sensor can help to hide the sync patch from the test subject and improve tolerance for sensor misalignment</li> </ul> </li> </ul> <p>Object Functions</p> <ul> <li>loadVideo(videoIndex, video)<ul> <li>Loads a video to the PsychToolboxVideoPlayer, formatted for playback with correct offset and sync patch</li> <li>videoIndex= index of the video (1-100)</li> <li>video = a Y x X x N MATLAB array of pixel intensities (0-255)<ul> <li>Y is the height of the video. It must match height of viewport. The height is given in ViewPortDimensions(2)</li> <li>X is the width of the video. It must match width of viewport. The width is given in ViewPortDimensions(1)</li> <li>N is the number of frames in the video</li> </ul> </li> <li>Color videos may be loaded as Y x X x 3 x N, where the third dimension are red, green and blue color layers respectively</li> </ul> </li> <li>loadText(textIndex, textString, [textStringLine2], [fontSize], [leftOffset])<ul> <li>Loads 1 or 2 lines of text to display on a single video frame (for online human subject instructions)</li> <li>textIndex = index of the text string (1-100). A video on the player cannot have the same index.</li> <li>textString = a character array of text to display</li> <li>textStringLine2 (optional) - a character array to display on line 2</li> <li>fontSize = font size of text to display</li> </ul> </li> <li>play(stimulusIndex)<ul> <li>Plays video or text frame at the specified index, loaded previously with loadVideo() or loadText().</li> <li>If obj.TimerMode is set to 0, this function will block the MATLAB command line until video playback is complete.</li> </ul> </li> <li>stop()<ul> <li>Stops ongoing video playback if obj.TimerMode is set to 1 (non-blocking playback)</li> </ul> </li> </ul> <p>Cleanup</p> <ul> <li>Clear the PsychToolboxVideoPlayer object with clear: <pre><code>V = PsychToolboxVideoPlayer(args);\n% ... Use the video player\nclear V\n</code></pre></li> <li>Clearing the object closes the PsychToolbox window.</li> <li>If a PsychToolboxVideoPlayer object is created as a local variable inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul> <p>Example</p> <p>This code creates a noise video, loads it to the video player, plays it and then closes the player.  <pre><code>MyVideo = (rand(480,640, 30)*255); % Create noise video\n% Initialize video player for a 640 x 480 video, with a 30 x 10 sync patch\nV = PsychToolboxVideoPlayer(2, [640 480], [0 0], [30 10], 0); % Load noise video into player at index 1\nV.loadVideo(1, myVideo); % play the video\nV.play(1); % close the video player\nclear V </code></pre></p> <p>An example behavior protocol using PsychToolboxVideoServer is given in the Bpod_Gen2 repository, here.</p>"},{"location":"function-reference/general-plugins/#bpodnotebook","title":"<code>BpodNotebook</code>","text":"<p>Description</p> <p>Displays a notebook, for taking notes on individual trials, or marking them digitally for classification based on manual criteria.</p> <ul> <li>The written notes are saved in the BpodSystem.Data struct as a cell array of strings, with one cell per trial.</li> <li>The digital marks are saved in the data struct as a vector named \"TrialMarkerCodes\".</li> </ul> <p></p> <ul> <li>The \"Editing Trial#\" window shows the trial whose notes and markers are currently being edited.</li> <li>The single arrow buttons &lt;, &gt; select the next or previous trial to edit respectively.</li> <li>The double arrow buttons &lt;&lt;, &gt;&gt; select the first or current trial to edit respectively.</li> <li>Each time the function is called, the notes in the data are overwritten with the GUI data (i.e. previous trials can be selected and edited)</li> </ul> <p>Syntax</p> <p>On first call (before main loop): <pre><code>BpodNotebook('init')\n</code></pre></p> <p>On subsequent calls (once per trial): <pre><code>NewData = BpodNotebook('sync', Data)\n</code></pre></p> <p>Parameters</p> <ul> <li>Data: A struct of session data (typically BpodSystem.Data)</li> </ul> <p>Returns</p> <ul> <li>NewData: A struct with the current notebook data added.</li> </ul> <p>Example</p> <p>This code launches the notebook GUI, and adds its entire set of notes to the data on each trial. <pre><code>BpodNotebook('init');\nfor currentTrial = 1:1000\n% ...Create, send and run state matrix, add and save events.\nBpodSystem.Data = BpodNotebook('sync', BpodSystem.Data);\nend\n</code></pre></p>"},{"location":"function-reference/general-plugins/#sideoutcomeplot","title":"<code>SideOutcomePlot()</code>","text":"<p>Description</p> <p>Plots correct sides and trial outcomes for a two-sided decision task. </p> <ul> <li>Future trials are indicated with filled blue circles.</li> <li>The current trial is indicated with a black cross.</li> <li>Correct trials are indicated in green. Filled circles indicate rewarded trials, unfilled circles indicate unrewarded trials.. </li> <li>Error trials are indicated in red. Filled circles indicate punished trials, unfilled circles indicate unpunished trials.</li> <li>Trials with no decision response are indicated as unfilled blue circles.</li> </ul> <p>The plot is shown here for an example session:</p> <p></p> <p>Syntax</p> <p>On first call (before first trial): <pre><code>SideOutcomePlot(AxisHandle,'init',TrialSides);\n</code></pre></p> <p>On subsequent calls (once per trial): <pre><code>SideOutcomePlot(AxisHandle,'update',CurrentTrial,TrialSides,Outcomes)\n</code></pre></p> <p>Parameters</p> <ul> <li>AxisHandle: The handle of the axes where you intend display the plot</li> <li>TrialSides: A vector listing the correct response side for all trials in the session. For each trial in the vector, right = 0, left = 1.</li> <li>CurrentTrial: The current trial number (will be marked with a cross)</li> <li>Outcomes: A vector for each completed trial, listing outcomes: <ul> <li>-1 = error, unpunished (unfilled red circle)</li> <li>0 = error, punished (filled red circle)</li> <li>1 = correct, rewarded (filled green circle)</li> <li>2 = correct, unrewarded (unfilled green circle)</li> <li>3 = no response (unfilled black circle)</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code initializes the outcome plot in its own window, and updates it on each trial. All correct trials are rewarded, and all error trials are punished. </p> <pre><code>TrialTypes = ceil(rand(1,5000)*2); % Trial types randomly interleaved, type 1 or 2.\n% type 1 = rewarded left. type 2 = rewarded right.\n%% Initialize plots\n% Create a figure for the outcome plot\nBpodSystem.ProtocolFigures.OutcomePlotFig = figure('Position', [200 200 1000 200],'name','Outcome plot',... 'numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); \n% Create axes for the outcome plot\nBpodSystem.GUIHandles.OutcomePlot = axes('Position', [.075 .3 .89 .6]); SideOutcomePlot(BpodSystem.GUIHandles.OutcomePlot,'init',2-TrialTypes);\n% Run 1000 trials:\nfor currentTrial = 1:1000\n% ...Create, send and run state machine with a state called \"Reward\" \n% and a state called \"Punish\", add and save events...\nOutcomes = zeros(1,BpodSystem.Data.nTrials);\nfor x = 1:BpodSystem.Data.nTrials\nif ~isnan(BpodSystem.Data.RawEvents.Trial{x}.States.Reward(1))\nOutcomes(x) = 1;\nelseif ~isnan(BpodSystem.Data.RawEvents.Trial{x}.States.Punish(1))\nOutcomes(x) = 0;\nelse\nOutcomes(x) = 3;\nend\nend\nSideOutcomePlot(BpodSystem.GUIHandles.OutcomePlot,'update',BpodSystem.Data.nTrials+1,2-TrialTypes,Outcomes)\nend\n</code></pre>"},{"location":"function-reference/general-plugins/#trialtypeoutcomeplot","title":"<code>TrialTypeOutcomePlot()</code>","text":"<p>Description</p> <p>Plots trial types and trial outcomes for a customizable window of trials surrounding the current trial.</p> <ul> <li>Future trials are indicated with filled blue circles.</li> <li>The current trial is indicated with a black cross.</li> <li>Correct trials are indicated in green. Filled circles indicate rewarded trials, unfilled circles indicate unrewarded trials.. </li> <li>Error trials are indicated in red. Filled circles indicate punished trials, unfilled circles indicate unpunished trials.</li> <li>Trials with no decision response are indicated as unfilled blue circles.</li> </ul> <p>The plot is shown here for an example session. The current trial shown is trial #24, trial type 2:</p> <p></p> <p>Syntax</p> <p>On first call (before first trial): <pre><code>TrialTypeOutcomePlot(AxisHandle,'init',TrialTypes);\n</code></pre> On subsequent calls (once per trial): <pre><code>TrialTypeOutcomePlot(AxisHandle,'update',CurrentTrial,TrialTypes,Outcomes)\n</code></pre></p> <p>Parameters - AxisHandle: The handle of the axes where you intend display the plot</p> <ul> <li>TrialTypes: A vector listing the trial types for all trials in the session. Each trial type must be a positive integer.</li> <li>CurrentTrial: The current trial number (will be marked with a cross)</li> <li>Outcomes: A vector for each completed trial, listing outcomes: <ul> <li>-1 = error, unpunished (unfilled red circle)</li> <li>0 = error, punished (filled red circle)</li> <li>1 = correct, rewarded (filled green circle)</li> <li>2 = correct, unrewarded (unfilled green circle)</li> <li>3 = no response (unfilled black circle)</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>This code initializes the trial type outcome plot in its own window, and updates it on each trial. All correct trials are rewarded, and all error trials are punished with time-out. </p> <pre><code>TrialTypes = ceil(rand(1,5000)*2); % Trial types randomly interleaved, type 1 or 2\n% Initialize plots\nBpodSystem.ProtocolFigures.OutcomePlotFig = figure('Position', [200 200 1000 200],'name','Trial type outcome plot',... 'numbertitle','off', 'MenuBar', 'none', 'Resize', 'off'); % Create a figure for the outcome plot\nBpodSystem.GUIHandles.OutcomePlot = axes('Position', [.075 .3 .89 .6]); % Create axes for the trial type outcome plot\nTrialTypeOutcomePlot(BpodSystem.GUIHandles.OutcomePlot,'init',TrialTypes);\n% Run 1000 trials:\nfor currentTrial = 1:1000\n%...Create, send and run state matrix with a state called \"Reward\" \n%   and a state called \"Punish\", add and save events...\nOutcomes = zeros(1,BpodSystem.Data.nTrials);\nfor x = 1:BpodSystem.Data.nTrials\nif ~isnan(BpodSystem.Data.RawEvents.Trial{x}.States.Reward(1))\nOutcomes(x) = 1;\nelseif ~isnan(BpodSystem.Data.RawEvents.Trial{x}.States.Punish(1))\nOutcomes(x) = 0;\nelse\nOutcomes(x) = 3;\nend\nend\nTrialTypeOutcomePlot(BpodSystem.GUIHandles.OutcomePlot,'update',BpodSystem.Data.nTrials+1,TrialTypes,Outcomes)\nend\n</code></pre>"},{"location":"function-reference/general-plugins/#statetiming","title":"<code>StateTiming()</code>","text":"<p>Description</p> <p>The StateTiming plot shows the time course of states in the previous trial. </p> <p>StateTiming was contributed by Florian Rau in Poulet Lab at MDC Berlin.</p> <p></p> <p>Syntax <pre><code>StateTiming();\n</code></pre></p> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>In the protocol's main loop, this code must follow each trial's call to <code>AddTrialEvents()</code>.</p> <pre><code>for currentTrial = 1:maxTrials\n%...\nRawEvents = RunStateMachine;\nBpodSystem.Data = AddTrialEvents(BpodSystem.Data, RawEvents);\nStateTiming();\n%...\nend\n</code></pre>"},{"location":"function-reference/initialization/","title":"Initialization","text":""},{"location":"function-reference/initialization/#bpod","title":"<code>Bpod()</code>","text":"<p>Description</p> <p>Initializes Bpod and creates a global object representing the Bpod device (<code>BpodSystem</code>) in the base workspace.</p> <ul> <li>The function automatically searches all available serial ports and finds Bpod if one is connected.</li> <li>It then creates a <code>BpodSystem</code> object.</li> </ul>"},{"location":"function-reference/liquid-calibration/","title":"Liquid calibration","text":""},{"location":"function-reference/liquid-calibration/#getvalvetimes","title":"<code>GetValveTimes()</code>","text":"<p>Description</p> <p>Converts liquid amounts (in microliters) to time a solenoid valve should be open to deliver the desired amount (in seconds).</p> <ul> <li>Uses the calibration functions generated with the Liquid Calibrator.</li> </ul> <p>Syntax <pre><code>ValveTimes = GetValveTimes(LiquidAmount, TargetValves)\n</code></pre></p> <p>Parameters</p> <ul> <li>LiquidAmount: amount of liquid to deliver (in microliters).</li> <li>TargetValves: a vector of integers listing the valves to return.</li> </ul> <p>Returns</p> <ul> <li>ValveTimes : A vector containing the valve times for all valves listed in the TargetValves parameter (in seconds)</li> </ul> <p>Example</p> <p>This code gets the time valves 1 and 3 must be open to deliver 20ul of liquid.  <pre><code>ValveTimes = GetValveTimes(20, [1 3]); LeftValveTime = ValveTimes(1); RightValveTime = ValveTimes(2);\n</code></pre></p>"},{"location":"function-reference/module-matlab-fsm/","title":"Module &lt;-&gt; MATLAB (via FSM)","text":""},{"location":"function-reference/module-matlab-fsm/#modulewrite","title":"<code>ModuleWrite()</code>","text":"<p>Description</p> <p>Writes values to a Bpod module, via its serial connection to the state machine. (i.e. MATLAB --&gt; State Machine --&gt; Module)</p> <p>Syntax <pre><code>ModuleWrite(ModuleName, Values, [Datatype]) </code></pre></p> <p>Parameters</p> <ul> <li>ModuleName: The module's name (a character array). See BpodSystem.Modules for the names of connected modules.</li> <li>Values: Value(s) to send to the module. By default, values are 'uint8'.</li> <li>(optional) DataType: An integer data type. Supported types are:<ul> <li>uint8</li> <li>uint16</li> <li>uin32</li> <li>int8</li> <li>int16</li> <li>int32</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Examples</p> <pre><code>% Example1: Sends the character array \"Hi there\" via the state machine, to EchoModule1\nModuleWrite('EchoModule1', 'Hi there');\n% Example2: Sends two 32-bit integers to SillyModule2\nModuleWrite('SillyModule2', [102483 297438], 'uint32');\n</code></pre>"},{"location":"function-reference/module-matlab-fsm/#moduleread","title":"<code>ModuleRead()</code>","text":"<p>Description</p> <p>Reads values from a Bpod module, via its serial connection to the state machine. (i.e. Module --&gt; State Machine --&gt; MATLAB)</p> <p>Important</p> <p>The state machine must be manually configured to relay bytes from the module to the USB port, in order for <code>ModuleRead()</code> to work. Set the current relayed module with: <code>BpodSystem.StartModuleRelay(ModuleName)</code>. When you are done exchanging data with the module, you must call <code>BpodSystem.StopModuleRelay()</code> before using the state machine. If you do not call <code>StopModuleRelay()</code>, bytes relayed from the module may interfere with expected USB transmissions. Example code below shows proper usage.</p> <p>Syntax</p> <pre><code>Values = ModuleRead(ModuleName, nValues, [Datatype]) </code></pre> <p>Parameters</p> <ul> <li>ModuleName: The module's name (a character array). See BpodSystem.Modules for the names of connected modules.</li> <li>Values: Value(s) to send to the module. By default, values are 'uint8'.</li> <li>(optional) DataType: An integer data type. Supported types are:<ul> <li>uint8</li> <li>uint16</li> <li>uin32</li> <li>int8</li> <li>int16</li> <li>int32</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>Values: An array of values returned from the module</li> </ul> <p>Examples</p> <p>Sends the character array \"Hi there\" via the state machine, to EchoModule1. Then, read the echo module's reply</p> <pre><code>BpodSystem.StartModuleRelay('EchoModule1'); % Relay bytes from EchoModule1\nModuleWrite('EchoModule1', 'Hi there'); % Write character string \"Hi there\" to EchoModule1\nReply = ModuleRead('EchoModule1, 8); % Read 8 bytes (the length of \"Hi there\") from EchoModule1\nBpodSystem.StopModuleRelay; % Cancel the relay from EchoModule1\n</code></pre> <p>Sends two 32-bit integers to SillyModule2. Reads SillyModule's reply - four 16-bit unsigned integers.</p> <pre><code>BpodSystem.StartModuleRelay('SillyModule2');\nModuleWrite('SillyModule2', [102483 297438], 'uint32');\nReply = ModuleRead('SillyModule2, 4, 'uint16');\nBpodSystem.StopModuleRelay;\n</code></pre>"},{"location":"function-reference/module-matlab-usb/","title":"Module &lt;-&gt; MATLAB (via USB)","text":"<p>See module documentation.</p>"},{"location":"function-reference/pc-fsm-softcodes/","title":"USB Soft Codes, PC --&gt; FSM","text":""},{"location":"function-reference/pc-fsm-softcodes/#sendbpodsoftcode","title":"<code>SendBpodSoftCode()</code>","text":"<p>Description</p> <p>Sends a byte code via USB to the Bpod state machine. The byte code can be handled during a trial like any other behavior event. By default, 15 bytes are reserved for soft codes (1-15). </p> <p>Note</p> <p>To access the MATLAB command line during a trial, you must use the <code>BpodTrialManager</code> class to run the trial's state machine.</p> <p>Syntax</p> <pre><code>SendBpodSoftCode(SoftCodeByte) </code></pre> <p>Parameters</p> <ul> <li>SoftCodeByte: A byte to send to the state machine<ul> <li>Note: The byte must be in the range of supported soft code bytes. By default the range is 1-15.</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Examples</p> <p>Send a 5 to the state machine after a random delay, triggering a state change</p> <pre><code>sma = NewStateMachine;\nsma = AddState(sma, 'Name', 'MyState', ...\n'Timer', 0,...\n'StateChangeConditions', {'SoftCode5', 'MyNextState'},...\n'OutputActions', {});\nsma = AddState(sma, 'Name', 'MyNextState', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', '&gt;exit'},...\n'OutputActions', {});\nT = BpodTrialManager; % Create an instance of the trial manager\nT.startTrial(sma); % Start running the state machine\npause(rand*5); SendBpodSoftCode(5);\nRawEvents = T.getTrialData;\nclear T\n</code></pre>"},{"location":"function-reference/running-protocol/","title":"Running a protocol","text":"<p>To launch a protocol using the Bpod console, click 'Play' for launch manager.</p>"},{"location":"function-reference/running-protocol/#runprotocol","title":"<code>RunProtocol()</code>","text":"<p>Description</p> <p>Runs, or stops a Bpod behavior protocol.</p> <p>Before using RunProtocol(), a protocol folder must exist in /Bpod Local/Protocols/.</p> <p>Also, a test subject must have been added for the protocol:</p> <ul> <li>In the launch manager, use the '+' button, OR </li> <li>Create a folder: /Bpod Local/Data/MyTestSubjectName/MyProtocolName/</li> </ul> <p>You must run Bpod; before using RunProtocol().</p> <p>Syntax</p> <p>To start a protocol: <pre><code>RunProtocol('Start', ProtocolName, SubjectName, [SettingsName])\n</code></pre></p> <p>To stop a running protocol: <pre><code>RunProtocol('Stop')\n</code></pre></p> <p>Parameters</p> <ul> <li>ProtocolName: A string specifying the name of the protocol, as it would appear in the launch manager.<ul> <li>Do not include a path or file extension; for instance, to run the Operant protocol use 'Operant'.</li> <li>New protocols can be created from the launch manager.</li> </ul> </li> <li>SubjectName: A string specifying the test subject name, as it would appear in the launch manager<ul> <li>Do not include a path or file extension; for instance, to run Rat232, use 'Rat232'.</li> <li>New subjects can be created from the launch manager.</li> </ul> </li> <li>SettingsName: An optional string argument to specify a settings file.<ul> <li>If omitted, the protocol's default settings file is used (by default, this is an empty struct). </li> <li>Do not include a path or file extension; for instance, to load Rat232's 'Easy.mat' settings file for Operant, use 'Easy'.</li> <li>New settings files can be created from the launch manager.</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Examples</p> <p>This code starts a new session using the 'OdorTest' protocol, for test subject 'SniffMaster' using the protocol's default settings file.  </p> <pre><code>RunProtocol('Start', 'OdorTest', 'SniffMaster');\n</code></pre> <p>This code starts a new session using the 'OdorTest' protocol, for test subject 'SniffMaster' using settings file /Bpod Local/Data/SniffMaster/OdorTest/ProtocolSettings/'BrutallyDifficult.mat'. <pre><code>RunProtocol('Start', 'OdorTest', 'SniffMaster', 'BrutallyDifficult');\n</code></pre></p>"},{"location":"function-reference/running-statemachine/","title":"Running a state machine","text":"<p>Note</p> <p>The sending and running of a state matrix can be done in one of two ways. The \"classic\" method is to use <code>SendStateMachine()</code> and <code>RunStateMachine()</code>, where the state machine is suspended during inter-trial MATLAB updates. The \"TrialManager\" method is to use <code>BpodTrialManager()</code> which allows updates in parallel. Protocols based on both RunStateMachine() and BpodTrialManager() will be supported for the indefinite future.</p>"},{"location":"function-reference/running-statemachine/#sendstatemachine","title":"<code>SendStateMachine()</code>","text":"<p>Description</p> <p>Sends a state machine description to a Bpod state machine device. </p> <ul> <li>The state machine description is checked first for sanity, and an error is thrown if parameters are invalid, states were referred to but not subsequently defined, etc.</li> <li>The function returns an acknowledgement that the data was properly formatted and cued for transmission. <ul> <li>SuccessfulTransmission is verified internally on the next call to RunStateMachine().</li> </ul> </li> </ul> <p>Syntax</p> <pre><code>Acknowledged = SendStateMachine(StateMachineStruct)\n</code></pre> <p>Parameters</p> <ul> <li>StateMachineStruct: The state machine struct to be sent.<ul> <li>Note: state machine structs are created with NewStateMachine() and states are added with AddState().</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>1 if cued for transmission successfully, 0 if not.</li> </ul> <p>Example</p> <p>This code generates a simple state machine and sends it to Bpod. </p> <pre><code>sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'State1', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {});\nSendStateMachine(sma);\n</code></pre>"},{"location":"function-reference/running-statemachine/#runstatemachine","title":"<code>RunStateMachine()</code>","text":"<p>Description</p> <p>Runs the last state machine that was loaded to Bpod with <code>SendStateMachine()</code>, and returns events, state transitions and timestamps after the state machine reaches the exit state. </p> <ul> <li>This command will block MATLAB execution until data is returned. Scripts to be run during a trial can be added as SoftCodeHandlers and triggered from the state machine.</li> <li>The events returned are in a raw format (not human-readable), and should be subsequently packaged into your session data with the <code>AddTrialEvents()</code> function.</li> </ul> <p>Syntax <pre><code>RawEvents = RunStateMachine()\n</code></pre></p> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <p>A struct with the following fields:</p> <ul> <li>States: a vector listing the integer codes of states visited, in sequential order.<ul> <li>The list of codes can be found in BpodSystem.StateMatrix.StateNames</li> </ul> </li> <li>Events: a vector listing the byte codes of events captured.<ul> <li>The list of events can be found in BpodSystem.StateMachineInfo.EventNames</li> </ul> </li> <li>StateTimestamps: a vector listing the entry times of each state listed in the \"States\" field (in seconds from matrix start).</li> <li>EventTimestamps: a vector listing the times of each event listed in the \"Events\" field (in seconds from matrix start).</li> <li>TrialStartTimestamp: The time the matrix started (in seconds from session start).</li> </ul> <p>Example</p> <p>This code sends \"sma\" (a state machine description) to Bpod, runs it 10 times, and packages the raw events for analysis. </p> <pre><code>SendStateMachine(sma);\nSessionData = struct;\nfor i = 1:10\nRawEvents = RunStateMachine;\nSessionData = AddTrialEvents(SessionData, RawEvents);\nend\n</code></pre>"},{"location":"function-reference/running-statemachine/#bpodtrialmanager","title":"<code>BpodTrialManager()</code>","text":"<p>Note</p> <p>Former syntax: <code>TrialManagerObject()</code></p> <p>Description</p> <p>In earlier releases of Bpod, the function RunStateMachine() was necessary to run each trial. RunStateMachine() blocks the MATLAB command line for the entire trial, so MATLAB cannot use in-trial time to prepare the next trial's state machine, update online plots or save data. MATLAB must do these things between trials, resulting in a \"dead-time\" period where the state machine is not recording events or controlling the environment. When MATLAB-side code is efficient, this dead-time is often acceptable - the example protocols included with Bpod have ~15ms of dead time on a modern processor, which occurs during the subject's motion to initiate the next trial. However if your protocol requires complex online analysis or other time-costly computer-side processing, the BpodTrialManager class provides a way for most of this processing to occur in parallel with the trial. </p> <p>A few points to consider before using TrialManager:</p> <ul> <li>Because the state machine uses a single-core Arduino processor, a small dead-time is still necessary for inter-trial data transmission. This dead time is on the order of 200 microseconds, and depends on how many states and state transitions are defined in the next trial. </li> <li>With TrialManager, the code for an experimental protocol becomes slightly more complicated (e.g. this versus this).</li> <li>Because TrialManager requires Bpod's governing computer to multitask instead of simply checking for incoming bytes in a loop, the computer may process soft codes with increased latency and jitter. </li> </ul> <p>Syntax</p> <pre><code>TrialManager = BpodTrialManager()\n</code></pre> <p>Object Fields</p> <ul> <li>Timer<ul> <li>A MATLAB timer object, used to scan for incoming bytes from the state machine.</li> <li>By default, the timer runs at 1kHz.</li> </ul> </li> </ul> <p>Object Functions</p> <ul> <li>startTrial(StateMatrix)<ul> <li>Sends the next trial's state matrix to the Bpod state machine device, and immediately begins running the trial. </li> <li>StateMatrix = a valid state machine definition, created with <code>AddState()</code>.</li> <li>This function is non-blocking; after state matrix transmission is complete, MATLAB executes the next line of code in your protocol, while the trial proceeds in parallel.</li> <li>In the background, a call to startTrial starts TrialManager's MATLAB timer, which checks constantly for new incoming bytes from the state machine.</li> </ul> </li> <li>currentTrialEvents = getCurrentEvents(TriggerStates)<ul> <li>This is an optional function that stalls MATLAB until a specified trigger state is reached, and then returns all states visited and events captured up to that point in the trial. This can be useful for computing the next trial's state machine while the current trial is still running in an adaptive task (e.g. a task with an anti-bias algorithm).</li> <li>TriggerStates = a cell array of strings specifying the names of trigger states, any of which will trigger the current states and events to be returned.</li> <li>currentTrialEvents is a struct with 3 fields:<ul> <li>StatesVisited = cell array of strings listing names of states visited, in order of their occurrence</li> <li>EventsCaptured = cell array of strings listing names of events captured, in order of their occurrence</li> <li>RawData = a struct with numerical codes for the states visited and events captured</li> </ul> </li> </ul> </li> <li>RawEvents = getTrialData()<ul> <li>This function stalls until the trial is complete, then retrieves the trial data.</li> <li>It should  be called after the next trial's state machine is computed and sent, plots are updated, and data is saved.</li> <li>RawEvents is a struct with raw trial data, formatted exactly like the output of <code>RunStateMachine()</code></li> </ul> </li> </ul> <p>Cleanup</p> <ul> <li>The TrialManager object and its associated timer object are cleared when you end the protocol.</li> </ul> <p>Examples</p> <ol> <li>An example visual 2AFC protocol using TrialManagerObject is included in /Examples/Protocols/Light/Light2AFC_TrialManager.</li> </ol> <p>For comparison, /Light2AFC is an earlier protocol with ~identical functionality, programmed with <code>RunStateMachine()</code>.</p> <ol> <li>Template for simple protocol setup (the task does not use adaptive contingencies, so <code>TrialManager.getCurrentEvents()</code> is not used)</li> </ol> <pre><code>function myProtocol % Main protocol file, runs once when session is launched\nglobal BpodSystem % Import the BpodSystem object (used here to detect when the user ends the protocol)\nnTrials = 1000; % Number of trials in session\nTrialManager = BpodTrialManager; % Create trial manager object\nsma = prepareStateMachine; % Prepare first trial's state machine (see function below)\nTrialManager.startTrial(sma); % Start first trial\nfor i = 1:nTrials\nsma = prepareStateMachine; % Prepare next trial's state machine\nRawEvents = TrialManager.getTrialData; % Hangs here until trial end, then returns the trial's raw data\n% // Code to update Bpod modules with the next trial's parameters (if necessary) goes here.\nif BpodSystem.Status.BeingUsed == 0; break; end % If user hit console \"stop\" button, end session \nTrialManager.startTrial(sma); % Start next trial's state machine\n% // Code to compute online behavior metrics goes here.\n% // Code to update online plots goes here.\n% // Code to format and save data goes here.\nend\nend\nfunction sma = prepareStateMachine\nsma = NewStateMatrix();\nsma = AddState(sma, 'Name', 'MyRandomDelay', ...\n'Timer', ceil(rand*1000)/1000,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {});\nend\n</code></pre>"},{"location":"function-reference/running-statemachine/#addtrialevents","title":"<code>AddTrialEvents()</code>","text":"<p>Description</p> <p>Packages raw events returned from RunStateMatrix() into a session data struct. </p> <p>State codes and event codes are decoded so the session data is human-readable</p> <p>Syntax <pre><code>UpdatedSessionData = AddTrialEvents(PreviousSessionData, RawEvents)\n</code></pre></p> <p>Parameters</p> <ul> <li>PreviousSessionData: The session data struct (or an empty struct for the first trial).</li> <li>RawEvents: The struct of raw events returned from RunStateMatrix().</li> </ul> <p>Return</p> <ul> <li>UpdatedSessionData: A struct containing data from all trials. It has the following fields:<ul> <li>nTrials: The number of trials that have been added</li> <li>RawEvents: A struct containing re-organized state and event timestamps for each trial, labeled so they are human-readable.<ul> <li>RawEvents.Trial{n} has two sub-fields, populated depending on what occurred during the trial:           - States: the times when each state was entered and exited (in seconds). States that were not visited show NaN.           - Events: the times when each event was detected (in seconds).</li> </ul> </li> <li>RawData: A struct containing three fields:<ul> <li>OriginalStateNamesByNumber: A cell array of strings listing the names of each state (for matching states up with state numbers sent via the sync port)           - Note that state numbers are assigned automatically depending on the order of states added with AddState - so if you programmed your protocol to add states (or refer to not-yet-added states) in a different order on each trial, state numbers on each trial may be different.</li> <li>OriginalStateData: A cell array containing the original state codes returned from RunStateMatrix on each trial</li> <li>OriginalEventData: A cell array containing the original event codes returned from RunStateMatrix on each trial</li> </ul> </li> <li>TrialStartTimestamp: The time when each trial started (measured from the last time Bpod was initialized)</li> <li>Settings: A cell array of strings containing the settings struct as it existed when each trial's state matrix was sent.</li> </ul> </li> </ul> <p>Example</p> <p>This code sends \"sma\" (an existing state matrix) to Bpod, runs it 10 times, and packages the raw events for analysis.  <pre><code>SendStateMatrix(sma);\nSessionData = struct;  % equivalent to BpodSystem.Data \nfor i = 1:10\nRawEvents = RunStateMatrix;\nSessionData = AddTrialEvents(SessionData, RawEvents);\nend\n</code></pre></p>"},{"location":"function-reference/serial-message-setup/","title":"Serial message setup","text":"<p>Like other output actions, the serial messages are released when the state begins.</p>"},{"location":"function-reference/serial-message-setup/#loadserialmessages","title":"<code>LoadSerialMessages()</code>","text":"<p>Description</p> <p>When building a state machine, The output action {\"Serial1\", N} can trigger byte N to be sent to a connected module named 'Serial1'.</p> <p>N can also specify a string of 1-3 bytes. </p> <p>This function loads byte strings for different output bytes on the UART serial channels.</p> <p>Syntax</p> <pre><code>Acknowledged = LoadSerialMessages(SerialPort, Messages, [MessageIndexes])\n</code></pre> <p>Parameters - SerialPort: The UART serial port number (1-2 on Bpod 0.5, 1-3 on Bpod 0.7, 1-5 on Bpod Pocket State Machine)     - If a recognized Bpod module is on the port, you can also use its name as a string (e.g. 'ValveModule1') - Messages: A cell array of messages - (optional) MessageIndexes: A list of indexes for the byte strings in the Messages argument.     - By default, the indexes of Messages are consecutive.</p> <p>Returns</p> <ul> <li>Acknowledged: 1 if messages successfully transmitted, 0 if not</li> </ul> <p>Examples</p> <p>Example1: Loads [5 8] as message#1, and [2 3 4] as message#2 on UART serial port 1 <pre><code>LoadSerialMessages(1, {[5 8], [2 3 4]});\n</code></pre></p> <p>Example2: Loads ['X' 3] as message#8 on UART serial port 3  <pre><code>LoadSerialMessages(3, ['X' 3], 8); </code></pre></p>"},{"location":"function-reference/serial-message-setup/#resetserialmessages","title":"<code>ResetSerialMessages()</code>","text":"<p>Description</p> <p>When building a state machine, The output action <code>{\"Serial1\", N}</code> can trigger byte N to be sent.</p> <p><code>LoadSerialMessages()</code> loads byte strings to transmit instead of each Byte N.</p> <p><code>ResetSerialMessages()</code> returns each message to its default (Byte N).</p> <p>Syntax</p> <pre><code>Acknowledged = ResetSerialMessages()\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>Acknowledged: 1 if messages successfully reset to defaults, 0 if not</li> </ul> <p>Example</p> <pre><code>% Loads ['X' 3] as message#7 on UART serial port 3 \nLoadSerialMessages(3, ['X' 3], 7); % Resets message#7 to '7', and message#N to 'N' (default) as on all serial ports\nResetSerialMessages; </code></pre>"},{"location":"function-reference/serial-message-setup/#implicit-serial-messages","title":"Implicit serial messages","text":"<p>Description</p> <p>Messages to be sent from the state machine to its modules are stored in a library onboard the state machine. The library can be explicitly programmed with <code>LoadSerialMessages()</code>.</p> <p>As of Bpod Console v1.70 and Bpod Firmware v23, serial messages can be added implicitly in the state description.</p> <p>Example</p> <p>Create a state named 'Error'. After a 3 second delay, the system exits the state. On entering the state, the byte sequence <code>['P' 2]</code> is sent to the HiFi module (to play an error sound loaded at sound position 2).</p> <pre><code>sma = AddState(sma, 'Name', 'Error', ...\n'Timer', 3,...\n'StateChangeConditions', {'Tup', '&gt;exit'},...\n'OutputActions', {'HiFi1', ['P' 2]});\n</code></pre>"},{"location":"function-reference/state-machine-creation/","title":"Creating a state machine","text":"<p>Note</p> <p>More examples of state machine creation can be found in the Examples/ folder of the repository. Examples/State Machines/ contains minimal (building block) examples, while Examples/Protocols/ contains complete examples of a protocol state matrix construction.</p>"},{"location":"function-reference/state-machine-creation/#newstatemachine","title":"<code>NewStateMachine()</code>","text":"<p>Description</p> <p>Creates a new, empty state machine. </p> <p>States can be added to the empty state machine description with the <code>AddState()</code> function. The state machine description returned is a struct with 21 subfields:</p> <ul> <li>Meta: a struct with information about the state machine (sizes of variables, precomputed for speed)</li> <li>nStates: the number of states that have been added to the state machine</li> <li>Manifest: a cell array listing the names of states that have been referenced by other states (though not explicitly added yet)</li> <li>nStatesInManifest: the number of states in the manifest</li> <li>StateNames: a cell array of strings containing the name of each state added to the state machine with <code>AddState()</code>; initialized as a 1x1 cell with the string \"Placeholder\"</li> <li>InputMatrix: each row is a state, each column is an input event. The matrix specifies the new state to go to if each event occurrs in each state.</li> <li>OutputMatrix: each row is a state, each column is an output action. The matrix specifies the value of each output action in each state.</li> <li>StateTimerMatrix: for each state, specifies the new state to go to if the state's internal timer elapses.</li> <li>GlobalTimerStartMatrix: each row is a state, each column is a global timer. The matrix specifies the new state to go to when the global timer starts.</li> <li>GlobalTimerEndMatrix: each row is a state, each column is a global timer. The matrix specifies the new state to go to when the global timer elapses.</li> <li>GlobalTimers: each column is a timer. This vector specifies the current setting of each timer in seconds.</li> <li>GlobalCounterMatrix: each row is a state, each column is a global counter. The matrix specifies the new state to go to if the counter's threshold is exceeded.</li> <li>GlobalCounterEvents: each column is a counter. This vector specifies the input event being counted. It defaults to 255 (no input event).</li> <li>GlobalCounterThresholds: each column is a counter. This vector specifies the number of events recorded before each counter is exceeded.</li> <li>GlobalCounterSet: each column is a counter. This vector specifies whether each counter was used in the current matrix (1) or not (0).</li> <li>ConditionMatrix: each row is a state, each column is a configurable input channel condition. The matrix specifies the new state to go to if the condition is satisfied.</li> <li>ConditionChannels: The input channel index linked to each condition.</li> <li>ConditionValues: The value of the input channel (specified in ConditionChannels) for each condition to be satisfied.</li> <li>StateTimers: each column is a state. This vector specifies the setting of each state's internal timer in seconds.</li> <li>StatesDefined: each column is a state. States appear in the matrix as blank states when first referred to as the target of a state transition. StatesDefined is then set from 0 to 1 when the state is finally added.</li> </ul> <p>Syntax</p> <pre><code>StateMachine = NewStateMachine();\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>An empty state machine struct</li> </ul> <p>Example</p> <p>This code initializes a state matrix and then adds one state:</p> <pre><code>sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'MyState', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {});\n</code></pre>"},{"location":"function-reference/state-machine-creation/#addstate","title":"<code>AddState()</code>","text":"<p>Description</p> <p>Adds a state to an existing state machine. </p> <p>Syntax</p> <p><pre><code>NewStateMachine = AddState(StateMachineStruct, 'Name', StateName,...\n'Timer', TimerDuration,...\n'StateChangeConditions', Conditions,...\n'OutputActions', Actions)\n</code></pre> Parameters</p> <ul> <li>StateMachineStruct: The state machine you are adding to. If this is the first state, StateMachineStruct is the output of <code>NewStateMachine()</code>.</li> <li>StateName: A character string containing the unique name of the state.<ul> <li>The state will automatically be assigned a number for internal use and state synchronization via the sync port.</li> </ul> </li> <li>Timer: The state timer value, given in seconds<ul> <li>This value must be zero or positive, and can range between 0-3600s.</li> <li>If set to 0s and linked to a state transition (see next bullet), the state will still take ~100us to execute the state's output actions before the transition completes.</li> </ul> </li> <li>StateChangeConditions: A cell array of strings listing pairs of input events and the state changes they trigger.<ul> <li>Each odd cell should contain the name of a valid input event.</li> <li>Each even cell should contain the name of the new state to enter if the previously listed event occurs, or 'exit' to exit the matrix and return all captured data..</li> </ul> </li> <li>OutputActions: A cell array listing the output actions and corresponding values for the current state.<ul> <li>Each odd cell should contain the name of a valid output action.</li> <li>Each even cell should contain the value of the previously listed output action (see output actions for valid values).</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A state machine struct, updated with the new state.</li> </ul> <p>Examples</p> <p>This code generates a simple state matrix that drives BNC output channel 1 to 5V (high) for 1 second before exiting.  <pre><code>sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'MyState', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},... 'OutputActions', {'BNCState', 1}); % Tup occurs when the state's internal timer elapses\n</code></pre></p> <p>This code generates a simple state matrix that flashes the port LEDs of ports 1-3 for 0.1 second each (assuming an LED is connected to the port's PWM line).  <pre><code>sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'LightPort1', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'LightPort2'},...\n'OutputActions', {'PWM1', 255}); sma = AddState(sma, 'Name', 'LightPort2', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'LightPort3'},...\n'OutputActions', {'PWM2', 255}); sma = AddState(sma, 'Name', 'LightPort3', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'PWM3', 255}); </code></pre></p>"},{"location":"function-reference/state-machine-creation/#editstate","title":"<code>EditState()</code>","text":"<p>Description</p> <p>Edits a state in an existing state machine. </p> <p>Syntax</p> <pre><code>NewMatrix = EditState(StateMachineStruct, StateName, ParameterName, ParameterValue)\n</code></pre> <p>Parameters</p> <ul> <li>StateMachineStruct: The state machine you are editing.</li> <li>StateName: A character string specifying the name of the state you are editing.</li> <li>ParameterName: A character string specifying the parameter you are editing. Valid values are:<ul> <li>'Timer'</li> <li>'StateChangeConditions'</li> <li>'OutputActions'</li> </ul> </li> <li>ParameterValue: The new value of the parameter.<ul> <li>For timer, this is the new timer duration in seconds. </li> <li>For StateChangeConditions, this is a cell array of strings formatted with pair-wise arguments as in <code>AddState()</code>.</li> <li>For OutputActions, this is a cell array of strings formatted with pair-wise arguments as in <code>AddState()</code>.</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A state machine struct, updated with the new parameter.</li> </ul> <p>Example</p> <p>This code generates a simple state machine that drives BNC output channel 1 to 5V (high) for 1 second before exiting. Next, EditState is used to make the state high for 10 seconds instead of 1. Finally, EditState is used to make the state machine end immediately if BNC input channel 1 receives a trigger pulse during the 10 second state.</p> <pre><code>sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'MyState', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'BNCState', 1}); sma = EditState(sma, 'MyState', 'Timer', 10);\nsma = EditState(sma, 'MyState', 'StateChangeConditions',...\n{'Tup', 'exit', 'BNC1High', 'exit');\n</code></pre>"},{"location":"function-reference/state-machine-creation/#setglobaltimer","title":"<code>SetGlobalTimer()</code>","text":"<p>Description</p> <p>Sets the parameters of a global timer.</p> <ul> <li>Unlike state timers, global timers can be triggered from any state (as an output action), and handled from any state (by causing a state change). Any subset of global timers can be triggered or canceled from any state.</li> <li>An optional onset latency can be configured, following the timer trigger</li> <li>Following the onset latency, a \"start\" event is generated, and can trigger a state change.</li> <li>Then, following the timer duration, an \"end\" event is generated, which can also trigger a state change.</li> <li>A digital or PWM (LED) output channel can be linked to the timer. <ul> <li>The linked channel is set \"high\" when the timer starts, and \"low\" when it ends. PWM values may be specified for onset/offset. </li> </ul> </li> <li>Separate serial output messages can be linked to the timer start and end events to control modules. </li> <li>Global timers can be set to 'Loop'; repeat until they are explicitly canceled, or until a fixed number of iterations.<ul> <li>Each loop iteration generates a start and stop event (this can be disabled for high-frequency loops)</li> <li>A configurable interval separates loop iterations (default = 0 seconds)</li> </ul> </li> <li>Global timers can be linked to trigger other global timers. Following the timer's onset delay, any linked timers will be triggered.</li> <li>The number of available global timers is a configurable parameter specified in the state machine firmware.</li> </ul> <p>Syntax</p> <p>The function uses argument-value pairs. These must be listed in order (for efficiency), up to the last argument you need. Beyond that, optional arguments (denoted by [ ]) may be omitted):</p> <p><pre><code>NewStateMachine = SetGlobalTimer(StateMachineStruct, 'TimerID', TimerNumber,... 'Duration', TimerDuration, ['OnsetDelay', OnsetDelay],...\n['Channel', OutputChannel], ['OnsetValue', OnsetValue],... ['OffsetValue', OffsetValue], ['Loop', LoopMode],...\n['GlobalTimerEvents', EventsEnabled], ['LoopInterval', LoopInterval],...\n['OnsetTrigger', OnsetTriggerByte])\n</code></pre> where [ ] = optional argument</p> <p>Parameters</p> <ul> <li>StateMachineStruct: The state machine description whose global timer you are setting (typically named 'sma').</li> <li>TimerNumber: The number of the timer you are setting (an integer, 1-5).</li> <li>TimerDuration: The duration of the timer, following timer start (0-3600 seconds)</li> <li>OnsetDelay: A fixed interval following timer trigger, before the timer start event (default = 0 seconds) <ul> <li>If set to 0, the timer starts immediately on trigger and no separate start event is generated.</li> </ul> </li> <li>OutputChannel: A string specifying an output channel to link to the timer (default = none)<ul> <li>Valid output channels can be viewed from the \"inspect\" icon on the Bpod Console.</li> </ul> </li> <li>OnsetValue: The value to write to the output channel on timer start (default = none)<ul> <li>If the linked output channel is a digital output (BNC, Wire), set to 1 = High; 5V or 0 = Low, 0V</li> <li>If the linked output channel is a pulse width modulated line (port LED), set between 0-255.</li> <li>If the linked output channel is a serial module, OnsetValue specifies a byte message to send on timer start.</li> </ul> </li> <li>OffsetValue: The value to write to the output channel on timer end (default = none)</li> <li>LoopMode: 0 = off (default). If set to 1, global timer loops until canceled or until trial end. If &gt;1, indicates a fixed number of loop iterations to execute (up to 255).</li> <li>EventsEnabled: 1 = on (default). If set to 0, timer onset and offset events are not generated. Disabling events is useful for cases where the global timer is rapidly cycling to control a stimulus, and would otherwise generate a huge number of ignored behavior events.</li> <li>LoopInterval: A configurable delay between the end of a timer loop and the beginning of the next one (default = 0 seconds)</li> <li>OnsetTrigger: A byte whose bits indicate other global timers to trigger when the timer starts (following its onset delay).<ul> <li>Instead of an integer, the assembler will recognize a character string of 1s and 0s (i.e. '101001' to trigger timers 1,4 and 6)</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A state machine struct, updated with the new global timer settings.</li> </ul> <p>Examples</p> <p>The two examples below are for simple use cases. More complex global timer examples can be found in the Bpod repository: /Bpod_Gen2/Examples/State Machines/GlobalTimers/</p> <p>This code generates a state machine that sets a global timer for 3 seconds, triggers it in the first state, and handles it in the second and third states.  <pre><code>sma = NewStateMachine();\nsma = SetGlobalTimer(sma, 'TimerID', 1, 'Duration', 3); sma = AddState(sma, 'Name', 'State1', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'State2'},...\n'OutputActions', {'GlobalTimerTrig', 1});\nsma = AddState(sma, 'Name', 'State2', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port1In', 'State3', 'GlobalTimer1_End', 'exit'},...\n'OutputActions', {});\nsma = AddState(sma, 'Name', 'State3', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port1Out', 'State2', 'GlobalTimer1_End', 'exit'},...\n'OutputActions', {});\n</code></pre></p> <p>This code generates a state machine that sets global timer#2 for 2 seconds with a 1.5 second onset delay. The timer is linked to a BNC channel. The timer is triggered in the first state, and handled it in the second and third states.</p> <pre><code>sma = NewStateMachine;\nsma = SetGlobalTimer(sma, 'TimerID', 2, 'Duration', 2,...\n'OnsetDelay', 1.5, 'Channel', 'BNC2'); sma = AddState(sma, 'Name', 'TimerTrig', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'Port1Lit'},...\n'OutputActions', {'GlobalTimerTrig', 1});\nsma = AddState(sma, 'Name', 'Port1Lit', ...\n'Timer', .25,...\n'StateChangeConditions', {'Tup', 'Port3Lit', 'GlobalTimer1_End', 'exit'},...\n'OutputActions', {'PWM1', 255});\nsma = AddState(sma, 'Name', 'Port3Lit', ...\n'Timer', .25,...\n'StateChangeConditions', {'Tup', 'Port1Lit', 'GlobalTimer1_End', 'exit'},...\n'OutputActions', {'PWM3', 255}); </code></pre>"},{"location":"function-reference/state-machine-creation/#setglobalcounter","title":"<code>SetGlobalCounter()</code>","text":"<p>Description</p> <p>Sets the threshold and monitored event for one of the 5 global counters. </p> <ul> <li>Global counters can count instances of events, and handle when the count exceeds a threshold from any state (by triggering a state change).</li> <li>The number of possible counters is a configurable parameter specified in the state machine firmware.</li> <li>For more on global counters, see Using State Matrices.</li> </ul> <p>Syntax</p> <pre><code>NewStateMachine = SetGlobalCounter(StateMachineStruct, CounterNumber, TargetEventName, Threshold)\n</code></pre> <p>Parameters</p> <ul> <li>StateMachineStruct: The state matrix whose global timer you are setting.</li> <li>CounterNumber: The number of the counter you are setting (an integer, 1-5).</li> <li>TargetEventName: The name of the event to count (a string; see Bpod Console's magnifying glass)</li> <li>Threshold: The number of event instances to count. (an integer).</li> </ul> <p>Returns</p> <ul> <li>A state machine struct, updated with the new global counter setting.</li> </ul> <p>Example</p> <p>This code generates a state machine that sets a global counter to count 5 BNC1High events, resets the count to 0 in the second state, and handles it in the third and fourth states. </p> <pre><code>sma = NewStateMachine();\nsma = SetGlobalCounter(sma, 1, 'BNC1High', 5);\nsma = AddState(sma, 'Name', 'State1', ... % BNC1High Events in this state are not counted because the count will be reset.\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'State2'},...\n'OutputActions', {});\nsma = AddState(sma, 'Name', 'State2', ... % This state resets the global counter.\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'State3'},...\n'OutputActions', {'GlobalCounterReset', 1});\nsma = AddState(sma, 'Name', 'State3', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port1In', 'State4', 'GlobalCounter1_End', 'exit'},...\n'OutputActions', {});\nsma = AddState(sma, 'Name', 'State4', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port1Out', 'State3', 'GlobalCounter1_End', 'exit'},...\n'OutputActions', {});\n</code></pre>"},{"location":"function-reference/state-machine-creation/#setcondition","title":"<code>SetCondition()</code>","text":"<p>Description</p> <p>Sets an input channel condition to handle on entering a state</p> <ul> <li>Each condition is true if an input channel's state matches the condition's value.</li> <li>The number of possible conditions is a configurable parameter specified in the state machine firmware.</li> </ul> <p>Syntax <pre><code>NewStateMachine = SetCondition(StateMachineStruct, ConditionNumber, ConditionChannel, ConditionValue)\n</code></pre></p> <p>Parameters</p> <ul> <li>StateMachineStruct: The state machine description whose global timer you are setting.</li> <li>ConditionNumber: The number of the condition you are setting (an integer).</li> <li>ConditionChannel: The name of the input channel attached to the condition.<ul> <li>Input channel names are listed in BpodSystem.StateMachineInfo.InputChannelNames</li> <li>The channel can also be a global timer, indicated as 'GlobalTimerN' where N is the index of the global timer.</li> </ul> </li> <li>ConditionValue: The value of the condition channel if the condition is met (1 = high, 0 = low)<ul> <li>If using a global timer, the timer is \"high\" (1) between its \"start\" and \"end\" events, and 0 otherwise.</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A state machine struct, updated with the new condition description.</li> </ul> <p>Example</p> <p>This code generates a state machine with three states. Each state lights up a behavior port. A condition is set to be valid if the IR channel of port2 is high (1). It is then used to skip state 2 if true.</p> <pre><code>sma = NewStateMachine;\nsma = SetCondition(sma, 2, 'Port2', 1);\nsma = AddState(sma, 'Name', 'Port1Light', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'Port2Light'},...\n'OutputActions', {'PWM1', 255});\nsma = AddState(sma, 'Name', 'Port2Light', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'Port3Light', 'Condition2', 'Port3Light'},...\n'OutputActions', {'PWM2', 255});\nsma = AddState(sma, 'Name', 'Port3Light', ...\n'Timer', 1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'PWM3', 255});\n</code></pre>"},{"location":"function-reference/updating-bpod/","title":"Updating Bpod","text":""},{"location":"function-reference/updating-bpod/#loadbpodfirmware","title":"<code>LoadBpodFirmware()</code>","text":"<p>Description</p> <p>Launches a tool to load firmware to any Bpod state machine or module.</p> <p></p> <p>Usage</p> <ul> <li>Select the target state machine version or module from the 'Firmware' menu.</li> <li>Select the firmware version from the 'Version' menu. The latest firmware in Bpod_Gen2 will be selected by default.</li> <li>Select the target serial port from the 'Port' menu. If you don't know the target serial port, close the tool, unplug all other Bpod and Arduino devices from the PC and re-run LoadBpodFirmware.</li> <li>Press 'Load' to load the firmware to the device. </li> <li>Most devices are programmed in a few seconds</li> <li>State Machine r0.5-r1.0 may take several minutes. This is normal.</li> <li>A confirmation popup will indicate when the firmware has been successfully updated</li> </ul>"},{"location":"function-reference/updating-bpod/#updatebpodsoftware","title":"<code>UpdateBpodSoftware()</code>","text":"<p>Description</p> <p>Launches the Bpod software update tool. This tool will update your local copy of the Bpod_Gen2 repository to the latest stable release.</p> <p>Warning</p> <p>If you are using a version control tool (e.g. Git) to keep your Bpod_Gen2 folder current, you should use the tool's \"Pull\" function and NOT UpdateBpodSoftware().</p> <p>As of August 2018, the software update tool is a BETA release, and works only on Win7 and Win10 with MATLAB r2014b or newer. </p> <p>A backup copy of your existing Bpod_Gen2 folder will be made in your Bpod_Local folder.</p> <p>The updater will overwrite any changes you may have made to your local copy of the Bpod_Gen2 repository, so if you made mods to the Bpod system files, make sure to back up your existing Bpod_Gen2 folder first! Note: behavior protocols, behavioral data, internal settings and calibration files are normally located in a separate folder outside of Bpod_Gen2 - make sure this is true of your system before proceeding.</p> <p>Internet connectivity is required to launch the updater.</p> <p>In event of an update failure, see instructions for manual update. </p> <p>Please report any issues to support@sanworks.io.</p> <p>Syntax</p> <p>Note</p> <p>Must be run while Bpod software is closed:</p> <pre><code>UpdateBpodSoftware() </code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example</p> <p>Launches the software updater <pre><code>% Note: Run this with Bpod software closed\nUpdateBpodSoftware();\n</code></pre></p>"},{"location":"install-and-update/arduinodue-update/","title":"Arduino Due (State Machine v0.5-1.0)","text":"<p>To update state machine firmware for Bpod hardware v0.5-0.9:</p> <ol> <li>Plug the Bpod device into the governing computer's USB port.</li> <li>(Windows only) If the drivers are not yet installed (or if you're not sure), follow Arduino Due's Windows driver installation page.</li> <li>Open the Arduino program folder and run Arduino.exe.</li> <li>Install support for Arduino Due (if you haven't done this already):<ul> <li>From the \"Tools\" menu, choose \"Board\" and then \"Boards Manager\".</li> <li>In the boards manager, install \"Arduino SAM boards (32-bits ARM Cortex M3).</li> <li>Restart Arduino</li> </ul> </li> <li>From the \"Tools\" menu, choose \"Board\" and then \"Arduino Due (Native USB Port)\".</li> <li>From the \"Serial Port\" menu, choose \"COMX\" (win) or \"/dev/ttySX\" (linux) where X is the port number. To find your port number in Win7, choose \"Start\" and type \"device manager\" in the search window. In the device manager, scroll down to \"Ports (COM &amp; LPT)\" and expand the menu. The COM port will be listed as \"Arduino Due Native USB Port (COMX)\" where COMX is a serial port name. On Unix this will not be \"COM\".</li> <li>From the File menu in Arduino, choose \"Open\" and select the firmware.<ul> <li>For Bpod 0.5, use: \"/Bpod/Firmware/Bpod0_X/Bpod_StateMachine_0_X_Y/Bpod_StateMachine_0_X_Y.ino.</li> <li>For older Bpod software, use Bpod_MainModule_0_X_Y.</li> <li>For Bpod 0.7+ use: /Bpod/Firmware/Gen2/BpodStateMachine_0_X_Y</li> <li>A new window should open with the firmware.</li> </ul> </li> <li>In the new window, click the \"upload\" button (the right-pointing arrow roughly under the \"edit\" menu).</li> </ol> <p>If all went well, the green progress indicator should finish, and be replaced with a message: \"Done uploading\". In orange text below, should read \"Verify successful\".</p>"},{"location":"install-and-update/arduinom0-update/","title":"ArduinoM0","text":"<p>To update state machine firmware for a module using Arduino M0: 1. Plug the module into the governing computer's USB port. 2. (Windows only) If the drivers are not yet installed (or if you're not sure), follow Arduino M0's Windows driver installation page. 3. Open the Arduino program folder and run Arduino.exe. 4. Install support for Arduino Due (if you haven't done this already):     - From the \"Tools\" menu, choose \"Board\" and then \"Boards Manager\".     - In the boards manager, install \"Arduino SAMD boards (32-bits ARM Cortex M0).     - Restart Arduino 5. From the \"Tools\" menu, choose \"Board\" and then \"Arduino M0\". 6. From the \"Serial Port\" menu, choose \"COMX\" (win) or \"/dev/ttySX\" (linux) where X is the port number. To find your port number in Win7, choose \"Start\" and type \"device manager\" in the search window. In the device manager, scroll down to \"Ports (COM &amp; LPT)\" and expand the menu. The COM port will be listed as \"Arduino M0 Native Port (COMX)\" where COMX is a serial port name. On Unix this will not be \"COM\". 7. From the File menu in Arduino, choose \"Open\" and select the firmware file.     - A new window should open with the firmware. 8. In the new window, click the \"upload\" button (the right-pointing arrow roughly under the \"edit\" menu).</p> <p>If all went well, the green progress indicator should finish, and be replaced with a message: \"Done uploading\". In orange text below, should read \"AVRDude Done. Thank you\".</p>"},{"location":"install-and-update/firmware-update/","title":"Firmware update","text":""},{"location":"install-and-update/firmware-update/#automatic","title":"Automatic","text":"<p>Note</p> <p>An experimental auto-updater is included with the latest Bpod software. It is not available on all platforms, and as new software it carries the risk of malfunction in your particular MATLAB + PC configuration. If you choose to try it,</p> <ul> <li>To update the firmware of your state machine:<ul> <li>Ensure the Bpod software is installed</li> <li>Start MATLAB</li> <li>Run the following at the MATLAB command line:<ul> <li>BpodFirmwareUpdate(MyPort)</li> <li>MyPort is the state machine's USB serial port (e.g. 'COM3')</li> <li>The updater will automatically detect your state machine's firmware version and give you the option to update</li> </ul> </li> </ul> </li> <li>To update firmware of your module(s):<ul> <li>Connect each module you want to update to the state machine using a CAT5 (Ethernet) cable</li> <li>Also connect each module you want to update to the PC via USB (even if a USB cable is not usually needed)</li> <li>Run Bpod()</li> <li>From the Bpod console, use the 'USB' button to pair each connected module with its USB serial port</li> <li>Next, run the following at the MATLAB command line:<ul> <li>BpodFirmwareUpdate</li> </ul> </li> </ul> </li> <li>The updater will automatically find any connected modules and give you the option to proceed with the update</li> </ul>"},{"location":"install-and-update/firmware-update/#semi-automatic","title":"Semi-Automatic","text":"<p>The semi-automatic option works on Windows only, and is only recommended for Teensy-based modules:</p> <ul> <li>State Machine r2</li> <li>Analog Output Module</li> <li>Analog Input Module</li> <li>HiFi Module</li> <li>Rotary Encoder Module</li> <li>Ethernet Module</li> <li>DDS Module</li> <li>Port Array Module From the MATLAB-command prompt, run: LoadBpodFirmware;</li> </ul> <p>A GUI will launch. Select the correct firmware and the target device's COM port, and click 'upload'.</p>"},{"location":"install-and-update/firmware-update/#manual","title":"Manual","text":"<p>FOR ALL:\u00a0</p> <ul> <li>Download Arduino 1.8.X non-admin / zip, extract the zip folder and save the extracted folder somewhere permanent on your PC.</li> <li>Download the firmware file to update. Firmware is an Arduino sketch, hosted on the Sanworks Github account:<ul> <li>Bpod State Machine (select your machine from the /Preconfigured/ folder)</li> </ul> </li> <li>Analog Output Module</li> <li>Analog Input Module</li> <li>DDS Module</li> <li>Rotary Encoder Module</li> <li>Valve Driver Module</li> <li>I2C Messenger Module</li> <li>SNES Module<ul> <li>Example firmware for Arduino / Teensy Shields</li> </ul> </li> </ul> <p>Next, continue to specific instructions for the device you want to update:</p> <p>Modules powered by Arduino Due (State Machine v0.5-1.0)</p> <p>Modules powered by Teensy 3.X and 4.X (State Machine v2, 2.5 and 2+, Analog Output, Analog Input, DDS, HiFi, Ethernet, Rotary Encoder, Port Array, Valve Driver v2, Examples using Teensy Shield)</p> <p>Modules powered by Sparkfun SAMD21 Mini (ValveDriver v1, I2C, SNES)</p> <p>Modules powered by Arduino M0 (Examples using Arduino Shield)</p>"},{"location":"install-and-update/installing-bpod/","title":"Installing Bpod","text":"<p>This section details installing the Bpod software on the governing computer, and the Bpod firmware on the Bpod device.</p>"},{"location":"install-and-update/installing-bpod/#pc-windows-10","title":"PC (Windows 10)","text":""},{"location":"install-and-update/installing-bpod/#requirements","title":"Requirements","text":"<ol> <li>Windows 10</li> <li>8GB+ RAM</li> <li>Preferably a 2.5GHz+ multi-core CPU (i.e. intel corei5/i7 series).</li> <li>MATLAB r2013a or newer. </li> </ol> <p>Note</p> <p>If you are using Windows 7 and State Machine r2, you need to install the Teensy serial port driver.</p>"},{"location":"install-and-update/installing-bpod/#clone-the-matlab-software-repository","title":"Clone the MATLAB software repository","text":"<p>Bpod's MATLAB software is frequently updated with new features and improvements.  To keep Bpod current for everyone, we use a revision control system called Git.</p> <p>Git's command line usage can be tricky, so instead, we recommend a simple and powerful user interface to Git called SourceTree.</p> <ol> <li>Download and install SourceTree. The default options during install are correct - and you can use the embedded git client when prompted, if you don't already have it.</li> <li>From SourceTree, clone the remote repository. <ol> <li>If you are using Bpod 0.5 (legacy), use: https://github.com/sanworks/Bpod.git</li> <li>If you are using Bpod 0.7+ or want to use Bpod 0.5 with current features, use: https://github.com/sanworks/Bpod_Gen2.git</li> </ol> </li> </ol> <p>If all went well, this should copy the latest Bpod software to your computer.</p>"},{"location":"install-and-update/installing-bpod/#install-the-matlab-software","title":"Install the MATLAB software","text":"<ol> <li>Open MATLAB</li> <li>Set the Path<ol> <li>In r2012a or later, choose \"Set Path\" from the \"Environment\" cluster in the \"Home\" tab. In r2011b or earlier, choose \"File &gt; Set path\".</li> <li>For Bpod_Gen2</li> <li>Choose \"Add\" (NOT with subfolders)</li> <li>Select C:\\Bpod_Gen2\\ (or wherever your /Bpod_Gen2/ root folder is) and click \"Add\"</li> <li>For Legacy Bpod</li> <li>Choose \"Add with subfolders\"</li> <li>Select C:\\Bpod\\Bpod System Files\\ and click \"Add\".</li> <li>Click \"Save\" at the bottom so MATLAB will know where Bpod is for all future sessions.</li> </ol> </li> <li>To verify that you were successful, make sure Bpod is unplugged and type Bpod at the MATLAB command prompt. <ol> <li>If all went well, Bpod will attempt to start and then fail with an error: \"Bpod device not found\". If something went wrong, you will get a different error.</li> <li>If the error says \"Unidentified function or variable 'Bpod', you did not successfully add Bpod to the MATLAB path.</li> </ol> </li> <li>Install PsychToolbox</li> <li>If you build the state machine yourself, upload Bpod's firmware<sup>1</sup></li> </ol> <p>You should be able to run Bpod from that MATLAB prompt with <code>Bpod</code></p> <p>Warning</p> <p>For Bpod r0.5 - 1 users:  On first plugging in the state machine, if MATLAB is open you will see a message:  <pre><code>Arduino Due detected.\nTo use this device with MATLAB, install MATLAB Support Package for Arduino Hardware.\n</code></pre> DO NOT install the Arduino support package and definitely do not overwrite the state machine firmware! Bpod firmware communicates with MATLAB via MATLAB's built-in serialport interface.</p>"},{"location":"install-and-update/installing-bpod/#ubuntu","title":"Ubuntu","text":"<p>These are instructions for setting up Bpod on a computer running Ubuntu</p> <p>We recommend at least an Intel Corei5 processor and 8GB of RAM.</p> <p>This tutorial assumes you have loaded Bpod's firmware if you self-assembled the state machine.</p> <ol> <li>Install Ubuntu (64bit) with &gt;100GB partition<ol> <li>Update Ubuntu to current version if necessary</li> </ol> </li> <li>Install MATLAB. <ol> <li>When prompted, check \u201cinstall script\u201d.</li> </ol> </li> <li>Run MATLAB (if default install location, from terminal: sudo /usr/local/MATLAB/RXXXX/bin/matlab</li> <li>Install PsychToolbox:<ol> <li>Download PsychToolbox by following instructions for linux here. Use the SUBVERSION based installation.</li> <li>Allow all patches and use default settings when prompted.</li> </ol> </li> <li>Copy Bpod files from here and add /Bpod_Gen2/Bpod System Files to MATLAB path</li> <li>Close MATLAB</li> <li>Open a terminal window and add yourself to the \u201cdialout\u201d group:</li> <li><code>sudo usermod -a -G dialout kepecslab</code> (if kepecslab is your username)</li> <li>Restart matlab as root (same as step 3)</li> <li>Run Bpod from the command prompt.</li> </ol> <p>Note: Gnome ModemManager does not play well with Arduino; it discovers Arduino and probes it with bytes that interfere with communications, possibly leaving Bpod in a state where it expects bytes that will never arrive. If you experience issues starting Bpod and you're using Gnome, consider disabling the modem manager.</p> <p>Note: A previous installation step was automated in the current version. If you are not using PsychToolbox, MATLAB needs to be instructed that ports of the form /dev/ttyACMx are valid serial ports. On first run, Bpod should automatically handle this, and then ask you to restart MATLAB. If it fails, do the following:</p> <ol> <li>from terminal, launch the editor as root. Run: sudo gedit</li> <li>Paste the following line into the text editor: -Dgnu.io.rxtx.SerialPorts=/dev/ttyS0:/dev/ttyS1:/dev/USB0:/dev/ttyACM0</li> <li>Save the file as java.opts to the following location:  /usr/local/MATLAB/R2011a/bin/glnxa64</li> </ol> <ol> <li> <p>State machines purchased from the Sanworks Assembly Surface come with firmware pre-installed\u00a0\u21a9</p> </li> </ol>"},{"location":"install-and-update/samkd21mini-update/","title":"SAMD21Mini","text":"<p>To update state machine firmware for a module using Sparkfun SAMD21 Mini:</p> <ol> <li>Plug the module into the governing computer's USB port.\u00a0</li> <li>(Windows only) If the drivers are not yet installed (or if you're not sure), follow Sparkfun's SAMD21 Mini Driver Installation instructions.</li> <li>Open the Arduino program folder and run Arduino.exe (in Linux/Mac, open the Arduino application).\u00a0</li> <li>Follow the instructions to install support for the SAMD21 Mini board.</li> <li>Restart Arduino\u00a0</li> <li>From the \"Tools\" menu, choose \"Board\" and then \"Sparkfun SAMD21 Mini Breakout\".</li> <li>From the \"Serial Port\" menu, choose \"COMX\" (win) or \"/dev/ttySX\" (linux) where X is the port number. To find your port number in Win7-10, choose \"Start\" and type \"device manager\" in the search window. In the device manager, scroll down to \"Ports (COM &amp; LPT)\" and expand the menu. The COM port will be listed as \"Sparkfun SAMD21 Breakout (COMX)\" where COMX is a serial port name. On Unix this will not be \"COM\". If you can't find your port, see the note below the instructions.</li> <li>From the File menu in Arduino, choose \"Open\" and select the firmware file.\u00a0<ul> <li>A new window should open with the firmware.</li> </ul> </li> <li>In the new window, click the \"upload\" button (the right-pointing arrow roughly under the \"edit\" menu).</li> </ol> <p>If all went well, the green progress indicator should finish, and be replaced with a message: \"Done uploading\".\u00a0</p> <p>On some platforms, you may see a message \"an error occurred while uploading the sketch\". This does not mean the upload was unsuccessful; hopefully future versions of the uploader will fix this error. Try out the module, and see if it behaves as expected.</p> <p>NOTE: In some circumstances, the SAMD21 Mini may get stuck during a firmware upload, in a state with a fading blue LED and no COM port visible to the PC. To fix this, unplug the board, then plug it in and double-click the SAMD21 Mini's black button. The COM port may change temporarily (e.g. from COM3 to COM4). Select the new port in Arduino and load the firmware.</p>"},{"location":"install-and-update/software-update/","title":"Software update","text":""},{"location":"install-and-update/software-update/#automatic","title":"Automatic","text":"<p>Note</p> <p>An experimental auto-updater is included with the latest Bpod software. It is not available on all platforms, and as new software it carries the risk of malfunction in your particular MATLAB + PC configuration. If you choose to use it,</p> <ul> <li>Manually back up your Bpod_Gen2 folder as a precaution.<ul> <li>Run <code>UpdateBpodSoftware()</code> at the MATLAB command line, and follow all prompts</li> <li>Please report any bugs or unexpected behavior to support@sanworks.io</li> </ul> </li> </ul>"},{"location":"install-and-update/software-update/#manual","title":"Manual","text":"<p>To manually update your Bpod software to the newest stable release:</p>"},{"location":"install-and-update/software-update/#if-using-sourcetree","title":"If using SourceTree","text":"<ul> <li>Close MATLAB and open SourceTree<ul> <li>Select the 'Bpod_Gen2' repository tab. If the tab is missing, click '+' and add it back.</li> <li>Click 'Pull'</li> <li>Double-click the latest version in the 'master' branch under 'Branches'</li> </ul> </li> </ul>"},{"location":"install-and-update/software-update/#if-not-using-sourcetree","title":"If NOT using SourceTree","text":"<ul> <li>Close MATLAB</li> <li>Backup your Bpod_Gen2 folder to a safe location</li> <li>Delete Bpod_Gen2 from its original location (Do not change the MATLAB path)</li> <li>Download the latest software from here: https://github.com/sanworks/Bpod_Gen2<ul> <li>Click 'Clone or Download' and select 'Download Zip'</li> <li>Extract the downloaded Zip file to the original Bpod_Gen2 location</li> <li>If desired, rename the root folder to remove '-master'</li> <li>Make sure your MATLAB path includes the Bpod_Gen2 root folder (subfolders not required)</li> </ul> </li> </ul>"},{"location":"install-and-update/teensy3x-update/","title":"Teensy3_X - 4_X","text":"<p>To update firmware for a Bpod module or state machine using Teensy 3.X or 4.X:</p> <ol> <li>Plug the module into the governing computer's USB port. If it is your first time uploading firmware, press Teensy's 'Reset' button once, to make sure its bootloader mode is detected by the OS.</li> <li>Unplug USB cables of all other Bpod modules from the same computer, and unplug all CAT5 (Ethernet) cables from the device you're updating. This is to avoid sending the firmware to the wrong board.</li> <li>Follow the instructions to install Teensyduino into your Arduino program folder. The installer includes Windows drivers.</li> <li>Open the Arduino program folder and run Arduino.exe (in Linux/Mac, open the Arduino application).\u00a0</li> <li>From the \"Tools\" menu, choose \"Board\" and then the Teensy board you want to program. For Bpod modules these are:\u00a0<ul> <li>Teensy 3.2 (for DDS Module, Ethernet Module and Port Array Module)</li> <li>Teensy 3.5 (for Rotary Encoder Module v1)</li> <li>Teensy 3.6 (for State Machine v2.0-2.4, Analog Input v1 and Analog Output v1 modules)</li> <li>Teensy 4.0 (for Rotary Encoder v2 and Valve Driver v2)</li> <li>Teensy 4.1 (for State Machine v2.5 and 2+, HiFi, Analog Input v2 and Analog Output v2)</li> </ul> </li> <li>From the \"Serial Port\" menu, choose \"COMX\" (win) or \"/dev/ttySX\" (linux) where X is the port number. If it is your first time uploading, the port may not be displayed - this is OK. Otherwise, to find your port number in Win7-10, choose \"Start\" and type \"device manager\" in the search window. In the device manager, scroll down to \"Ports (COM &amp; LPT)\" and expand the menu. The COM port will be listed as \"Teensy USB Serial (COMX)\" where COMX is a serial port name. On Unix this will not be \"COM\".</li> <li>Important: Check the top of the firmware file for instructions regarding CPU Speed (selectable from the Arduino 'Tools' menu). The default is OK if no note is given.</li> <li>From the File menu in Arduino, choose \"Open\" and select the firmware file.\u00a0<ul> <li>A new window should open with the firmware.</li> </ul> </li> <li>In the new window, click the \"upload\" button (the right-pointing arrow roughly under the \"edit\" menu).</li> </ol> <p>The Teensyduino application will launch, and a small window with a progress indicator will open and close.</p> <p>If all went well, the blue bar at the bottom of the firmware window should display \"Done uploading\".</p>"},{"location":"module-documentation/","title":"Modules","text":"<p>Beyond solenoid valves, LEDs and TTL pulses, it's hard to anticipate what kinds of outputs Bpod will need to control in future experiments.</p> <p>As a general expansion framework, 3 (or more) of the serial ports of the state machine's microcontroller are exposed to enable Sanworks and users to build Arduino-based modules.</p>"},{"location":"module-documentation/#module-documentation","title":"Module documentation","text":"<p>Each module has three pieces of documentation.</p> <ol> <li>Hardware: located in Assembly &gt; Modules, hardware specifications and the bill of materials required for construction.</li> <li>Serial interface: located in Modules &gt; Serial Interfaces, USB/serial port communication specifications</li> <li>Plugin: located in Modules &gt; Plugins, plugins/class/API for programmatic module interaction</li> </ol> <p>In most cases, configuration of a module at the start of a session involves the use of the plugin, while actions performed during a trial are triggered using serial messages from the state machine.</p>"},{"location":"module-documentation/#general-explanation-of-module-architecture","title":"General explanation of module architecture","text":"<pre><code>flowchart\n\nsubgraph MATLAB\narcom(ArCOM Object)\nmodulefunction(Module Object)\nend\n\nstatemachine(Bpod State Machine\\nUART Serial Port)\n\nsubgraph Module\n\nmoduleserial(ArCOM interface)\narduino(Arduino-based processor)\nend\n\nmodulefunction &lt;--&gt; arcom\nstatemachine &lt;-- Serial message via CAT5e --&gt; moduleserial\narcom &lt;-- Serial message via USB --&gt; moduleserial\nmoduleserial &lt;-- Information exchange --&gt; arduino</code></pre> <p>ArCOM is a library for Arduino developed by Sanworks to simplify data transaction between Arduinos with other Arduinos and computers. Rather than working directly in binary, ArCOM makes it easy to send and receive bytes from a module. The rationale for its development can be found here.</p> <p>For example, modules that play a stimulus are often sent two bytes, byte <code>'P'</code> to signify that the instruction is to play, and a second byte to specify which pre-loaded stimulus to play (e.g. <code>['P' 1]</code>). Communication of all forms is performed using ArCOM, and the plugins (which are classes) are used to make this easily accessible within the protocol file's programming language.</p> <p>Bytes can be sent to the module using both the USB connection with the plugin (which is actually just utilising the <code>ArCOM</code> object), and via the state machine serial port.</p> <p>To understand this sequence more closely, read the example in-depth explanation for the Rotary Encoder Module.</p>"},{"location":"module-documentation/#uart-communication-description","title":"UART communication description","text":"<ul> <li>The UART serial ports are indicated on the enclosure as RJ45 ethernet jacks labeled \"Modules\" 1-N.</li> <li>The ports are configured to communicate with other microcontrollers at 1.3125Mb/s</li> <li>The state machine sends UART serial transmissions to modules using an RS485 IC at each end of the ethernet cable. This employs differential signaling over the Ethernet cable's twisted wire pairs, to make the digital messages more robust against noise.</li> </ul>"},{"location":"module-documentation/#building-your-own-moduleintegrating-existing-arduino-system","title":"Building your own module/integrating existing Arduino system","text":"<p>The Bpod Arduino Shield is a simple circuit board used to interface the serial ports on the state machine and the UART on Arduino boards (M0, Zero, Due, Leonardo, Adafruit MetroM4). </p> <p>General pointers for building a module can be found in the guide to building your own module. It will help to become familiar with the Arduino language, an excellent intro for which is located here.</p>"},{"location":"module-documentation/I2C-messenger-module/","title":"I2CMessenger()","text":""},{"location":"module-documentation/I2C-messenger-module/#description","title":"Description","text":"<p>Translates the Bpod serial interface (UART / RS-485) to the 2-wire I2C interface, using a Bpod I2C Messenger Module. </p> <ul> <li>Enables message transmission to external instruments (e.g. ScanImage).</li> <li>Acts as an I2C master. By default, transmits all incoming messages from Bpod to slave#1.</li> <li>Output logic levels (3.3V or 5V) are configurable with a jumper on the device.</li> <li>Powered by the open source SAMD21 breakout board, an Arduino-compatible ARM Cortex M0 microcontroller.</li> <li>By default, Messenger passes bytes in both directions.</li> <li>The USB connection can be used to load messages (up to 16 bytes) to transmit instead of each byte that arrives.</li> <li>Compatible with Bpod 0.7+</li> </ul>"},{"location":"module-documentation/I2C-messenger-module/#syntax","title":"Syntax","text":"<p>To initialize: <pre><code>I2C = I2CMessenger(portString); </code></pre></p> <ul> <li>portString = the I2C messenger's serial port (e.g. COM3)</li> <li>Returns an I2C Messenger object</li> </ul> <p>To set the current slave: <pre><code>I2C.SlaveAddress = address;\n</code></pre> - address = 1-255 - Default = 1</p> <p>To load a 0-16 byte serial message: <pre><code>I2C.loadMessage(messageIndex, message, [messageSlaveAddress]);\n</code></pre> - messageIndex = 1-256 - message = a 1-16 byte array of bytes - optional: messageSlaveAddress = a fixed I2C slave address for the recipient (default = current slave)</p> <p>To set the messaging mode: <pre><code>I2C.Mode = mode;\n</code></pre> - mode = 'Relay', 'Message', 'USBRelay' or 'USBMessage     - 'Relay' - Sends incoming bytes to current I2C slave     - 'Message' - Sends incoming 1-16 byte messages to their I2C slave(s)     - 'USBRelay' - Sends incoming bytes to the USB serial port (for diagnostics)     - 'USBMessage' - Sends incoming 1-16 byte messages to the USB serial port (for diagnostics)</p> <p>To set the transfer speed: <pre><code>I2C.TransferSpeed = speed;\n</code></pre> - speed = 'Standard' or 'FastMode' (default). Standard = 100kb/s, FastMode = 400kb/s</p> <p>To reset all parameters to defaults: <pre><code>I2C.reset;\n</code></pre></p> <p>To disconnect the serial port and clear the object: <pre><code>clear I2C\n</code></pre></p> <p>Syntax (diagnostics)</p> <p>To force-send a byte from the I2C module to the Bpod state machine serial port: <pre><code>I2C.bpodWrite(byte);\n</code></pre></p> <p>To force-send a byte from the I2C module to the current I2C slave: <pre><code>I2C.I2Cwrite(byte);\n</code></pre></p> <p>To force-send a 1-16 byte message from the I2C module to its I2C slave: <pre><code>I2C.triggerMessage(messageIndex);\n</code></pre></p>"},{"location":"module-documentation/I2C-messenger-module/#example","title":"Example","text":"<p>This code connects to the I2C module. A byte is sent to I2C slave#3, triggered by USB. Then, message#34 is set to a 13-byte message, to slave#5. The latter message is triggered from the state machine.</p> <pre><code>I2C = I2CMessenger('COM6'); % Initialize I2C messenger on port COM6\nI2C.SlaveAddress = 3;\nI2C.Mode = 'Message';\nI2C.I2Cwrite('A'); % Force-send 'A' to slaveAddress 3\nI2C.setMessage(34, 'HelloI2Cslave', 5); % message#, message, slaveAddress\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'SendI2CMessage', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'I2C1', [1 34]});% 1 is the op code to send a message. \n% Because the module is in 'Message' mode, message#34 will\n% be sent instead of byte 34.\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\n</code></pre>"},{"location":"module-documentation/analog-input-module/","title":"AnalogInputModule()","text":""},{"location":"module-documentation/analog-input-module/#description","title":"Description","text":"<p>The BpodAnalogIn class provides an object representing Bpod's Analog Input Module (a general purpose voltage ADC with a dedicated microcontroller).</p> <p>The Analog Input Module has 8 input channels with 12 bits of resolution and configurable ranges up to +/-10V.</p> <p>The object has functions to:</p> <ul> <li>Acquire data to a microSD card, on trigger from the Bpod state machine</li> <li>Return acquired data to MATLAB via USB</li> <li>Stream live analog input data to USB for online viewing and data capture</li> <li>Stream live data to a Bpod output module (DDS or Analog Output).</li> <li>Set voltage thresholds to generate discrete behavior events, which can be handled by the state machine</li> </ul> <p>After running Bpod, an BpodAnalogIn object is initialized with the following syntax:</p> <pre><code>A = BpodAnalogIn('COM3');\n</code></pre> <p>Where COM3 is the analog input module's serial port.</p> <p>The Analog Input device is controlled in 2 ways:</p> <ul> <li>Setting the BpodWavePlayer object's fields</li> <li>Calling the BpodWavePlayer object's functions</li> </ul>"},{"location":"module-documentation/analog-input-module/#object-fields","title":"Object fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>SamplingRate (Hz)<ul> <li>1Hz-20kHz, affects all channels.</li> <li>Other functions (streaming to USB, streaming to external module, running threshold logic) can be used in combination, but will reduce the maximum sampling rate.</li> </ul> </li> <li>InputRange (String)<ul> <li>A cell array of strings specifying voltage input range for EACH channel:- '-10V:10V'    - '-5V:5V'    - '-2.5V:2.5V'    - '0V:10V'    </li> <li>For best signal quality, use the smallest voltage range necessary for your application.</li> <li>Signals that exceed the maximum or minimum will be constrained to the range boundary</li> </ul> </li> <li>nActiveChannels (positive integer)<ul> <li>Number of channels actively sampled (consecutive, beginning with Ch1).- Fewer channels = faster sampling possible. Read the fewest channels necessary for your application.    </li> </ul> </li> <li>Thresholds (V)<ul> <li>A simple voltage threshold and reset scheme is supported by the standard firmware, to generate discrete events</li> <li>Thresholds is a 1 x nChannels vector of voltages.</li> <li>If events are enabled (see startReportingEvents() below), on voltage threshold crossing, the channel# is sent to the state machine.</li> <li>A low-&gt;high crossing will trigger the event, if ResetVoltage (below) is less than threshold.</li> <li>A high-&gt;low crossing will trigger the event, if ResetVoltage is greater than threshold.</li> <li>After a channel's voltage crosses threshold, event generation is disabled until the channel voltage crosses ResetVoltage (below)</li> </ul> </li> <li>ResetVoltages (V)<ul> <li>A 1 x nChannels vector of voltages</li> <li>Event generation is re-enabled after the voltage crosses ResetVoltages(chan).</li> <li>If a channel's ResetVoltage is below Threshold, events are triggered on low -&gt; high threshold crossing.</li> <li>If a channel's ResetVoltage is above Threshold, events are triggered on high -&gt; low threshold crossing.</li> </ul> </li> <li>SMeventsEnabled (logical vector of length nChannels)<ul> <li>Indicates whether each channel's threshold crossing events are sent to the state machine</li> <li>To enable or disable event transmission for the channels selected in SMeventsEnabled:<ul> <li>Call startEventReporting() to enable events (below)</li> <li>Call stopEventReporting() to disable events (below)    </li> </ul> </li> <li>Channels greater than nActiveChannels (above) are ignored.</li> </ul> </li> <li>Stream2Module (logical vector of length nChannels)<ul> <li>Indicates whether each channel's measurements are sent to a connected output module</li> <li>Channels greater than nActiveChannels (above) are ignored.</li> </ul> </li> <li>nSamplesToLog (positive integer)<ul> <li>Determines the maximum number of samples to log to the microSD card after logging is started with startLogging()</li> <li>Fewer samples can be acquired, if a stop command arrives while logging.</li> <li>Set nSamplesToLog to 'Inf' to log until a stop command arrives</li> </ul> </li> </ul>"},{"location":"module-documentation/analog-input-module/#object-functions","title":"Object functions","text":"<ul> <li>startLogging()<ul> <li>Starts logging all samples acquired to the microSD card, overwriting any previously stored data</li> <li>Channels between 1 and nActiveChannels (above) are logged.</li> <li>After logging, acquired data is retrieved with getData() below.</li> </ul> </li> <li>stopLogging()<ul> <li>Stops logging samples to the microSD card.</li> </ul> </li> <li>Data = getData()<ul> <li>Returns a struct containing data logged to the microSD card since the last call to startLogging()</li> <li>Stops logging, if logging was enabled</li> <li>Fields of the data struct are:<ul> <li>X: 1 x nSamples vector containing time of each sample from logging start (in seconds)</li> <li>Y: nActiveChannels x nSamples matrix, containing voltages measured at each time in X    </li> </ul> </li> </ul> </li> <li>startModuleStream()<ul> <li>Starts streaming data to the \"output stream\" module connector</li> <li>For each sample, the data stream output is:<ul> <li>Character 'R' (byte 82)</li> <li>one 2-byte sample for each channel up to nActiveChannels    </li> </ul> </li> <li>Example firmware for the analog output module expects data in this format, and converts it into a voltage signal output.</li> </ul> </li> <li>stopModuleStream()<ul> <li>Stops streaming data to the \"output stream\" module connector</li> </ul> </li> <li>startUSBStream()<ul> <li>Starts streaming data to the USB serial object (obj.Port).</li> <li>Data is in the same format used for streaming to modules (see startModuleStream() above)</li> <li>Following startUSBStream, a sample can be read from the port with:<ul> <li>obj.Port.read(1, 'uint8') % This will return 'R'</li> <li>obj.Port.read(nActiveChannels, 'uint16') % This will return 1 sample (in bits) for each active channel    </li> </ul> </li> <li>Other commands to the module will FAIL while USB streaming. Stop the stream with stopUSBStream().</li> </ul> </li> <li>stopUSBStream()<ul> <li>Stops streaming data to the USB port</li> </ul> </li> <li>startReportingEvents()<ul> <li>Starts sending bytes to the state machine to report threshold crossing events.</li> <li>Bytes sent indicate the channel of the threshold crossing event (i.e. byte 7 = a threshold crossing on Channel 7)</li> <li>Only channels chosen in SMeventsEnabled (above) send events.</li> <li>The conditions for triggering events are controlled by 2 fields: Thresholds and ResetVoltages (above).</li> </ul> </li> <li>stopReportingEvents()<ul> <li>Stops sending threshold crossing events to the state machine.</li> </ul> </li> <li>setZero()<ul> <li>This function is used to compensate for the ADC's zero-code offset, by shifting the ranges so that the ground potential reads as 0V.</li> <li>IMPORTANT: Connect a wire between channel 1's + and - terminals before running setZero.</li> <li>The offset will be saved to the microSD card and loaded automatically on boot.</li> </ul> </li> <li>scope()<ul> <li>Launches an oscilloscope-style GUI for troubleshooting, threshold configuration and online monitoring.</li> </ul> </li> </ul> <ul> <li>By entering a filename in the 'File' field (including the full path) The scope() GUI can continuously capture streaming data to a file during a behavior session, as an alternative to microSD acquisition. See example protocol here.</li> </ul>"},{"location":"module-documentation/analog-input-module/#cleanup","title":"Cleanup","text":"<ul> <li> <p>Clear the BpodAnalogIn object with clear: <pre><code>A = BpodAnalogIn('COM3');\n% ...Use the analog input module\nclear A\n</code></pre></p> </li> <li> <p>Clearing the object releases the serial port, so other applications can access it.</p> </li> <li>If a BpodAnalogIn object is created inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/audioplayer/","title":"BpodAudioPlayer()","text":""},{"location":"module-documentation/audioplayer/#description","title":"Description","text":"<p>BpodAudioPlayer plays audio waveforms on trigger, using Ch1+2 of theAnalog Output Module (a precision voltage DAC with a dedicated microcontroller). This is a convenient way to deliver sound, in applications where anti-aliasing and other standard sound card features are not critical. For high resolution audio, use the Bpod HiFi Module.</p> <p>To use AudioPlayer, you must upload AudioPlayer firmware to the output module from here.</p> <p>Two firmware versions are supported. Their differences are:</p> <ul> <li>AudioPlayer<ul> <li>64 sounds max (up to 1M stereo samples each)</li> <li>96kHz sampling max</li> <li>Loading sounds must occur while sounds are not playing (i.e. before the session or between trials)</li> </ul> </li> <li>AudioPlayerLive (beta)<ul> <li>20 sounds max (up to 1M stereo samples each)</li> <li>44.1kHz sampling max</li> <li>Loading sounds permitted during playback Both firmware versions feature very low latency playback on trigger (~100-200 microseconds).</li> </ul> </li> </ul> <p>Both also support arbitrary onset and offset AM envelopes up to 10k samples, useful for mitigating speaker \"pop\" and spectral splatter.</p> <p>After running Bpod, a BpodAudioPlayer object is initialized with the following syntax:</p> <pre><code>A = BpodAudioPlayer('COM3');\n</code></pre> <p>Where COM3 is the analog output module's serial port.</p> <p>The BpodAudioPlayer device is controlled in 2 ways:</p> <ul> <li>Setting the BpodAudioPlayer object's fields</li> <li>Calling the BpodAudioPlayer object's functions</li> </ul>"},{"location":"module-documentation/audioplayer/#object-fields","title":"Object fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>SamplingRate (Hz)<ul> <li>1Hz-96kHz</li> <li>With AudioPlayerLive firmware, this range is restricted to: 1Hz-44.1kHz.</li> </ul> </li> <li>LoadMode<ul> <li>A string specifying a transmission scheme for loading sound data -&gt; USB -&gt; microSD card:<ul> <li>'Fast' loads quickly, but may interrupt ongoing playback</li> <li>'Safe'* loads more slowly, with care not to disrupt playback**</li> <li>*AudioPlayerLive firmware only</li> <li>**Please verify this mode on your own system; USB host controllers and OS drivers may cause unexpected results.<ul> <li>To use 'Safe' mode effectively, you must have PsychToolbox installed.</li> </ul> </li> </ul> </li> </ul> </li> <li>Waveforms (Cell)<ul> <li>Local copy of all waveforms loaded to microSD with loadSound() function.</li> </ul> </li> <li>TriggerMode (String)<ul> <li>A string specifying how to handle incoming bytes from the Bpod State Machine:<ul> <li>'Normal' - plays the triggered sound, and ignores triggers that arrive during playback</li> <li>'Master' - triggers can force-start a new sound during playback.</li> <li>'Toggle' - starts playback. Stops playback if the same sound is triggered during playback.</li> </ul> </li> </ul> </li> <li>LoopMode (String)<ul> <li>A string specifying whether loop mode is on or off for each channel<ul> <li>'On' loops the waveform until LoopDuration seconds, or until toggled off</li> <li>'Off' = plays the waveform once</li> </ul> </li> </ul> </li> <li>LoopDuration (Seconds)<ul> <li>In loop mode, specifies the duration to loop the waveform following a trigger.</li> <li>Units = seconds</li> </ul> </li> <li>AMEnvelope (Vector of fractional units in range [0 1])<ul> <li>An AM attenuation vector of up to 10,000 samples to apply on sound onset, and again in reverse on sound offset.</li> </ul> </li> <li>BpodEvents (String)<ul> <li>'Off': No feedback to the Bpod state machine</li> <li>'On' generates a serial event when starting playback, and again when playback finishes.<ul> <li>The event byte specifies which sound was started or stopped</li> <li>e.g. byte 3 = sound 3 started (or stopped) playback.</li> </ul> </li> </ul> </li> </ul>"},{"location":"module-documentation/audioplayer/#object-functions","title":"Object Functions","text":"<ul> <li>loadSound(soundNumber, waveform)<ul> <li>Transmits a voltage waveform to the device.</li> <li>soundNumber = index of the waveform (1-64, or 1-20 with AudioPlayerLive firmware)</li> <li>waveform = a 1xN MATLAB array of voltages (samples in volts)<ul> <li>Voltages must be in the range [-5 to +5].</li> <li>An error is raised if the waveform exceeds the allowed maximum (1M samples)</li> </ul> </li> <li>With AudioPlayerLive, the sound is stored in a holding buffer and cannot be triggered, until the next call to 'push' (see below).<ul> <li>This allows (for example), the next trial's sound#3 to be safely loaded while the previous sound#3 is still playing and triggerable.</li> </ul> </li> <li>Function returns an error if waveform was not successfully transmitted.</li> </ul> </li> <li>push() *AudioPlayerLive only<ul> <li>Sets all newly loaded sounds to be the current sounds, and frees the loading buffers for new sounds.</li> </ul> </li> <li>play(soundNumber)<ul> <li>Plays a sound.</li> </ul> </li> <li>stop()<ul> <li>Stops playback</li> </ul> </li> <li>setupSDCard()<ul> <li>Must be run before first use with a new card.</li> <li>Creates an empty data file on the module's microSD card, where waveforms will be stored.</li> <li>Setup may take ~1 minute, depending on the microSD card's speed. A Sandisk U1 class card is strongly recommended.</li> </ul> </li> </ul>"},{"location":"module-documentation/audioplayer/#cleanup","title":"Cleanup","text":"<ul> <li>Clear the BpodAudioPlayer object with clear:</li> </ul> <pre><code>A = BpodAudioPlayer('COM3');\n% ...Use the audio player\nclear A\n</code></pre> <ul> <li>Clearing the object releases the serial port, so other applications can access it.</li> <li>If a BpodAudioPlayer object is created locally inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/dds-module/","title":"DDSModule()","text":""},{"location":"module-documentation/dds-module/#description","title":"Description","text":"<p>DDSModule produces sine or triangle waves with adjustable frequency and amplitude, using an AD9834 Direct Digital Synthesizer IC. Frequency can range from 1Hz to 100kHz. Amplitude can range from 0 to 600mV peak-to-peak.</p> <p>The wave parameters can be adjusted with &lt;100us latency from the state machine, or from a separate module that is configured to stream 16-bit values at up to 10kHz. An internal mapping function maps the 16-bit data stream to output frequencies.</p> <p>The DDSModule MATLAB object allows frequency, amplitude and other parameters to be configured from MATLAB.</p> <p>After running Bpod, a DDSModule object is initialized with the following syntax:</p> <pre><code>D = DDSModule('COM3');\n</code></pre> <p>Where COM3 is the DDS module's serial port.</p> <p>The DDSModule device is controlled by setting the DDSModule object's fields</p>"},{"location":"module-documentation/dds-module/#object-fields","title":"Object Fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>Frequency (Hz)<ul> <li>Range = 1Hz : 100,000Hz.</li> <li>Frequencies above 100,000Hz may be selected, with increasing prevalance of aliasing artifacts from the DDS IC's external 10MHz oscillator.</li> </ul> </li> <li>Amplitude (Normalized Units)<ul> <li>Range = 0 : 1.</li> <li>At range = 0, waveform peak to peak amplitude = ~0mV.</li> <li>At range = 1, waveform peak to peak amplitude = ~600mV.</li> <li>The waveform produced by the DDS IC has a DC offset. Waveform minima increase from 7mV to 40mV as the amplitude is increased from 0 to 1. Depending on demand, a future version of the device may include an output stage to center the output waveform on 0V.</li> </ul> </li> <li>Waveform (String)<ul> <li>A string specifying the shape of the output waveform:<ul> <li>'Sine' - a sinusoidal waveform</li> <li>'Triangle' - a triangle wave.</li> </ul> </li> </ul> </li> <li>MapFcn (String)<ul> <li>A string specifying a mapping function, used to convert a stream of 16-bit values arriving from the module input port into output frequencies in the range specified by OutputMapRange.</li> <li>'Linear' = Bits are mapped directly to frequencies in the range specified by OutputMapRange.</li> <li>'Exp' = The squares of 16-bit values are mapped to the linear space of frequencies.<ul> <li>The 'Exp' mapping function provides increased resolution in low frequencies.</li> </ul> </li> </ul> </li> <li>InputBitRange (1x2 Double, Bits)<ul> <li>A 1 x 2 vector specifying the range of input bits to map to the OutputMapRange (below).</li> <li>Input bits arrive from a Bpod acquisition module (AnalogInput, RotaryEncoder) via the \"Input Stream\" connector.</li> </ul> </li> <li>OutputMapRange (1x2 Double, Frequencies)<ul> <li>A 1 x 2 vector specifying the lower and upper frequency boundaries of the mapping function's output range.<ul> <li>[20 20000] maps the 16-bit input stream in range [0 2^16] to human auditory range of 20Hz-20kHz.</li> <li>[2000 100000] maps the 16-bit input stream to the mouse auditory range of 2kHz-100kHz.</li> </ul> </li> </ul> </li> </ul>"},{"location":"module-documentation/dds-module/#object-functions","title":"Object Functions","text":"<ul> <li>setAmplitudeBits(bits)<ul> <li>Sets the current output waveform amplitude by writing a specific bit value to the amplitude-control DAC.<ul> <li>This function is used in conjunction with setAmplitudeZeroCode() to calibrate the device's output amplitude</li> </ul> </li> <li>bits = An integer bit value, up to 13 bits max (Range = 0-8192)</li> </ul> </li> <li>setAmplitudeZeroCode(bits)<ul> <li>Sets the amplitude-control DAC bit value that codes for a 0V p2p output waveform.</li> <li>bits = An integer bit value, up to 13 bits max (Range = 0-8192)</li> <li>The value is written to the device's EEPROM, and becomes the device's zero code for all subsequent use, even across power cycles.</li> <li>NOTE: To calibrate, with the device plugged into an oscilloscope, use setAmplitudeBits() (above) to find the lowest bit-value at which the output waveform is 0V p2p. Then call setAmplitudeZeroCode with the bit value to store it.</li> </ul> </li> </ul>"},{"location":"module-documentation/dds-module/#cleanup","title":"Cleanup","text":"<ul> <li> <p>Clear the DDSModule object with clear: <pre><code>D = DDSModule('COM3');\n% ...Use the DDS Module\nclear D\n</code></pre></p> </li> <li> <p>Clearing the object releases the serial port, so other applications can access it.</p> </li> <li>If a DDS Module object is created inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/hifi-module/","title":"BpodHiFi()","text":""},{"location":"module-documentation/hifi-module/#description","title":"Description","text":"<p>BpodHiFi plays audio waveforms on trigger, using the Bpod HiFi Module.</p> <p>Example protocols using <code>BpodHiFi()</code> are given here, here and here.</p> <p>After running Bpod, a BpodHiFi object is initialized with the following syntax:</p> <pre><code>H = BpodHiFi('COM3');\n</code></pre> <p>Where COM3 is the HiFi module's serial port.</p> <p>The HiFi module is controlled in 2 ways:</p> <ul> <li>Setting the BpodHiFi object's fields</li> <li>Calling the BpodHiFi object's functions</li> </ul>"},{"location":"module-documentation/hifi-module/#object-fields","title":"Object Fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>SamplingRate (Hz)<ul> <li>44.1kHz, 48kHz, 96kHz and 192kHz (default) are supported.</li> <li>The sampling rate is a global parameter, affecting all sounds loaded to the device.</li> </ul> </li> <li>AMEnvelope (Vector of fractional units in range [0, 1])<ul> <li>An AM attenuation vector of up to 2,000 samples to apply on sound onset, and again in reverse on sound offset.</li> </ul> </li> <li>HeadphoneAmpEnabled(String)<ul> <li>A string specifying whether the headphone amplifier on the base model HiFi module is enabled.</li> <li>Note: The HD model does not have a headphone amp.</li> <li>'Off': Headphone amplifier is disabled. Audio output is still accessible via the RCA jacks.</li> <li>'On' Headphone amplifier enabled. Gain is controlled by setting the HeadphoneAmpGain field.</li> </ul> </li> <li>HeadphoneAmpGain(Value)<ul> <li>Gain of the headphone amplifier (base model HiFi module only)</li> <li>Value in range 0-63 sets the amplifier gain from 0 to its maximum value.</li> </ul> </li> <li>DigitalAttenuation_dB(dB)         - An attenuation factor to constrain the output voltage range of the audio DAC (i.e. digital volume control)         - dB must be in range [-103, 0] for the base model (-103dB = maximum attenuation, 0dB = no attenuation)<ul> <li>dB must be in range [-120, 0] for the HD model (-120dB = maximum attenuation, 0dB = no attenuation)</li> </ul> </li> <li>SynthAmplitude(Value)<ul> <li>Amplitude of persistent synth waveform</li> <li>Amplitude is in range [0, 1] where 0 = synth disabled and 1 = max amplitude</li> <li>Note: synth amplitude will drop to 0 during playback of loaded waveforms, and resume its set point when no waveform is playing.</li> <li>SynthFrequency(Value, Hz)<ul> <li>Frequency of synthesized waveform</li> <li>Range = [20, 80,000]</li> <li>SynthFrequency is ignored when the waveform selected is 'WhiteNoise'</li> </ul> </li> <li>SynthWaveform(String)<ul> <li>Waveform to synthesize continuously when SynthAmplitude is &gt;0</li> <li>Options are 'WhiteNoise' and 'Sine' (others may be added in future releases)</li> </ul> </li> <li>SynthAmplitudeFade(Samples)<ul> <li>Number of samples over which to execute a linear amplitude ramp to the new setpoint when a new SynthAmplitude is set</li> <li>Range = [0, 1920000] where 0 is an instant transition</li> </ul> </li> </ul> </li> </ul>"},{"location":"module-documentation/hifi-module/#object-functions","title":"Object Functions","text":"<ul> <li>load(soundIndex, waveform, *optionalArgs)<ul> <li>Transmits an audio waveform to the device.</li> <li>soundIndex = index of the waveform (1-20) * Note, in communications between the state machine and HiFi module these are 0-19</li> <li>waveform = a 1xN (mono) or 2xN (stereo) MATLAB array of audio samples<ul> <li>Samples must be double type, in the range [-1, 1].</li> <li>An error is raised if the waveform length exceeds the allowed maximum (5,760,000 samples)</li> </ul> </li> <li>The sound is stored in a holding buffer and cannot be triggered, until the next call to 'push' (see below).<ul> <li>This allows (for example), the next trial's sound#3 to be safely loaded while the previous sound#3 is still playing and triggerable.</li> </ul> </li> <li>Optional arguments are given as argument-value pairs:<ul> <li>(...'LoopMode', loopMode...)<ul> <li>loopMode = 0 (No looping)</li> <li>loopMode = 1 (Use looping)</li> </ul> </li> <li>(...'LoopDuration', loopDuration...)<ul> <li>loopDuration is the amount of time to run looping, in seconds. 0 = infinite loop.</li> <li>loopDuration is only valid at the current sampling rate - the sound should be reloaded if sampling rate is changed.</li> </ul> </li> </ul> </li> <li>If used, optional arguments MUST be given in the order above (for efficiency)</li> <li>Function will retry up to 5 times automatically if the waveform was not successfully transmitted.</li> </ul> </li> <li>push()<ul> <li>Sets all newly loaded sounds to be the current sounds, and frees their loading buffers for new sounds.</li> </ul> </li> <li>play(soundNumber)<ul> <li>Plays a sound.</li> </ul> </li> <li>stop()<ul> <li>Stops playback</li> </ul> </li> </ul>"},{"location":"module-documentation/hifi-module/#cleanup","title":"Cleanup","text":"<ul> <li>Clear the BpodHiFi object with clear:</li> </ul> <pre><code>H = BpodHiFi('COM3');\n% ...Use the HiFi module\nclear H\n</code></pre> <ul> <li>Clearing the object releases the serial port, so other applications can access it.</li> <li>If a BpodHiFi object is created locally inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/pulsepal-module/","title":"PulsePalModule()","text":""},{"location":"module-documentation/pulsepal-module/#description","title":"Description","text":"<p>PulsePalModule plays stimulation patterns on trigger, using the Bpod Analog Output Module (a precision voltage DAC with a dedicated microcontroller).</p> <p>Pulse trains are parametric. The parameters are identical to the Beta version of Pulse Pal's MATLAB API.</p> <p>To use PulsePalModule, you must upload PulsePalModule firmware to the output module from here.</p> <p>After running Bpod, a PulsePalModule object is initialized with the following syntax:</p> <pre><code>P = PulsePalModule('COM3');\n</code></pre> <p>Where COM3 is the analog output module's serial port.</p> <p>The PulsePalModule device is controlled in 2 ways:</p> <ul> <li>Setting the PulsePalModule object's fields</li> <li>Calling the PulsePalModule object's functions</li> </ul>"},{"location":"module-documentation/pulsepal-module/#object-fields","title":"Object Fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port</li> </ul> </li> <li>nChannels<ul> <li>Number of output channels on the connected Analog output module</li> </ul> </li> <li>Parameters<ul> <li>1 x nChannels vector, specifying the value of a pulse train parameter.</li> <li>Pulse Pal parameters and their units are described here.</li> <li>When modifying parameters, specify channels by index:<ul> <li>P.phase1Voltage(2) = 5 % sets output channel 2's pulse voltage to 5V</li> <li>P.interPulseInterval(1:4) = 0.001 % Sets the inter-pulse interval on ch1-4 to 1ms</li> <li>P.restingVoltage = 3 % Returns an error: no channels specified</li> </ul> </li> </ul> </li> <li>TriggerMode (integer)<ul> <li>An integer specifying how to handle incoming bytes from Bpod:<ul> <li>0 - plays the triggered pulse train, and ignores triggers on the same channel during playback</li> <li>1 - starts playback. Stops playback if a channel is triggered during playback.</li> </ul> </li> </ul> </li> <li>autoSync (string)<ul> <li>'On': updates the device immediately each time a pulse train parameter is changed in MATLAB</li> <li>'Off': updates to the device are handled manually by calling the sync() function.</li> </ul> </li> </ul>"},{"location":"module-documentation/pulsepal-module/#object-functions","title":"Object Functions","text":"<ul> <li>trigger(channels)<ul> <li>Triggers the output channels specified in (channels) to play their currently loaded pulse train</li> <li>Useful for testing pulse trains. During behavior, pulse trains are triggered directly from the Bpod device.</li> </ul> </li> <li>abort()<ul> <li>Aborts ongoing pulse train playback on all channels.</li> </ul> </li> <li>setVoltage(channel, voltage)<ul> <li>Sets a fixed voltage on an output channel</li> </ul> </li> <li>sync()<ul> <li>If autoSync is disabled, this function manually updates the pulse train parameters on the device to match the MATLAB object.</li> </ul> </li> <li>sendCustomPulseTrain(trainID, pulseTimes, voltages)<ul> <li>Sends a custom pulse train to the device, overriding many parameters.<ul> <li>Set an output channel to use a custom pulse train by setting the object's customTrainID field.</li> <li>trainID: Index of the pulse train (1-4)</li> </ul> </li> <li>pulseTimes: onset times of each pulse in the train (seconds)</li> <li>voltages: voltages of each pulse in the train (volts)</li> </ul> </li> <li>sendCustomWaveform(trainID, samplePeriod, Voltages)<ul> <li>Sends a custom pulse train to the device, overriding many parameters.<ul> <li>Sequential pulses are assumed, and their width is set by the samplePeriod argument.</li> </ul> </li> <li>samplePeriod: The width of each pulse (seconds)</li> <li>voltages: voltages in the waveform (volts)</li> </ul> </li> <li>saveParameters(filename)<ul> <li>Saves the current object's pulse train parameters to a MATLAB .mat file</li> </ul> </li> <li>loadParameters(filename)<ul> <li>Loads pulse train parameters from a MATLAB file previously saved with the saveParameters() function.</li> <li>The PulsePalModule object's fields are populated from the file, and the parameters are synchronized to the device.</li> </ul> </li> <li>setDefaultParams()<ul> <li>Sets all pulse train parameters to their defaults (a 1-second train of 1ms, 5V pulses on all 4 output channels, at 100Hz)</li> </ul> </li> </ul>"},{"location":"module-documentation/pulsepal-module/#triggering-from-the-state-machine","title":"Triggering from the state machine","text":"<p>From the state machine's output actions, use: {'PulsePal1', N} N is a byte, whose bits indicate which channel(s) to trigger.</p>"},{"location":"module-documentation/pulsepal-module/#cleanup","title":"Cleanup","text":"<ul> <li> <p>Clear the PulsePalModule object with clear: <pre><code>P = PulsePalModule('COM3');\n... % Use the module\nclear P\n</code></pre></p> </li> <li> <p>Clearing the object releases the serial port, so other applications can access it.</p> </li> <li>If a PulsePalModule object is created inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/readme/","title":"Readme","text":"<p>This folder contains the files for documentation of individual modules. Refer to the user guide for modules for general information on modules.</p>"},{"location":"module-documentation/rotary-encoder-module/","title":"RotaryEncoderModule()","text":"<p>A rotary encoder is a device that sends information related to its angular rotation. This module would be useful for tasks involving running wheels or choice wheels.</p> <p>Important</p> <p>There are two versions of the Rotary Encoder Module with non-overlapping feature sets. Both modules are controlled by the <code>RotaryEncoderModule</code> class. Functions specific to each version are indicated with:</p> <ul> <li> <p>Module v1 only: </p> </li> <li> <p>Module v2 only: </p> </li> </ul>"},{"location":"module-documentation/rotary-encoder-module/#description","title":"Description","text":"<p><code>RotaryEncoderModule()</code> provides an object to interface with the Bpod rotary encoder module. The rotary encoder module is optimized to integrate a 1024-position quadrature rotary encoder (e.g. Yumo E6B2-CWZ3E) with Bpod.</p> <p>A <code>RotaryEncoderModule</code> object is initialized with the following syntax: <pre><code>R = RotaryEncoderModule('COM3');\n</code></pre> Where COM3 is the rotary encoder module's serial port.</p> <p>The rotary encoder module is controlled in 2 ways:  - Setting the <code>RotaryEncoderModule</code> object's fields - Calling the <code>RotaryEncoderModule</code> object's functions (its methods)</p>"},{"location":"module-documentation/rotary-encoder-module/#object-fields","title":"Object Fields","text":"<ul> <li>Port<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>thresholds<ul> <li>An array of position thresholds (in degrees) for generating events.<ul> <li>Each trial begins at 0 degrees</li> <li>Crossing position threshold N generates a single behavior event (byte N).</li> <li>A crossed threshold is disabled. Disabled thresholds can be reactivated using the enableThresholds() function below.</li> </ul> </li> <li>By default, there are two thresholds - Threshold1 (a negative value in degrees) and Threshold2 (a positive value).</li> </ul> </li> <li>wrapPoint<ul> <li>In degrees, the number of degrees moved in either direction, before the position value \"wraps\" to complete a circle.</li> <li>By default, wrapPoint = 180:<ul> <li>Starting at position 0, Moving clockwise will increase the position towards 180. At 181, position wraps to -180.<ul> <li>Moving counter-clockwise will decrease the position from 0 towards -180. At -181, position wraps to +180.</li> <li>Setting wrapPoint = 360 will require a complete rotation in each direction before the value wraps.</li> </ul> </li> <li>If wrapPoint is set to 0, the position will be tracked continuously in either direction, up to 32 complete rotations.</li> <li>Thresholds cannot exceed the wrapPoint value - i.e. if wrapPoint = 180, a threshold cannot be 190 because it would never be visited.</li> </ul> </li> </ul> </li> <li>sendThresholdEvents<ul> <li>'On' to send threshold crossing events to the Bpod state machine</li> <li>'Off' (default) to disable event transmission.</li> </ul> </li> <li>moduleOutputStream ( module v1 only)<ul> <li>'On' to stream the current position directly to a synthesis module's InputStream port (DDS, AnalogOutput).</li> <li>'Off' (default) to disable the module stream </li> </ul> </li> <li>moduleStreamPrefix ( module v1 only)<ul> <li>When streaming position to a synthesis module (analog output, DDS), a character precedes each 16-bit position value.</li> <li>By default, moduleStreamPrefix is set to 'M' - the op code for the DDS module's \"mapping\" function.</li> </ul> </li> <li>userCallbackFcn<ul> <li>A character array containing the name of a user-created MATLAB function to call when new position data arrives via USB. The latest encoder position (in degrees) is the user function's only input argument.</li> </ul> </li> <li>useAdvancedThresholds ( module v2 only)<ul> <li>Specifies the type of threshold used to generate behavioral events</li> <li>'off' to use standard position thresholds, specified by 'thresholds' property (documented above)</li> <li>'on' to use thresholds programmed with the setAdvancedThresholds() method (ignores 'thresholds' property above)</li> <li>Advanced thresholds can have timing properties, and are not made current until a 'push' command is received.</li> </ul> </li> </ul>"},{"location":"module-documentation/rotary-encoder-module/#object-functions","title":"Object functions","text":"<ul> <li>currentPosition()<ul> <li>Returns the current position of the encoder (in degrees)</li> </ul> </li> <li>zeroPosition()<ul> <li>Sets the current encoder position to 0 degrees</li> </ul> </li> <li>setPosition(newPosition)<ul> <li>newPosition (in degrees) sets the value of the encoder's current position</li> <li>newPosition's absolute value cannot exceed the wrapPoint parameter (above)</li> </ul> </li> <li>enableThresholds(thresholdArray)<ul> <li>thresholdArray = a binary array for each threshold in Thresholds (above), indicating whether it is enabled (1) or disabled (0).</li> </ul> </li> <li>startLogging() ( module v1 only)<ul> <li>Starts logging the current position to the module's microSD card.</li> <li>startLogging erases all previous data logged to the microSD card. Make sure to retrieve previously logged data with getLoggedData() before calling startLogging().</li> </ul> </li> <li>stopLogging() ( module v1 only)<ul> <li>Stops logging the current position to the module's microSD card.</li> </ul> </li> <li>data = getLoggedData() ( module v1 only)<ul> <li>If data was logged to the microSD card, a struct is returned containing:<ul> <li>nPositions (number of positions logged)</li> <li>positionData (a 1 x nPositions vector of positions, in degrees)</li> <li>timeData (a 1 x nPositions vector of times for each position measurement, in seconds)</li> </ul> </li> <li>If no data was logged, the function throws an error to indicate that no data was available.</li> </ul> </li> <li>startUSBStream()<ul> <li>Starts streaming each new position (and corresponding time measurements) to the USB port. </li> <li>Positions and times are stored in a buffer. The latest streaming data can be retrieved by calling readUSBStream().</li> <li>Optionally, add argument 'UseTimer' to avoid buffer overruns if your code will not call readUSBSTream() every 100ms or so. This will start a MATLAB timer in the background to read incoming data from the buffer.</li> </ul> </li> <li>data = readUSBStream()<ul> <li>If new position and time data are available in the streaming buffer, the function returns a struct containing:<ul> <li>nPositions (number of positions logged)</li> <li>positionData (a 1 x nPositions vector of positions, in degrees)</li> <li>timeData (a 1 x nPositions vector of times for each position measurement, in seconds)</li> </ul> </li> <li>If no data is available in the buffer, the function returns a struct with nPositions = 0, and empty position and time fields.</li> <li>If startUSBStream was not called prior to calling readUSBStream, the function returns an error.</li> </ul> </li> <li>stopUSBStream()<ul> <li>Stops the USB data stream previously initialized with startUSBStream().</li> <li>The function pauses for 100ms, then clears any data that arrived in the buffer, ensuring that subsequent data transactions will work.</li> </ul> </li> <li>setAdvancedThresholds(thresholds, [thresholdTypes], [thresholdTimes]) ( module v2 only)<ul> <li>optional input arguments are indicated with []</li> <li>thresholds = an array of position thresholds in degrees. Up to 8 thresholds can be specified.</li> <li>thresholdTypes = an array indicating the threshold type, with one value per threshold:<ul> <li>0: Position threshold</li> <li>1: Threshold reached if position thresholds are NOT crossed for at least a given interval of time</li> </ul> </li> <li>thresholdTimes = an array indicating the timeout for each threshold if threshold type == 1</li> </ul> </li> <li>push() ( module v2 only)<ul> <li>When advanced thresholds are loaded with setAdvancedThresholds(), they are not immediately used by the device. The next call to push() will replace the current threshold set with the most recently loaded thresholds.</li> <li>The state machine can also push thresholds as an output action of a state (e.g. at the beginning of each trial) with the '*' command</li> </ul> </li> <li>streamUI()<ul> <li>Launches a GUI to aid with setting event thresholds. Note: This GUI should be closed before running a session.</li> <li>The GUI starts a USB stream (startUSBStream above) and plots the encoder's position (deg) v. time (s).</li> <li>It allows you to configure and re-enable event thresholds and enable/disable the module stream.</li> <li>The GUI is updated using a MATLAB timer, preserving access to the command line.</li> <li>It appears as:</li> </ul> </li> </ul>"},{"location":"module-documentation/rotary-encoder-module/#cleanup","title":"Cleanup","text":"<ul> <li>Clear the <code>RotaryEncoderModule</code> object with clear: <pre><code>R = RotaryEncoderModule('COM3');\n% ... Use the rotary encoder module\nclear R\n</code></pre></li> <li>Clearing the object releases the serial port, so other applications can access it.</li> <li>If a <code>RotaryEncoderModule</code> object is created inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"module-documentation/rotary-encoder-module/#explanation-of-the-module","title":"Explanation of the module","text":"<p>This is a guide explaining how the module works, which provides a template for understanding the functions of other modules.</p>"},{"location":"module-documentation/rotary-encoder-module/#what-the-module-does","title":"What the module does","text":"<p>Off the shelf rotary encoder's are relatively simple devices that report a direction of movement by a certain amount. The following diagram (from the datasheet for the Yumo E6B2-C rotary encoders) describes the purpose of the black, white, and orange wires; the Phase A, Phase B, and Phase Z, respectively.</p> <p></p> <p>Each wire    can either be High or Low, and the combination of them describes the movement/position of the rotary encoder. The black and white wires pulse once at the same time when the encoder moves enough in one direction. However, one will pulse slightly ahead of the other depending on whether the encoder moved clockwise or anticlockwise. The amount of movement required to trigger a pulse depends on the resolution of the rotary encoder, with a 1024 resolution encoder having 1024 ticks per 360 degrees of rotation. The orange wire will pulse when the rotary encoder is moved through a full rotation (i.e. at the same place each time), allowing a system to monitor absolute position even if power momentarily fails.</p> <p>The fact that a rotary encoder moved clockwise or anti clockwise one tick is low level information, so the rotary encoder module will take that information, convert it into degrees, and timestamp it. That is the purpose of the rotary encoder modulefm: to provide an interface with a rotary encoder to pre-processes the data into something more usable and support more complex functions, such as a threshold system.</p> <p>A printed circuit board, or PCB, is essentially conductive wires printed into an insulated sheet. Rather than have a bird's nest of wires, it's much easier to have the wires statically and reproducibly embedded in a piece of plastic.</p> <p>The module makes use of a Teensy board, a microcontroller that can be programmed with the Arduino language. The board must process the incoming wire inputs. Rather than trying to insert/solder those inputs into the Teensy directly, it's far better to connect a screw terminal into a PCB, which then \"relays\" the signals from the wires to the Teensy's solder pads which are soldered to the PCB.</p> <pre><code>---\ntitle: Rotary Encoder Module Schematic\n---\nflowchart\nre(rotary encoder)\npcb(rotary encoder module PCB)\nmodule(rotary encoder module Board\\n- processes TTL\\n- timestamped position\\n- threshold check etc.)\nusb(Computer)\nstatemachine(State Machine)\n\nre -- movement pulses via TTL--&gt; pcb\npcb -- relay movement TTL --&gt; module\nmodule -- bytes for state machine --&gt; pcb\npcb &lt;-- bytes via CAT5e cable --&gt; statemachine\nmodule &lt;-- ArCOM USB communication --&gt; usb</code></pre>"},{"location":"module-documentation/rotary-encoder-module/#serial-interface-and-module-class-example","title":"Serial interface and module class example","text":"<p>Let's take <code>RotaryEncoderModule.setPosition(newPosition)</code> as an example. <code>newPosition</code> is the value, in degrees, that the rotary encoder module will be set to (recall that the rotary encoder itself can only really report movement, so \"position\" as a value in degrees exists through calculations performed by the module's Teensy board). We can do this in MATLAB, and not have to worry about translating this request into some lower-level language that the Teensy board on the module is reading.</p> <p>The <code>setPosition()</code> class method will use (aka wraps) the <code>ArCOMObject_Bpod.write()</code> method to send the sequence of bytes that the firmware has been programmed to recognise as a command to set a new postion. In this case byte 'P' followed by two bytes (16 bits) for the new position. When the module receives 'P', it recognises that the next two bytes should be interpreted as the number value for the new position.</p> <p>Understanding the serial interface is important and useful because we can use the state machine to do the exact same thing.</p> <pre><code>sma = AddState('State', 'dothing',\n'Tup', 0,\n'StateChangeConditions', {'Tup', 'nextstate'},\n'OutputActions', {'RotaryEncoder1', ['P' 'x' '1']}\n)\n</code></pre> <p>In this case, the 'x' and '1' correspond to bytes 01111000 00110001 or 30769. Note that this example is only illustrative because a <code>newPosition</code> of 30769 would probably fail because it is beyond the <code>wrapPoint</code> for the module.</p> <p>We could also use the Bpod Console's Manual Override to send this byte sequence manually via state machine, or indeed use <code>RotaryEncoderModule.Port.write()</code> to do so via SerialUSB. </p>"},{"location":"module-documentation/stepper-module/","title":"BpodStepperModule()","text":""},{"location":"module-documentation/waveplayer/","title":"BpodWavePlayer()","text":""},{"location":"module-documentation/waveplayer/#description","title":"Description","text":"<p><code>BpodWavePlayer</code> plays analog waveforms on trigger, using the Analog Output Module (a precision voltage DAC with a dedicated microcontroller).</p> <p>The analog output module must have WavePlayer firmware loaded to use this class.</p> <p>After running Bpod, a <code>BpodWavePlayer</code> object is initialized with the following syntax:</p> <pre><code>W = BpodWavePlayer('COM3');\n</code></pre> <p>Where COM3 is the analog output module's serial port.</p> <p>The BpodWavePlayer device is controlled in 2 ways:\u00a0</p> <ul> <li>Setting the <code>BpodWavePlayer</code> object's fields</li> <li>Calling the <code>BpodWavePlayer</code> object's functions</li> </ul>"},{"location":"module-documentation/waveplayer/#object-fields","title":"Object Fields","text":"<ul> <li>Port\u00a0<ul> <li>ArCOM Serial port object</li> </ul> </li> <li>Info<ul> <li>A struct containing the connected module's firmware and hardware versions</li> </ul> </li> <li>SamplingRate (Hz)<ul> <li>1Hz-10kHz, affects all channels.\u00a0</li> <li>Can be set beyond 10kHz, up to to 20kHz, automatically disabling channels 3-4.</li> </ul> </li> <li>OutputRange (String)<ul> <li>A string specifying voltage output range for all channels:\u00a0<ul> <li>'0V:5V'</li> <li>'0V:10V'</li> <li>'0V:12V'</li> <li>'-5V:5V'</li> <li>'-10V:10V'</li> <li>'-12V:12V'</li> </ul> </li> <li>For best signal quality, use the smallest voltage range necessary for your application.\u00a0</li> <li>An error is raised if a voltage sample in a currently loaded waveform is outside of the new range.\u00a0</li> <li>All currently loaded voltage waveforms are automatically re-coded into bits, and sent to the device.</li> </ul> </li> <li>Waveforms (Cell)<ul> <li>Local copy of all waveforms loaded to microSD with loadWaveform() function.</li> </ul> </li> <li>TriggerMode (String)<ul> <li>A string specifying how to handle incoming bytes from Bpod:<ul> <li>'Normal' - plays the triggered wave(s), and ignores triggers on the same channel during playback</li> <li>'Master' - triggers can force-start a new wave during playback.</li> <li>'Toggle' - starts playback. Stops playback if a channel is triggered during playback.</li> </ul> </li> </ul> </li> <li>TriggerProfiles (Matrix)<ul> <li>Allow a single trigger byte to specify different waveforms to play on any subset of channels.</li> <li>TriggerProfiles must be an maxTriggerProfiles X nChannels matrix. Columns are channels, rows are trigger profiles.</li> <li>Each row specifies the waveform to play on each channel when the row's trigger byte arrives.</li> <li>TriggerProfiles are disabled by default. Must be enabled by setting TriggerProfileEnable to 'On'</li> </ul> </li> <li>TriggerProfileEnable (String)<ul> <li>A string that controls how bytes from the state machine are handled, following byte 'P' (for play).</li> <li>'On' = second byte specifies trigger profile to play (range = 1 : maxTriggerProfiles).</li> <li>'Off' = default trigger scheme: one waveform on multiple channels.\u00a0<ul> <li>second byte specifies bits corresponding to playback channels (bytes 1-16 = subsets of channels 1-4)</li> <li>A third byte must follow, specifying the waveform index (range = 1 :maxWaveforms).</li> </ul> </li> </ul> </li> <li>LoopMode (String)<ul> <li>A string specifying whether loop mode is on or off for each channel<ul> <li>'On' loops the waveform until LoopDuration seconds, or until toggled off</li> <li>'Off' = plays the waveform once</li> </ul> </li> </ul> </li> <li>LoopDuration (Seconds)<ul> <li>In loop mode, specifies the duration to loop the waveform following a trigger.</li> <li>Units = seconds</li> </ul> </li> <li>BpodEvents (String)<ul> <li>'Off': No feedback to the Bpod state machine</li> <li>'On' generates a serial event when starting playback, and again when playback finishes.<ul> <li>The event byte specifies which channels started or stopped playback during the current playback sample</li> <li>e.g. byte 0x3 = binary 11; event indicates that channels 1 and 2 simultaneously started (or stopped) playback.</li> <li>e.g. byte 15 = binary 1000; event indicates that channel 4 started (or stopped) playback.</li> </ul> </li> </ul> </li> </ul>"},{"location":"module-documentation/waveplayer/#object-functions","title":"Object Functions","text":"<ul> <li>loadWaveform(waveNumber, waveform)<ul> <li>Transmits a voltage waveform to the device</li> <li>waveNumber = index of the waveform (1-64)</li> <li>waveform = a 1xN MATLAB array of voltages (samples in volts)<ul> <li>Voltages must be in the range specified by the OutputRange field.</li> <li>An error is raised if the waveform exceeds the allowed maximum (1M samples)</li> </ul> </li> <li>Function returns an error if waveform was not successfully transmitted.</li> </ul> </li> <li>play(channels, waveNumber)<ul> <li>Plays a waveform on any subset of channels.</li> <li>channels = a vector indicating the output channels to trigger (e.g. [2 4] = channels 2 and 4)</li> <li>waveNumber = index of the waveform to play on targeted channels (1-64)</li> <li>If TriggerMode is set to 'Normal' and a waveform is playing, the play() command is ignored by the device.</li> <li>If TriggerMode is set to 'Toggle' and a waveform is playing on a targeted channel, the waveform is stopped.</li> <li>If TriggerMode is set to 'Master' and a waveform is playing, it is immediately replaced by the new waveform.</li> <li>Returns an error if TriggerProfileEnable is set to 'On'; see play(triggerProfile)<ul> <li>Plays only 1 waveform per function call. For simultaneous triggering of multiple waveforms, see play(triggerProfile)</li> </ul> </li> </ul> </li> <li>play(triggerProfile)<ul> <li>Plays waveforms on target channels specified by a trigger profile</li> <li>triggerProfile = index of the trigger profile to play (1-64)</li> <li>triggerProfileEnable must be set to 'On'</li> </ul> </li> <li>play(listOfWaveforms)<ul> <li>Requires firmware v5 or newer</li> <li>listOfWaveforms is a 1xnChannels array specifying which waveform to play on which output channel</li> <li>to indicate 'No Waveform', use 0</li> </ul> </li> <li>stop()<ul> <li>Stops all ongoing playback</li> </ul> </li> <li>setFixedVoltage(Channels, Voltage)<ul> <li>Sets a persistent voltage on a subset of output channels.</li> <li>channels = a vector indicating the output channels to set (e.g. [2 4] = channels 2 and 4).</li> <li>Voltage = the voltage to set. The voltage must be within the currently configured OutputRange (see OutputRange field above).</li> <li>Playing a waveform on the channel(s) will return the voltage to 0V after playback completes.</li> </ul> </li> <li>set2Defaults()<ul> <li>Loads default values for all parameters. As of Bpod_Gen2 v1.73, set2Defaults is run on creating a BpodWavePlayer object, to ensure that the device begins each session in a fixed state.</li> <li>set2Defaults can be run explicitly by the user to clear any changes to the parameters.</li> <li>In versions of Bpod_Gen2 prior to 1.73, parameters were read from the device to populate the BpodWavePlayer object on init. This could create issues on shared rigs if one experiment leaves the device in an unexpected state. Updating to Bpod_Gen2 v1.73 or newer is strongly recommended.</li> </ul> </li> <li>setupSDCard()<ul> <li>Must be run before first use with a new card if using firmware v3 or older</li> <li>Creates an empty data file on the module's microSD card, where waveforms will be stored.</li> <li>Setup may take ~1 minute, depending on the microSD card's speed. A SanDisk Industrial card is strongly recommended.</li> </ul> </li> </ul>"},{"location":"module-documentation/waveplayer/#cleanup","title":"Cleanup","text":"<ul> <li>Clear the BpodWavePlayer object with clear:</li> </ul> <pre><code>W = BpodWavePlayer('COM3');\n% ...Use the wave player\nclear W\n</code></pre> <ul> <li>Clearing the object releases the serial port, so other applications can access it.</li> <li>If a BpodWavePlayer object is created inside a MATLAB function, the object is cleared automatically when the function returns.</li> </ul>"},{"location":"serial-interfaces/analogue-input-module-serial-interface/","title":"Analog Input Module Serial Interface","text":""},{"location":"serial-interfaces/analogue-input-module-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to acquire analog waveforms and extract voltage threshold events using the analog input module.</p> <p>Requires an analog input module board with firmware loaded from: - https://github.com/sanworks/Bpod_AnalogInput_Firmware The analog input module must be connected to a free serial port on the state machine module.</p>"},{"location":"serial-interfaces/analogue-input-module-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<p>The state machine command interface consists of bytes sent from the Bpod state machine to the analog input module to start and stop acquisition, data streaming or threshold event transmission.</p> <ul> <li>Byte *255- (reserved): Returns module info to state machine</li> <li>'L' (ASCII 80): Start/Stop logging analog data<ul> <li>'L' (byte 0) must be followed by one byte:<ul> <li>Byte 1: A byte indicating start (1) or stop (0).\u00a0</li> </ul> </li> </ul> </li> <li>'E' (ASCII 70): Start/Stop threshold event transmission to the state machine<ul> <li>'E' (byte 0) must be followed by two bytes:<ul> <li>Byte1: A byte indicating the event target: 0 = USB*, 1 = state machine.</li> <li>Byte 2: A byte indicating whether to start (1) or stop (0) event transmission.</li> </ul> </li> <li>Note: Channels must be selected previously, to transmit events (see op 'K' below).</li> </ul> </li> <li>'S' (ASCII 83):\u00a0 *Start/Stop raw data streaming to USB, or to a module- (Analog Output, DDS, etc)<ul> <li>'S' must be followed by two bytes:<ul> <li>Byte1: A byte indicating the data stream target: 0 = USB*, 1 = output module.</li> <li>Byte 2: A byte indicating whether to start (1) or stop (0) event transmission.</li> </ul> </li> </ul> </li> <li>'#' (ASCII 35): Sync byte from the state machine. This byte can be sent from any state to mark the time in the analog USB data stream. This simplifies alignment of the USB data stream with behavioral events.\u00a0<ul> <li>'#' must be followed by one byte:<ul> <li>Byte N: A byte with a user-determined value, passed from the state machine. From state machine output actions, use: {'AnalogIn1', ['#' N]} where N is any user-determined value that would be useful to have in the analog record\u00a0 (an event code, a state number, etc)</li> </ul> </li> </ul> </li> </ul>"},{"location":"serial-interfaces/analogue-input-module-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows configuration of the analog input module with MATLAB or Python before a trial begins. It also allows data return from the module's onboard microSD card. The <code>AnalogInputModule()</code> plugin for Bpod/MATLAB wraps this interface. The first two commands are the same as for the state machine interface (though an acknowledgement byte = 1 is returned in each case), and additional commands follow:</p> <ul> <li>'R' (ASCII 82): *Set the input range for each channel- (default = +/-10V). 'R' (byte 0) is followed by 1 byte for each channel (8 total):<ul> <li>Bytes 1-8: Each channel's range index. Range indexes are:<ul> <li>0: -10V to +10V</li> <li>1: -5V to +5V</li> <li>2: -2.5V to +2.5V</li> <li>3: 0V to +10V</li> </ul> </li> <li>The analog input module returns a byte (1) to confirm that it has finished setting the range.</li> <li>NOTE: The waveforms are stored on the device in bits. The bits are computed for the current range. When you change the output range of the device, the waveforms already stored will be compressed or expanded in amplitude with respect to the new range.\u00a0</li> </ul> </li> <li>'A' (ASCII 65): Set the number of actively sampled channels\u00a0 'A' (byte 0) is followed by:<ul> <li>Byte 1: The number of consecutive, actively sampled channels (beginning with Ch0).</li> <li>The analog input module returns a byte (1) to confirm that it has finished setting nChannels.</li> <li>Note: Sampling more channels takes more time, and reduces the maximum possible sampling rate. Set this value to the minimum number of channels used.</li> </ul> </li> <li>'F' (ASCII 70): Set sampling frequency. 'F' (byte 0) is followed by:<ul> <li>Bytes 1-4: a 32-bit integer indicating the new sampling frequency (in Hz).</li> <li>The analog input module returns a byte (1) to confirm that it has finished setting sampling frequency.</li> </ul> </li> <li>'O' (ASCII 79): Hand-shake, retrieve firmware version, and reset module parameters to defaults.<ul> <li>The module replies with the following sequence of bytes:<ul> <li>161 (1 byte;\u00a0 a unique acknowledgement byte)</li> <li>firmwareVersion (4 bytes; 32-bit int)</li> </ul> </li> </ul> </li> <li>'D' (ASCII 68): **Retrieve captured analog data</li> </ul> <p>from the module's microSD card. The module replies with the following bytes:     - nSamplesAcquired (4 bytes; 32-bit int); number of samples acquired since last call to ['L' 1] (see above)     - for (each sample)         - for (each actively sampled channel)             - a sample (2 bytes; 16-bit int)     - Samples are returned as bytes in the current voltage range, and must be converted to volts by the software. - 'W' (ASCII 87): Set maximum number of samples to acquire. 'W' (byte 0) is followed by:     - Bytes 1-4: a 32-bit integer indicating the new maximum number of samples to acquire following a call to ['L' 1] (see above)     - The analog input module returns a byte (1) to confirm that it has finished setting the maximum number of samples. - 'K' (ASCII 75): Enable/disable threshold event transmission for each channel. 'K' (byte 0) is followed by:     - Bytes 1-8: each channel's setting: 1 (on) or 0 (off)     - The analog input module returns a byte (1) to confirm the new configuration.     - Note: Event transmission must be enabled globally for this configuration to be observed (see op 'E' above) - 'T' (ASCII 84): Set voltage thresholds and reset voltages for each channel. 'T' (byte 0) is followed by:     - Bytes 1-16: Voltage threshold for each channel in bits (2 bytes; 16-bit int)*8 channels. Bits indicate voltage in the current range.         - Bytes 17-32: Reset voltage for each channel in bits (2 bytes; 16-bit int)*8 channels. Bits indicate voltage in the current range.     - The analog input module returns a byte (1) to confirm that it has finished setting the thresholds and reset voltages. - 'Z' (ASCII 90): Set a channel's zero-code to its current voltage**. 'Z' (byte 0) is followed by:     - Byte 1: Channel (1 byte); the channel to zero.     - Note: The device will measure the channel 100 times, and offset its range so that the average measurement = 0V. Be sure to set the input signal to 0V first.     - Note: This function helps compensate for the DAC's zero-code error (typically &lt;7 LSBs, also dependent on range configuration).     - Note: Any changes to range of any channel will reset zero-code offset to 0 for all channels (i.e. If using zero-code correction, this function must be called after each range adjustment).</p>"},{"location":"serial-interfaces/analogue-input-module-serial-interface/#examples","title":"Examples","text":"<p>Acquire 1 channel of analog data at 10kHz from an ArCOM serial object in MATLAB:\u00a0</p> <pre><code>A = ArCOMObject('COM43', 115200);\nA.write(['A' 1], 'uint8'); % Set the module to read only 1 channel (channel 1)\nA.write('F', 'uint8', 10000, 'uint32'); % Set the module to sample at 10kHz\nA.write(['L' 1], 'uint8'); % Start logging\nAck = A.read(3, 'uint8'); % Read acknowledgement bytes\npause(1); % Wait 1 second for data to be acquired\nA.write(['L' 0], 'uint8'); % Stop logging\nA.write('D', 'uint8'); % Request logged data\nnSamples = A.read(1, 'uint32'); % read the number of samples acquired\nData = A.read(nSamples , 'uint32'); % read the data\nclear A\n</code></pre> <p>Start+Stop logging analog data from the Bpod state machine, when the subject enters+exits port 2 (Assuming the subject has run Bpod and created a <code>AnalogInputModule()</code> object called A).</p> <pre><code>LoadSerialMessages('AnalogIn1', {['L' 1], ['L' 0]});\u00a0 % Set serial messages 1+2 to start+stop logging\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'WaitForPort2Entry', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port2In', 'WaitForPort2Exit'},...\n'OutputActions', {}); % Sends serial message 1 (Start logging)\nsma = AddState(sma, 'Name', 'WaitForPort2Exit', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port2Out', 'StopLogging'},...\n'OutputActions', {'AnalogIn1', 1}); % Sends serial message 1 (Start logging)\nsma = AddState(sma, 'Name', 'StopLogging', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'AnalogIn1', 2}); % Sends serial message 2 (Stop logging)\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\nData = A.getData; % Now that the trial has ended, get data acquired while the subject was in the port\n</code></pre>"},{"location":"serial-interfaces/audioplayer-serial-interface/","title":"AudioPlayer Serial Interface","text":""},{"location":"serial-interfaces/audioplayer-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to play mono or stereo sounds using Ch1 + Ch2 of the analog output module.</p> <p>Requires a 4-channel analog output module board with BpodAudioPlayer or BpodAudioPlayerLive firmware loaded from:</p> <ul> <li>https://github.com/sanworks/Bpod_AnalogOutput_Firmware/tree/master/AnalogOutputModule_4ch<ul> <li>Note: The 'Live' version of BpodAudioPlayer allows sounds to be loaded while playback is in progress, but is limited to 44.1kHz sampling. The analog output module must be connected to a module port on the state machine.</li> </ul> </li> </ul> <p>NOTE: the Analog Output Module is not a sound card! If you need high quality audio playback, use the Bpod HiFi module.</p>"},{"location":"serial-interfaces/audioplayer-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<p>The state machine command interface consists of bytes sent from the Bpod state machine to the AudioPlayer module to start and stop playback.</p> <ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'P' (ASCII 80): Plays a sound.<ul> <li>'P' (byte 0) must be followed by one byte:<ul> <li>Byte 1: The sound to play (zero-indexed).</li> </ul> </li> </ul> </li> <li>'X' (ASCII 88): Stop all playback</li> <li>'x' (ASCII 120): Stop playing a specific sound (if that sound happens to be playing)<ul> <li>'x' (byte 0) must be followed by one byte:<ul> <li>Byte 1: The sound to stop (zero-indexed).</li> </ul> </li> </ul> </li> </ul>"},{"location":"serial-interfaces/audioplayer-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows configuration of the AudioPlayer module from MATLAB or Python before a trial begins. The AudioPlayer class for Bpod/MATLAB wraps this interface. The first two commands are the same as for the state machine interface, and additional commands follow.</p> <ul> <li>(ASCII 229): Handshake and reset. The module replies with the following sequence of bytes:<ul> <li>handshakeReply (1 byte); Equal to 230</li> <li>firmwareVersion(4 bytes; 32-bit int); the current firmware version</li> <li>Note: This op will cancel any currently playing or loading sounds, reset the sampling rate to default 44.1kHz, and clear any previously loaded sounds.</li> </ul> </li> <li>'L' (ASCII 76): Load an audio waveform. 'L' (byte 0) is followed by:<ul> <li>Byte 1: The waveform to load (0-19). Note: In the AudioPlayer plugin, these are corrected for MATLAB's indexing (1-20).</li> <li>Byte 2: isStereo (set to 1 if loading a stereo/2ch waveform, or 0 if mono/1ch). Note: Both speakers play mono waveforms.</li> <li>Bytes 3 - 6: The number of samples in the audio waveform expressed as a 32-bit integer (1-1,000,000).</li> <li>Bytes 7 - (7+((2 + (2*isStereo))*nSamples)): The waveform. Each byte is a 16-bit integer coding for a voltage in the range -5 to +5.</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished reading the last sample.</li> </ul> </li> <li>'&gt;' (ASCII 76): Load an audio waveform in safe mode (slower than 'L'). '&gt;' (byte 0) is followed by bytes as described in op 'L' above.<ul> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished reading the last sample.</li> </ul> </li> <li>'S' (ASCII 83): Set sampling period (units = microseconds, default = 22.675737; sampling rate = 44.1kHz). 'S' (byte 0) is followed by:<ul> <li>Bytes 1-4: Sampling period in microseconds (32-bit float)</li> <li>The AudioPlayer class (MATLAB) exposes sampling rate to the user, and computes sampling period before transmitting.</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting the sampling period. -'*' (ASCII 42): Push any loaded sounds to current playback buffers*.</li> <li>Note: This op will make any sounds loaded recently current at the loaded positions, replacing any sounds at those positions.<ul> <li>Thus, if new sounds for positions 2 and 3 are loaded during a trial for use on the next trial, sending '*' will make these waveforms the current sounds at positions 2 and 3.</li> </ul> </li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished pushing loaded sounds.</li> </ul> </li> <li>'E' (ASCII 69): Enable AM envelope. 'E' (byte 0) is followed by:<ul> <li>Byte 1: UseAMEnvelope: 1 if using AM envelope, 0 if not.</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting the loop mode.</li> </ul> </li> <li>'M' (ASCII 77): Load AM envelope. 'M' (byte 0) is followed by:<ul> <li>Bytes 1-2: EnvelopeSize (16-bit unsigned int): The number of samples in the envelope</li> <li>Bytes 3-(3+EnvelopeSize*4): samples of the 16-bit AM envelope. These are 4-byte floats (attenuating factors) in range [0 to 1].</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished storing the AM envelope. -'Y' (ASCII 89): Setup MicroSD card*.</li> <li>Note: This op must be run before use with a new microSD card. It may take up to 1 minute to complete.</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting up the microSD card.</li> </ul> </li> <li>'O' (ASCII 79): Set loop mode for a waveform. 'O' (byte 0) is followed by:<ul> <li>Bytes 1-20: Loop mode bytes. Each byte represents a waveform: 1 if using loop mode, 0 if not.</li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting the loop mode. -'-' (ASCII 45): Set duration for looping playback on a single trigger.* '-' (byte 0) is followed by:</li> <li>Bytes 1-21: Duration of looped playback on trigger for each waveform (expressed in samples) as a 32-bit integer.<ul> <li>Note: Because loop duration is expressed in samples, it must be re-loaded following sampling rate changes (see op above, 'S')</li> </ul> </li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting the loop duration.</li> </ul> </li> <li>'V' (ASCII 86): Set start/stop event reporting to the state machine. 'V' (byte 0) is followed by:<ul> <li>Byte 1: 1 to report waveform on and off events, 0 if not.</li> <li>Note: start and stop events are returned as bytes to indicate each waveform's playback start OR stop:<ul> <li>Bytes 0-19 = started playback of waveform 1-20</li> <li>Bytes 20-39 = stopped playback of waveform 1-20</li> </ul> </li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting events.</li> </ul> </li> <li>'T' (ASCII 84): Set trigger mode. 'T' (byte 0) is followed by:<ul> <li>Byte 1: The trigger mode index:<ul> <li>0 = Standard mode ('P' command starts playback, 'P' commands received during playback are ignored)</li> <li>1 = Master mode ('P' command starts playback, 'P' commands received during playback start different waveforms)</li> <li>2 = Toggle mode ('P' command starts playback, 'P' commands received during playback ends playback)</li> </ul> </li> <li>The AudioPlayer module returns a byte (1) to confirm that it has finished setting the trigger mode.</li> </ul> </li> <li>'N' (ASCII 78): Return system constants. Nothing follows byte 'N'. The module replies with the following sequence of bytes:<ul> <li>liveMode (1 byte); Corresponds to firmware type (0 = AudioPlayer, 1 = AudioPlayerLive)</li> <li>maxWaves (2 bytes; 16-bit int); maximum number of waveforms supported</li> <li>maxEnvelopeSize (2 bytes; 16-bit int); maximum number of samples in AM envelope</li> <li>maxSamplingRate (4 bytes; 32-bit int); maximum sampling rate permitted</li> </ul> </li> </ul>"},{"location":"serial-interfaces/audioplayer-serial-interface/#examples","title":"Examples","text":"<p>Play sound #4 using an ArCOM serial object in MATLAB:</p> <pre><code>D = ArCOMObject('COM3', 115200);\nD.write(['P' 3], 'uint8'); % Remember that sound position is 0-indexed!\nclear D\n</code></pre> <p>Trigger sound #4 from the Bpod state machine</p> <pre><code>LoadSerialMessages('AudioPlayer1', {['P' 3]}); % Set serial message 1\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'PlaySound', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'AudioPlayer1', 1}); % Sends serial message 1\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\n</code></pre>"},{"location":"serial-interfaces/blink-module-serial-interface/","title":"Blink Module Serial Interface","text":""},{"location":"serial-interfaces/blink-module-serial-interface/#description","title":"Description","text":"<p>Blinks the Arduino board LED (pin 13) to indicate the values of bytes arriving from the Bpod state machine.</p> <p>The blink module is intended for educational and debugging purposes.</p> <p>Requires an Arduino with BlinkModule firmware loaded from:</p> <ul> <li>/Bpod_Gen2/Examples/Firmware/Bpod Shield/BlinkModule/</li> </ul>"},{"location":"serial-interfaces/blink-module-serial-interface/#command-interface","title":"Command Interface","text":"<ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>All other bytes: blinks LED to indicate byte value (byte 1 = 1 blink, byte 4 = 4 blinks, etc.)</li> </ul>"},{"location":"serial-interfaces/blink-module-serial-interface/#example","title":"Example","text":"<p>This code creates, sends and runs a state machine with 1 state. The single state causes the Arduino board to blink 5 times. Set nBlinks to customize blink number.  <pre><code>nBlinks = 5; sma = NewStateMachine();\nsma = AddState(sma, 'Name', 'TriggerBlink', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'end'},...\n'OutputActions', {'BlinkModule1', nBlinks});\nSendStateMachine(sma);\nRawEvents = RunStateMachine\n</code></pre></p>"},{"location":"serial-interfaces/fsm-serial-interface-v17/","title":"State Machine Serial Interface","text":"<p>Firmware version 17</p>"},{"location":"serial-interfaces/fsm-serial-interface-v17/#description","title":"Description","text":"<p>Allows software (i.e. Matlab, Python) to communicate with a Bpod state machine via its USB serial port.</p> <p>This document describes the format of byte strings to send to the state machine's USB serial port, and what bytes to expect in return.</p>"},{"location":"serial-interfaces/fsm-serial-interface-v17/#command-menu","title":"Command Menu","text":"<p>The first byte sent to the Bpod state machine accesses a command menu, where different bytes specify different functions.</p> <p>The command bytes are:</p> <ul> <li>'6' (ASCII 54): Hand shake (used to confirm a valid connection to the state machine).<ul> <li>The state machine returns a byte: '5' (ASCII 53) to confirm the connection.</li> </ul> </li> <li>'F' (ASCII 70): Return firmware version and machine type<ul> <li>The state machine replies with the following bytes:</li> <li>FirmwareVersion(2 bytes; 16-bit int)</li> <li>MachineType (2 bytes; 16-bit int). MachineType is: 1 (State Machine hardware v0.5-0.9) or 2 (pocket state machine)</li> </ul> </li> <li>'H' (ASCII 72): Return the state machine's on-board hardware configuration (excluding modules).<ul> <li>The state machine replies with the following bytes:<ul> <li>MaxStates(2 bytes; 16-bit int); maximum number of supported states in a single state machine description</li> <li>TimerPeriod(2 bytes; 16-bit int); the period (in microseconds) of the state machine's refresh cycle during a trial</li> <li>maxSerialEvents(1 byte); the maximum number of behavior events that can be allocated among connected modules</li> <li>nGlobalTimers (1 byte); the number of global timers supported</li> <li>nGlobalCounters (1 byte); the number of global counters supported</li> <li>nConditions (1 byte); the number of condition-events supported</li> <li>nInputs (1 byte); the number of channels in the state machine's input channel description array</li> <li>inputDescriptionArray (1 byte x nInputs); an array indicating the state machine's onboard input channel types</li> <li>nOutputs (1 byte); the number of channels in the state machine's output channel description array</li> <li>outputDescriptionArray (1 byte x nOutputs); a byte array indicating the state machine's onboard output channel types</li> </ul> </li> </ul> </li> <li>'M' (ASCII 77): Return information describing the state machine's connected modules<ul> <li>The state machine replies with the following bytes:<ul> <li>for each module (character 'U') in outputDescriptionArray (see 'H' above)<ul> <li>moduleConnected (1 byte); 1 if a module was found, 0 if not.</li> <li>if moduleConnected == 1<ul> <li>moduleFirmwareVersion (4 bytes; 32-bit int) - firmware version reported by the module</li> <li>moduleNameLength (1 byte); length of module name, in characters</li> <li>moduleName (1 x moduleNameLength bytes); a character array with the module name</li> <li>moreInfoFollows (1 byte); 0 if module description is complete, 1 if more data follows</li> <li>while moreInfoFollows == 1<ul> <li>infoType (1 byte); Type of info returned</li> <li>if infoType == '#' (ASCII 35); code to request for a specific number of serial events<ul> <li>nEvents(1 byte); number of serial events requested</li> </ul> </li> <li>elseif infoType == 'E' (ASCII 69) - code to assign names to event bytes returned from this module to the state machine<ul> <li>nEventNames (1 byte); number of event names to transmit</li> <li>for 1 to nEventNames<ul> <li>eventNameLength (1 byte); length of this event name</li> <li>eventName (1 x eventNameLength bytes); a character array with the event name</li> </ul> </li> </ul> </li> <li>end</li> </ul> </li> <li>end<ul> <li>moreInfoFollows (1 byte); 0 if module description is complete, 1 if more data follows</li> </ul> </li> </ul> </li> <li>end</li> </ul> </li> <li>end</li> <li>end</li> </ul> </li> <li>'%' (ASCII 37): Set number of behavior events allocated to each module. '#' (byte 0) is followed by:</li> <li>Bytes 1-nModules: a byte for each module, indicating the number of behavior events it can generate.<ul> <li>NOTE: nModules is the sum of (character 'U') in outputDescriptionArray returned by the state machine (see 'H' above)</li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting each module's event allocation.</li> <li>NOTE: By default, the maximum number of events (see 'H' -&gt; maxSerialEvents above) is distributed equally among modules. If a module requests a specific number of events (see 'M' -&gt; '#' above), the software (MATLAB / Python) must calculate the reallocation using the set of requests, and then use this command ('%') to update the state machine.</li> <li>'E' (ASCII 69): Set the state of each input channel (enabled/disabled). 'E' (byte 0) is followed by:</li> <li>Bytes 1-nInputs: a byte for each input channel, indicating whether it is enabled (1) or disabled (0).<ul> <li>nInputs must exist, having been returned from the 'H' command (above)</li> <li>Generally, low-impedance inputs that are not connected to a signal source or tied to a pull-down resistor should be disabled.<ul> <li>On the Bpod state machine, only the port input channels (i.e. photogates) are low impedance inputs.</li> </ul> </li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting each channel's enabled property.</li> <li>'J' (ASCII 74): Enable/Disable relay of incoming bytes from one module to the USB port. 'J' (byte 0) is followed by:</li> <li>Byte 1: the module number to enable or disable (indexed by 0)</li> <li>Byte 2: the state of the module (0 = relay off, 1 = relay on)</li> </ul> </li> <li>'K' (ASCII 87): Set a state synchronization channel. 'K' (byte 0) is followed by:<ul> <li>Byte 1: the digital output channel to use for synchronization. This channel is an index of outputDescriptionArray (see 'H' above).</li> <li>Byte 2: the synchronization mode. Valid modes are:<ul> <li>0: Channel set high on trial start and low on trial end</li> <li>1: Channel switches logic states with each state transition</li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting the sync channel configuration.</li> </ul> </li> <li>'O' (ASCII 79): Override digital output line state. 'O' (byte 0) is followed by:<ul> <li>Byte 1: the digital output channel to override. This channel is an index of outputDescriptionArray (see 'H' above).</li> <li>Byte 2: the new state of the channel<ul> <li>If outputDescriptionArray[index] is a digital line (D,B,W), Byte 2 should be (1 = high, 0 = low)</li> <li>If outputDescriptionArray[index] is a PWM line (P), Byte 2 should be the new PWM duty cycle (0-255)</li> <li>If outputDescriptionArray[index] is a valve bank (S), Byte 2 should be a byte whose bits set the state of the 8 valves.</li> </ul> </li> </ul> </li> <li>'I' (ASCII 73): Read the state of a digital input channel. 'I' (byte 0) is followed by:<ul> <li>Byte 1: the digital input channel to read. This channel is an index of inputDescriptionArray (see 'H' above).<ul> <li>The state machine will return:<ul> <li>0 if the channel's logic level is low</li> <li>1 if the channel's logic level is high.</li> </ul> </li> </ul> </li> </ul> </li> <li>'T' (ASCII 84): Transmit a string of bytes to a connected module. 'T' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module.<ul> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> <li>Byte 2: nBytes (number of bytes in the message)</li> <li>Bytes 3 --&gt; (2+nBytes): The message to transmit</li> </ul> </li> </ul> </li> <li>'L' (ASCII 76): Store a list of 1-3 byte serial messages, which can later be sent to modules by message index. 'L' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module. (Each module has its own message library)<ul> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> </ul> </li> <li>Byte 2: nMessages (the number of messages to store)<ul> <li>for each message between 1 and nMessages<ul> <li>MessageIndex (1 byte; 1-255)</li> <li>MessageLength (1 byte; 1-3)</li> <li>for 1 to MessageLength<ul> <li>1 Byte (The next byte of the current message)</li> </ul> </li> </ul> </li> </ul> </li> <li>The state machine returns a byte (1) to confirm that the specified channel's message library has been updated.</li> </ul> </li> <li>'&gt;' (ASCII 62): Clear the serial message libraries. No data follows.<ul> <li>The state machine restores each message to default - a message of length 1, whose value is equal to its index.</li> <li>The state machine returns a byte (1) to confirm that the message libraries have been cleared.</li> </ul> </li> <li>'U' (ASCII 85): Transmit a stored serial message (by index) to a connected module. 'U' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module.</li> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> <li>Byte 2: the index of the message to send.</li> </ul> </li> <li>'V' (ASCII 86): Manually override an input channel, creating a virtual event. 'V' (byte 0) is followed by:<ul> <li>Byte 1: the input channel to override. This channel is an index of inputDescriptionArray (see 'H' above).</li> <li>Byte 2: the new value of the channel (0 = low, 1 = high).</li> <li>NOTE: If a channel is overridden, it will remain in the overridden state regardless of what signals arrive. The channel must be reset with a second call to 'V' in order to return control to the hardware.</li> </ul> </li> <li>'C' (ASCII 67): Transmit a state machine description to the state machine device. 'C' (byte 0) is followed by:<ul> <li>Bytes 1-2: nBytes (the number of bytes in the state machine description, NOT including the first 3 bytes; 'C' and nBytes)</li> <li>Byte 3: nStates (the number of states in the state machine description)</li> <li>for each state s between 1 and nStates<ul> <li>TimerMatrix[s] (1 byte) - The state to go to if the state timer elapses</li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte) - The number of events handled in this state (overriding default of not-handled)</li> <li>if nOverrides &gt; 0<ul> <li>for each event e between 1 and nOverrides<ul> <li>thisEvent (1 byte) - (the numeric code of the event handled in state s)</li> <li>thisState (1 byte) - (the state to go to if thisEvent occurs in state s)</li> </ul> </li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of outputs controlled in this state (overriding default of no output)</li> <li>if nOverrides &gt; 0<ul> <li>for each output channel between 1 and nOverrides<ul> <li>thisOutputChannel (1 byte) - (the index of the target output channel outputDescriptionArray)</li> <li>thisOutputValue (1 byte) - (the value of the output channel)</li> </ul> </li> </ul> </li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global timer start events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each timer t between 1 and nOverrides<ul> <li>thisTimer (1 byte) - (the index of the global timer whose start-events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisTimer's start event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global timer end events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each timer t between 1 and nOverrides<ul> <li>thisTimer (1 byte) - (the index of the global timer whose end-events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisTimer's end event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global counter threshold events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each counter c between 1 and nOverrides<ul> <li>thisCounter (1 byte) - (the index of the global counter whose threshold events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisCounter's threshold event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of condition events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each condition c between 1 and nOverrides<ul> <li>thisCondition (1 byte) - (the index of the condition whose events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if a thisCondition event occurs)</li> </ul> </li> </ul> </li> <li>for each global timer between 1 and nGlobalTimers (nGlobalTimers must be retrieved earlier, using command 'H' above)<ul> <li>linkedOutputChannel (1-byte) - index of an output channel in outputDescriptionArray. 255 = no channel linked).</li> </ul> </li> <li>for each global timer between 1 and nGlobalTimers<ul> <li>onMessage (1-byte). This is the index of a message set previously with command 'L' above, to send when the timer starts.</li> </ul> </li> <li>Note: The target module for onMessage is defined by linkedOutputChannel (above), if linkedOutputChannel is a module port.</li> <li>for each global timer between 1 and nGlobalTimers<ul> <li>offMessage (1-byte). This is the index of a message set previously with command 'L' above, to send when the timer starts.</li> </ul> </li> <li>Note: The target module for offMessage is defined by linkedOutputChannel (above), if linkedOutputChannel is a module port.</li> <li>for each global timer between 1 and nGlobalTimers<ul> <li>loopMode (1-byte). Set to 0 (default) if a one-shot timer, 1 to use the timer in loop mode</li> </ul> </li> <li>for each global timer between 1 and nGlobalTimers<ul> <li>sendGlobalTimerEvents (1-byte). Set to 1 (default) to generate global timer on and off events. Set to 0 to disable them.</li> </ul> </li> <li>for each global counter between 1 and nGlobalCounters (nGlobalCounters must be retrieved earlier, using command 'H' above)<ul> <li>attachedEvent(1-byte). This is the index of a behavior event to count.</li> </ul> </li> <li>for each condition between 1 and nConditions (nConditions must be retrieved earlier, using command 'H' above)<ul> <li>conditionChannel(1-byte). This is an input channel index in inputDescriptionArray.</li> </ul> </li> <li>for each condition between 1 and nConditions (nConditions must be retrieved earlier, using command 'H' above)<ul> <li>conditionValue(1-byte). 0 = low, 1 = high. Defines the state of the channel when the condition is true.</li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>stateTimer[s] (4 bytes; 32-bit int). This state's internal timer (units = state machine cycles, 1 cycle = timerPeriod returned from 'H' above).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimers<ul> <li>globalTimer[t] (4 bytes; 32-bit int). Duration of global timer t (units = state machine cycles).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimers<ul> <li>globalTimerOnsetDelay[t] (4 bytes; 32-bit int). Onset delay of global timer t (units = state machine cycles).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimers<ul> <li>globalTimerLoopInterval[t] (4 bytes; 32-bit int). Delay between timer loop iterations (units = state machine cycles).</li> </ul> </li> <li>for each global counter between 1 and nGlobalCounters<ul> <li>globalCounterThreshold[t] (4 bytes; 32-bit int). Threshold (units = instances of the event being counted).</li> </ul> </li> <li>NOTE: The state machine will return a confirmation byte to indicate successful transmission of the state machine description, on the next call to RunStateMachine. This saves 1 read/write cycle, and reduces dead-time.</li> </ul> </li> <li>'R' (ASCII 82): Run state machine.<ul> <li>If a new state machine was sent prior to calling 'R', the state machine returns a byte (1) to confirm.</li> <li>While the trial is running, event codes and soft-codes are returned via the serial report as follows:<ul> <li>Op-code (byte 1) = 1 if the message is an event, and 2 if the message is a soft code</li> <li>If op-code 1,<ul> <li>nEvents (byte 2) - number of events returned</li> </ul> </li> <li>for each event between 1 and nEvents         - Event code (1 byte)</li> <li>If op-code 2,<ul> <li>Soft code (byte 2) = the soft code to pass to the soft code handler function. Exit state: If event code 255 was returned, the state machine has reached an exit state. It then sends the trial's timing data as follows:</li> </ul> </li> <li>Trial start timestamp in milliseconds (4 bytes; 32-bit integer)</li> <li>nTimestamps (2 bytes; 16-bit integer) - the number of timestamps to be transmitted</li> <li>for each timestamp between 1 and nTimestamps:<ul> <li>Timestamp (4 bytes; 32-bit integer) - for each event recorded during the trial, a 32-bit timestamp. Units = 100us state machine cycles following trial start.</li> </ul> </li> </ul> </li> </ul> </li> <li>'X' (ASCII 88): Force-exit the currently running state machine, and return the partial trial's data.<ul> <li>No data follows.</li> <li>The state machine then returns the data in same format as for 'R' command above.</li> </ul> </li> <li>'Z' (ASCII 90): Disconnect state machine from the USB serial port.<ul> <li>No data follows.</li> <li>This resets several program variables to prepare the state machine for its next connection</li> </ul> </li> </ul>"},{"location":"serial-interfaces/fsm-serial-interface-v18/","title":"State Machine Serial Interface","text":"<p>Firmware version 18-22</p> <p>Find the previous (&lt;18) state machine interface here.</p>"},{"location":"serial-interfaces/fsm-serial-interface-v18/#description","title":"Description","text":"<p>Allows software (i.e. Matlab, Python) to communicate with a Bpod state machine via its USB serial port.</p> <p>This document describes the format of byte strings to send to the state machine's USB serial port, and what bytes to expect in return.</p>"},{"location":"serial-interfaces/fsm-serial-interface-v18/#discovery-byte","title":"Discovery byte","text":"<p>While not yet connected to software, the Bpod state machine sends a \"discovery byte\" to any software that connects to its serial port. This allows PC-side software to identify the correct port, without sending probe bytes that could be handled in unexpected ways by other instruments.</p> <p>The discovery byte identifying a Bpod finite state machine is: 222, and may be read by simply opening the port and waiting 150ms for the byte to arrive.</p>"},{"location":"serial-interfaces/fsm-serial-interface-v18/#command-menu","title":"Command Menu","text":"<p>The first byte sent to the Bpod state machine accesses a command menu, where different bytes specify different functions.</p> <p>The command bytes are:</p> <ul> <li>'6' (ASCII 54): Hand shake (used to confirm a valid connection to the state machine).<ul> <li>Sending this byte disables discovery byte transmission until it is explicitly restored with the 'Z' command (see below).</li> <li>The state machine returns a byte: '5' (ASCII 53) to confirm the connection.</li> <li>The state machine also resets the session clock (see '*' command below)</li> <li>Note: You may find an extra discovery byte in the buffer after sending the hand shake. Be sure to clear it before sending the next command.</li> </ul> </li> <li>'F' (ASCII 70): Return firmware version and machine type<ul> <li>The state machine replies with the following bytes:</li> <li>FirmwareVersion(2 bytes; 16-bit int)</li> <li>MachineType (2 bytes; 16-bit int). MachineType is: 1 (State Machine 0.5) 2 (State Machine 0.7-0.9) or 3 (State Machine 2)</li> </ul> </li> <li>'*' (ASCII 42): Reset session clock<ul> <li>This sets the session clock to 0.</li> <li>Trial start and end times will be provided in reference to the last clock reset.</li> <li>The state machine returns a byte (1) to confirm that it has finished resetting the session clock.</li> </ul> </li> <li>'G' (ASCII 71): Return timestamp transmission scheme<ul> <li>The state machine replies with one byte, TimestampTransmissionScheme:<ul> <li>0: Post-trial (event timestamps are stored in Bpod's RAM and sent at once when each trial ends)</li> <li>1: Live (during a trial, each cycle's list of event codes sent to the PC is followed by the cycle's timestamp).</li> </ul> </li> <li>Note: In either case, timestamps are returned in units of state machine cycles (default = 100 microseconds / cycle).</li> </ul> </li> <li>'H' (ASCII 72): Return the state machine's on-board hardware configuration (excluding modules).<ul> <li>The state machine replies with the following bytes:<ul> <li>MaxStates(2 bytes; 16-bit int); maximum number of supported states in a single state machine description</li> <li>TimerPeriod(2 bytes; 16-bit int); the period (in microseconds) of the state machine's refresh cycle during a trial</li> <li>maxSerialEvents(1 byte); the maximum number of behavior events that can be allocated among connected modules</li> <li>nGlobalTimers (1 byte); the number of global timers supported</li> <li>nGlobalCounters (1 byte); the number of global counters supported</li> <li>nConditions (1 byte); the number of condition-events supported</li> <li>nInputs (1 byte); the number of channels in the state machine's input channel description array</li> <li>inputDescriptionArray (1 byte x nInputs); an array indicating the state machine's onboard input channel types</li> <li>nOutputs (1 byte); the number of channels in the state machine's output channel description array</li> <li>outputDescriptionArray (1 byte x nOutputs); a byte array indicating the state machine's onboard output channel types</li> </ul> </li> </ul> </li> <li>'M' (ASCII 77): Return information describing the state machine's connected modules<ul> <li>The state machine replies with the following bytes:<ul> <li>for each module (character 'U') in outputDescriptionArray (see 'H' above)<ul> <li>moduleConnected (1 byte); 1 if a module was found, 0 if not.</li> <li>if moduleConnected == 1<ul> <li>moduleFirmwareVersion (4 bytes; 32-bit int) - firmware version reported by the module</li> <li>moduleNameLength (1 byte); length of module name, in characters</li> <li>moduleName (1 x moduleNameLength bytes); a character array with the module name</li> <li>moreInfoFollows (1 byte); 0 if module description is complete, 1 if more data follows</li> <li>while moreInfoFollows == 1<ul> <li>infoType (1 byte); Type of info returned</li> <li>if infoType == '#' (ASCII 35); code to request for a specific number of serial events<ul> <li>nEvents(1 byte); number of serial events requested</li> </ul> </li> <li>elseif infoType == 'E' (ASCII 69) - code to assign names to event bytes returned from this module to the state machine<ul> <li>nEventNames (1 byte); number of event names to transmit</li> <li>for 1 to nEventNames<ul> <li>eventNameLength (1 byte); length of this event name</li> <li>eventName (1 x eventNameLength bytes); a character array with the event name</li> </ul> </li> </ul> </li> <li>end</li> </ul> </li> <li>end<ul> <li>moreInfoFollows (1 byte); 0 if module description is complete, 1 if more data follows</li> </ul> </li> </ul> </li> <li>end</li> </ul> </li> <li>end</li> </ul> </li> <li>end</li> </ul> </li> <li>'%' (ASCII 37): Set number of behavior events allocated to each module. '#' (byte 0) is followed by:<ul> <li>Bytes 1-nModules: a byte for each module, indicating the number of behavior events it can generate.<ul> <li>NOTE: nModules is the sum of (character 'U') in outputDescriptionArray returned by the state machine (see 'H' above)</li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting each module's event allocation.</li> <li>NOTE: By default, the maximum number of events (see 'H' -&gt; maxSerialEvents above) is distributed equally among modules. If a module requests a specific number of events (see 'M' -&gt; '#' above), the software (MATLAB / Python) must calculate the reallocation using the set of requests, and then use this command ('%') to update the state machine.</li> <li>'E' (ASCII 69): Set the state of each input channel (enabled/disabled). 'E' (byte 0) is followed by:</li> <li>Bytes 1-nInputs: a byte for each input channel, indicating whether it is enabled (1) or disabled (0).<ul> <li>nInputs must exist, having been returned from the 'H' command (above)</li> <li>Generally, low-impedance inputs that are not connected to a signal source or tied to a pull-down resistor should be disabled.<ul> <li>On the Bpod state machine, only the port input channels (i.e. photogates) are low impedance inputs.</li> </ul> </li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting each channel's enabled property.</li> <li>'J' (ASCII 74): Enable/Disable relay of incoming bytes from one module to the USB port. 'J' (byte 0) is followed by:</li> <li>Byte 1: the module number to enable or disable (indexed by 0)</li> <li>Byte 2: the state of the module (0 = relay off, 1 = relay on)</li> </ul> </li> <li>'K' (ASCII 87): Set a state synchronization channel. 'K' (byte 0) is followed by:<ul> <li>Byte 1: the digital output channel to use for synchronization. This channel is an index of outputDescriptionArray (see 'H' above).</li> <li>Byte 2: the synchronization mode. Valid modes are:<ul> <li>0: Channel set high on trial start and low on trial end</li> <li>1: Channel switches logic states with each state transition</li> </ul> </li> <li>The state machine returns a byte (1) to confirm that it has finished setting the sync channel configuration.</li> </ul> </li> <li>'O' (ASCII 79): Override digital output line state. 'O' (byte 0) is followed by:<ul> <li>Byte 1: the digital output channel to override. This channel is an index of outputDescriptionArray (see 'H' above).</li> <li>Byte 2: the new state of the channel<ul> <li>If outputDescriptionArray[index] is a digital line (D,B,W), Byte 2 should be (1 = high, 0 = low)</li> <li>If outputDescriptionArray[index] is a PWM line (P), Byte 2 should be the new PWM duty cycle (0-255)</li> <li>If outputDescriptionArray[index] is a valve bank (S), Byte 2 should be a byte whose bits set the state of the 8 valves.</li> </ul> </li> </ul> </li> <li>'I' (ASCII 73): Read the state of a digital input channel. 'I' (byte 0) is followed by:<ul> <li>Byte 1: the digital input channel to read. This channel is an index of inputDescriptionArray (see 'H' above).<ul> <li>The state machine will return:<ul> <li>0 if the channel's logic level is low</li> <li>1 if the channel's logic level is high.</li> </ul> </li> </ul> </li> </ul> </li> <li>'T' (ASCII 84): Transmit a string of bytes to a connected module. 'T' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module.<ul> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> <li>Byte 2: nBytes (number of bytes in the message)</li> <li>Bytes 3 --&gt; (2+nBytes): The message to transmit</li> </ul> </li> </ul> </li> <li>'L' (ASCII 76): Store a list of 1-3 byte serial messages, which can later be sent to modules by message index. 'L' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module. (Each module has its own message library)</li> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> <li>Byte 2: nMessages (the number of messages to store)<ul> <li>for each message between 1 and nMessages<ul> <li>MessageIndex (1 byte; 1-255)</li> <li>MessageLength (1 byte; 1-3)</li> <li>for 1 to MessageLength<ul> <li>1 Byte (The next byte of the current message)</li> </ul> </li> </ul> </li> </ul> </li> <li>The state machine returns a byte (1) to confirm that the specified channel's message library has been updated.</li> </ul> </li> <li>'&gt;' (ASCII 62): Clear the serial message libraries. No data follows.         - The state machine restores each message to default - a message of length 1, whose value is equal to its index.<ul> <li>The state machine returns a byte (1) to confirm that the message libraries have been cleared.</li> </ul> </li> <li>'U' (ASCII 85): Transmit a stored serial message (by index) to a connected module. 'U' (byte 0) is followed by:<ul> <li>Byte 1: the index of the targeted module.</li> <li>The module index is in range 0 -&gt; max number of modules (instances of 'U' in outputDescriptionArray; see 'H' above)</li> <li>Byte 2: the index of the message to send.</li> </ul> </li> <li>'S' (ASCII 83): Echo a USB soft code targeting the PC. 'S' (byte 0) is followed by:<ul> <li>Byte1: (The soft code to echo)<ul> <li>The state machine replies with the following bytes:<ul> <li>2 (the op-code for a soft code; see command 'R' below)</li> <li>Byte1</li> <li>This function is useful for debugging and testing soft code handlers. '~' (ASCII 126): Receive a USB soft code targeting the state machine. '~' (byte 0) is followed by:</li> </ul> </li> <li>Byte1: (The soft code)</li> <li>This will only have an effect if the state machine is running, and in a state that handles the specific soft code sent.</li> </ul> </li> </ul> </li> <li>'V' (ASCII 86): Manually override an input channel, creating a virtual event. 'V' (byte 0) is followed by:<ul> <li>Byte 1: the input channel to override. This channel is an index of inputDescriptionArray (see 'H' above).</li> <li>Byte 2: the new value of the channel (0 = low, 1 = high).</li> <li>NOTE: If a channel is overridden, it will remain in the overridden state regardless of what signals arrive. The channel must be reset with a second call to 'V' in order to return control to the hardware.</li> </ul> </li> <li>'C' (ASCII 67): Transmit a compressed state machine description to the state machine device. 'C' (byte 0) is followed by:<ul> <li>Byte 1: RunStateMatrixASAP (if 1, triggers the new SM to auto-run after the current one completes, without a call to 'R')<ul> <li>Byte 2: using255BackSignal (if 1, only 254 actual states are allowed and \"going to state 255\" jumps back to previous state)</li> <li>Bytes 3-4: nBytes (the number of bytes in the remaining state machine description, NOT including the first 4 bytes and 'C')</li> <li>Byte 5: nStates (the number of states in the state machine description)</li> <li>Byte 6: nGlobalTimersUsed (The 1-based index of the highest global timer used in the state matrix; 0 if none)</li> <li>Byte 7: nGlobalCountersUsed (The 1-based index of the highest global counter used in the state matrix; 0 if none)</li> <li>Byte 8: nConditionsUsed (The 1-based index of the highest condition used in the state matrix; 0 if none)</li> <li>for each state s between 1 and nStates<ul> <li>TimerMatrix[s] (1 byte) - The state to go to if the state timer elapses</li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte) - The number of events handled in this state (overriding default of not-handled)</li> <li>if nOverrides &gt; 0<ul> <li>for each event e between 1 and nOverrides<ul> <li>thisEvent (1 byte) - (the numeric code of the event handled in state s)</li> <li>thisState (1 byte) - (the state to go to if thisEvent occurs in state s)</li> </ul> </li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of outputs* controlled in this state (overriding default of no output)</li> <li>*note: As of firmware v18, global timer trigger and cancel output actions are sent separately (below)</li> <li>if nOverrides &gt; 0<ul> <li>for each output channel between 1 and nOverrides<ul> <li>thisOutputChannel (1 byte) - (the index of the target output channel outputDescriptionArray)</li> <li>thisOutputValue (1 byte) - (the value of the output channel)</li> </ul> </li> </ul> </li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global timer start events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each timer t between 1 and nOverrides<ul> <li>thisTimer (1 byte) - (the index of the global timer whose start-events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisTimer's start event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global timer end events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each timer t between 1 and nOverrides<ul> <li>thisTimer (1 byte) - (the index of the global timer whose end-events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisTimer's end event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of global counter threshold events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each counter c between 1 and nOverrides<ul> <li>thisCounter (1 byte) - (the index of the global counter whose threshold events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if thisCounter's threshold event occurs)</li> </ul> </li> </ul> </li> <li>for each state s between 1 and nStates<ul> <li>nOverrides (1 byte): The number of condition events handled in this state (overriding default of none)</li> <li>if nOverrides &gt; 0<ul> <li>for each condition c between 1 and nOverrides<ul> <li>thisCondition (1 byte) - (the index of the condition whose events are handled)</li> </ul> </li> <li>thisState (1 byte) - (the state to go to if a thisCondition event occurs)</li> </ul> </li> </ul> </li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>linkedOutputChannel (1-byte) - index of an output channel in outputDescriptionArray. 255 = no channel linked).</li> </ul> </li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>onMessage (1-byte). This is the index of a message set previously with command 'L' above, to send when the timer starts.</li> </ul> </li> <li>Note: The target module for onMessage is defined by linkedOutputChannel (above), if linkedOutputChannel is a module port.</li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>offMessage (1-byte). This is the index of a message set previously with command 'L' above, to send when the timer starts.</li> </ul> </li> <li>Note: The target module for offMessage is defined by linkedOutputChannel (above), if linkedOutputChannel is a module port.</li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>loopMode (1-byte). Set to 0 (default) if a one-shot timer, 1 to loop the timer until canceled, 2-255 to loop N times</li> </ul> </li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>sendGlobalTimerEvents (1-byte). Set to 1 (default) to generate global timer on and off events. Set to 0 to disable them.</li> </ul> </li> <li>for each global counter between 1 and nGlobalCountersUsed (nGlobalCountersUsed was received earlier in the transmission)<ul> <li>attachedEvent(1-byte). This is the index of a behavior event to count.</li> </ul> </li> <li>for each condition between 1 and nConditionsUsed (nConditionsUsed was received earlier in the transmission)<ul> <li>conditionChannel(1-byte). This is an input channel index in inputDescriptionArray.</li> </ul> </li> <li>for each condition between 1 and nConditionsUsed (nConditionsUsed was received earlier in the transmission)<ul> <li>conditionValue(1-byte). 0 = low, 1 = high. Defines the state of the channel when the condition is true.</li> </ul> </li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>globalCounterReset(1-byte). Defines the index of the global counter to reset in each state.</li> </ul> </li> <li>NOTE: The next section of the state machine description expects a different datatype for several variables, depending on how many global timers are supported by the state machine: byte (if &lt; 9), 16-bit unsigned int (if &lt; 17), 32-bit unsigned int (otherwise, up to 32). This compression allows Bpod firmware to support state machine versions with less internal memory.</li> <li>if nGlobalTimers &lt; 9 Note: nGlobalTimers was received with the state machine hardware description; (see 'H' above).<ul> <li>for each state between 1 and nStates<ul> <li>globalTimerTrig (1-byte). Bits of globalTimerTrig indicate the global timers to trigger in each state</li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>globalTimerCancel (1-byte). Bits of globalTimerTrig indicate the global timers to cancel in each state</li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimerOnsetTriggers (1-byte) Bits of globalTimerOnsetTriggers indicate other global timers to trigger after the current timer's onset delay.</li> </ul> </li> </ul> </li> </ul> </li> <li>else if nGlobalTimers &lt; 17<ul> <li>for each state between 1 and nStates<ul> <li>globalTimerTrig (2-byte; 16-bit unsigned int). Bits of globalTimerTrig indicate the global timers to trigger in each state</li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>globalTimerCancel (2-byte; 16-bit unsigned int). Bits of globalTimerTrig indicate the global timers to cancel in each state</li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimerOnsetTriggers (2-byte; 16-bit unsigned int) Bits of globalTimerOnsetTriggers indicate other global timers to trigger after the current timer's onset delay.</li> </ul> </li> </ul> </li> </ul> </li> <li>else (up to 32 global timers theoretically possible)<ul> <li>for each state between 1 and nStates<ul> <li>globalTimerTrig (2-byte; 32-bit unsigned int). Bits of globalTimerTrig indicate the global timers to trigger in each state</li> </ul> </li> <li>for each state between 1 and nStates<ul> <li>globalTimerCancel (2-byte; 32-bit unsigned int). Bits of globalTimerTrig indicate the global timers to cancel in each state</li> <li>for each global timer between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimerOnsetTriggers (2-byte; 32-bit unsigned int) Bits of globalTimerOnsetTriggers indicate other global timers to trigger after the current timer's onset delay.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>end if</p> <ul> <li>for each state s between 1 and nStates<ul> <li>stateTimer[s] (4 bytes; 32-bit int). This state's internal timer (units = state machine cycles, 1 cycle = timerPeriod returned from 'H' above).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimer[t] (4 bytes; 32-bit int). Duration of global timer t (units = state machine cycles).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimerOnsetDelay[t] (4 bytes; 32-bit int). Onset delay of global timer t (units = state machine cycles).</li> </ul> </li> <li>for each global timer t between 1 and nGlobalTimersUsed (nGlobalTimersUsed was received earlier in the transmission)<ul> <li>globalTimerLoopInterval[t] (4 bytes; 32-bit int). Delay between timer loop iterations (units = state machine cycles).</li> <li>for each global counter between 1 and nGlobalCountersUsed (nGlobalCountersUsed was received earlier in the transmission)</li> <li>globalCounterThreshold[t] (4 bytes; 32-bit int). Threshold (units = instances of the event being counted).</li> <li>NOTE: The state machine will return a confirmation byte to indicate successful transmission of the state machine description, on the next call to RunStateMachine. This saves 1 read/write cycle, and reduces dead-time.</li> </ul> </li> <li>'R' (ASCII 82): Run state machine.<ul> <li>if a new state machine was sent prior to calling 'R'</li> <li>The state machine returns a byte (1) to confirm that it has finished receiving the new state machine.</li> <li>The state machine returns TrialStartTimestamp (8 bytes; 64-bit unsigned int). Time in microseconds since session start</li> <li>While the trial is running, event codes and soft-codes are returned via the USB serial port as follows:</li> </ul> </li> <li>Op-code (byte 1) = 1 if the message is an event, and 2 if the message is a soft code</li> <li>If op-code 1,<ul> <li>nEvents (byte 2) - number of events returned</li> </ul> </li> <li>for each event between 1 and nEvents<ul> <li>Event code (1 byte)</li> <li>if TimestampTransmissionScheme == 1 See command 'G' above; 1 = during trial<ul> <li>Timestamp (4 bytes; 32-bit int) Units = state machine cycles (default=100us)</li> </ul> </li> </ul> </li> <li>If op-code 2,<ul> <li>Soft code (byte 2) = the soft code to pass to the soft code handler function. Exit state: If event code 255 was returned, the state machine has reached an exit state. It then sends the trial's timing data:</li> </ul> </li> <li>nCyclesCompleted (4 bytes; 32-bit integer) - the number of state machine cycles counted during the trial</li> <li>TrialEndTimestamp in microseconds (8 bytes; 64-bit unsigned integer) - time the trial ended in microseconds</li> <li>if TimestampTransmissionScheme == 0 See command 'G' above; 0 = after trial<ul> <li>nTimestamps (2 bytes; 16-bit integer) - the number of timestamps to be transmitted</li> <li>for each timestamp between 1 and nTimestamps:<ul> <li>Timestamp (4 bytes; 32-bit integer) - for each event recorded during the trial, a 32-bit timestamp. Units = 100us state machine cycles following trial start.</li> </ul> </li> </ul> </li> <li>'X' (ASCII 88): Force-exit the currently running state machine, and return the partial trial's data.<ul> <li>No data follows.</li> <li>The state machine then returns the data in same format as for 'R' command above. 'Z' (ASCII 90): Disconnect state machine from the USB serial port.</li> <li>No data follows.</li> <li>This resets several program variables to prepare the state machine for its next connection</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"serial-interfaces/hifi-module-serial-interface/","title":"HiFi Module Serial Interface","text":""},{"location":"serial-interfaces/hifi-module-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to load and play sounds using the Bpod HiFi Module.</p> <p>Requires a Bpod HiFi module with firmware loaded from:</p> <ul> <li>https://github.com/sanworks/Bpod_HiFi_Firmware</li> </ul> <p>The HiFi module must be connected to a module port on the state machine to use the state machine interface.</p>"},{"location":"serial-interfaces/hifi-module-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<p>The state machine command interface consists of bytes sent from the Bpod state machine to the HiFi module to start and stop playback, and control synth.</p> <ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'P' (ASCII 80): Plays a sound.<ul> <li>'P' (byte 0) must be followed by one byte:<ul> <li>Byte 1: The sound to play (zero-indexed).</li> </ul> </li> </ul> </li> <li>'*' (ASCII 42): Push any loaded sounds to current playback buffers.<ul> <li>Note: This op will make any sounds loaded recently current at the loaded positions, replacing any sounds at those positions.<ul> <li>Thus, if new sounds for positions 2 and 3 are loaded during a trial for use on the next trial, sending '*' will make these waveforms the current sounds at positions 2 and 3.</li> </ul> </li> <li>If called from the PC via USB, The HiFi module returns a byte (1) to confirm that it has finished pushing loaded sounds.</li> </ul> </li> <li>'X' (ASCII 88): Stop all playback</li> <li>'x' (ASCII 120): Stop playing a specific sound (if that sound happens to be playing)<ul> <li>'x' (byte 0) must be followed by one byte:<ul> <li>Byte 1: The sound to stop (zero-indexed).</li> </ul> </li> </ul> </li> <li>'N' (ASCII 78): Set Synth Amplitude. 'N' (byte 0) is followed by:<ul> <li>Bytes 1-2: synthAmplitude (16-bit unsigned integer)</li> <li>synthAmplitude must be in range 0-32767 where 0 = no synth, and 32767 = max amplitude (i.e. this is an attenuation factor in bits)</li> <li>If called from the PC via USB, The HiFi module returns a byte (1) to confirm that it has finished setting synth amplitude.</li> </ul> </li> <li>'F' (ASCII 78): Set Synth Frequency. 'F' (byte 0) is followed by:<ul> <li>Bytes 1-4: synthFrequency (32-bit unsigned integer)</li> <li>synthFrequency is the target frequency *1000 (e.g. to set 100Hz, use 100000)</li> <li>synthFrequency is ignored if the current waveform is white noise.</li> <li>If called from the PC via USB, The HiFi module returns a byte (1) to confirm that it has finished setting synth frequency.</li> </ul> </li> <li>'W' (ASCII 78): Set Synth Waveform. 'W' (byte 0) is followed by:<ul> <li>Byte 1: Waveform type. Values are 0: White Noise, 1: Sine</li> <li>If called from the PC via USB, The HiFi module returns a byte (1) to confirm that it has finished setting synth waveform.</li> </ul> </li> </ul>"},{"location":"serial-interfaces/hifi-module-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows configuration of the HiFi module from MATLAB or Python before a trial begins. The BpodHiFi class for Bpod/MATLAB wraps this interface. The first several commands are the same as for the state machine interface, and additional commands follow.</p> <ul> <li>(ASCII 243): Handshake. The module replies with the following sequence of bytes:<ul> <li>handshakeReply (1 byte); Equal to 244</li> </ul> </li> <li>'L' (ASCII 76): Load an audio waveform. 'L' (byte 0) is followed by:<ul> <li>Byte 1: The waveform to load (0-19). Note: In the HiFiModule class, these are corrected for MATLAB's indexing (1-20).</li> <li>Byte 2: isStereo (set to 1 if loading a stereo/2ch waveform, or 0 if mono/1ch). Note: Both speakers play mono waveforms.</li> <li>Bytes 3 - 6: The number of samples in the audio waveform expressed as a 32-bit integer (1-1,000,000).</li> <li>Bytes 7 - (7+((2 + (2*isStereo))*nSamples)): The waveform. Each byte is a 16-bit signed integer coding for an audio sample.</li> <li>The HiFi module returns a byte (1) to confirm that it has finished reading the last sample.</li> </ul> </li> <li>'S' (ASCII 83): Set sampling rate (units = Hz). 'S' (byte 0) is followed by:<ul> <li>Bytes 1-4: Sampling rate in hz (32-bit unsigned integer)</li> <li>Note that only 44100, 48000, 96000 and 192000 are valid sampling rates</li> <li>The HiFi module returns a byte (1) to confirm that it has finished setting the sampling period.</li> </ul> </li> <li>'E' (ASCII 69): Enable AM envelope. 'E' (byte 0) is followed by:<ul> <li>Byte 1: UseAMEnvelope: 1 if using AM envelope, 0 if not.</li> <li>The HiFi module returns a byte (1) to confirm that it has finished setting the AM envelope.</li> </ul> </li> <li>'M' (ASCII 77): Load AM envelope. 'M' (byte 0) is followed by:<ul> <li>Bytes 1-2: EnvelopeSize (16-bit unsigned int): The number of samples in the envelope</li> <li>Bytes 3-(3+EnvelopeSize*4): samples of the 16-bit AM envelope. These are 4-byte floats (attenuating factors) in range [0 to 1].</li> <li>The HiFi module returns a byte (1) to confirm that it has finished storing the AM envelope.</li> </ul> </li> <li>'O' (ASCII 79): Set loop mode for a waveform. 'O' (byte 0) is followed by:<ul> <li>Bytes 1-20: Loop mode bytes. Each byte represents a waveform: 1 if using loop mode, 0 if not.</li> <li>The HiFi module returns a byte (1) to confirm that it has finished setting the loop mode.</li> </ul> </li> <li>'-' (ASCII 45): Set duration for looping playback on a single trigger. '-' (byte 0) is followed by:<ul> <li>Bytes 1-21: Duration of looped playback on trigger for each waveform (expressed in samples) as a 32-bit integer.<ul> <li>Note: Because loop duration is expressed in samples, it must be re-loaded following sampling rate changes (see op above, 'S')</li> </ul> </li> <li>The HiFi module returns a byte (1) to confirm that it has finished setting the loop duration.</li> </ul> </li> <li>'A' (ASCII 65): Set digital attenuation. 'A' (byte 0) is followed by:<ul> <li>Byte 1: Digital attenuation. Valid values are in range 0-240</li> <li>The HiFi module returns a byte (1) to confirm that it has finished setting the digital attenuation.</li> </ul> </li> <li>'I' (ASCII 78): Return system info. Nothing follows byte 'I'. The module replies with the following sequence of bytes:<ul> <li>isHD(1 byte); Corresponds to HiFiBerry DAC board (0 = DAC2 Pro, 1 = DAC2 HD)</li> <li>bitDepth (1 byte); Bit depth of audio samples. Possible values are 16 or 24 (current firmware supports 16 bit only)</li> <li>maxWaves (1 byte); Maximum number of waveforms that can be loaded</li> <li>digitalAttenuation (1 byte); Digital attenuation. dB = digitalAttenuation*-0.5</li> <li>samplingRate (4 bytes; 32-bit int); Current sampling rate in Hz</li> <li>maxSecondsPerWaveform (4 bytes; 32-bit int); Maximum number of seconds that can be stored for a 192kHz stereo waveform</li> <li>maxEnvelopeSize (4 bytes; 32-bit int); Maximum number of samples in the configurable onset/offset AM envelope</li> </ul> </li> </ul>"},{"location":"serial-interfaces/hifi-module-serial-interface/#examples","title":"Examples","text":"<p>Play sound #4 using an ArCOM serial object in MATLAB:</p> <pre><code>D = ArCOMObject('COM3', 115200);\nD.write(['P' 3], 'uint8'); % Remember that sound position is 0-indexed!\nclear D\n</code></pre> <p>Trigger sound #4 from the Bpod state machine <pre><code>LoadSerialMessages('HiFi1', {['P' 3]}); % Set serial message 1\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'PlaySound', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'HiFi1', 1}); % Sends serial message 1\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\n</code></pre></p>"},{"location":"serial-interfaces/port-array-module-serial-interface/","title":"Port Array Module Serial Interface","text":""},{"location":"serial-interfaces/port-array-module-serial-interface/#description","title":"Description","text":"<p>Allows the state machine to open valves, set LED brightness and read poke events from ports on the Bpod port array module.</p> <p>Requires a port array module board with firmware loaded from:</p> <ul> <li>https://github.com/sanworks/Bpod_PortArray_Firmware</li> </ul> <p>To use the state machine interface, the port array module must be connected to a free serial port on the Bpod state machine.</p>"},{"location":"serial-interfaces/port-array-module-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<p>The state machine command interface consists of bytes sent from the Bpod state machine to the port array module to open and close valves, and set LED brightness.</p> <ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'V' (ASCII 86): Set the state of a valve.<ul> <li>Following 'V', the module expects 2 bytes:<ul> <li>port# (1 byte; range = 0-3)</li> <li>state (1 byte; range = 0-1) Note: 0 = closed, 1 = open</li> </ul> </li> </ul> </li> <li>'B' (ASCII 66): Set the state of all valves at once, using bits of a byte<ul> <li>Following 'B', the module expects 1 byte:<ul> <li>valveState (1 byte; range = 0-15) Note: 0 = all cosed, 15 = all open</li> </ul> </li> </ul> </li> <li>'P' (ASCII 80): Set port LED intensity (pulse width modulated).<ul> <li>Following 'P', the module expects 2 bytes:<ul> <li>port# (1 byte; range = 0-3)</li> <li>duty cycle (1 byte; range = 0-255) Note: 0 = off, 255 = max brightness</li> </ul> </li> </ul> </li> <li>'W' (ASCII 87): Set all port LED intensities<ul> <li>Following 'W', the module expects 4 bytes:<ul> <li>duty cycles of ports 1-4 (4 bytes; range = 0-255) Note: 0 = off, 255 = max brightness</li> </ul> </li> </ul> </li> <li>'L' (ASCII 76): Set all port LEDs at once, using bits of a byte to indicate (0 = off) or (1 = max brightness)<ul> <li>Following 'L', the module expects 1 byte:<ul> <li>ledState (1 byte; range = 0-15) Note: 0 = all off, 15 = all on</li> </ul> </li> </ul> </li> <li>'R' (ASCII 82): Reset clock.<ul> <li>The clock is used to return timestamps when streaming poke events directly over USB. When used with the state machine, the state machine clock timestamps all incoming events.</li> </ul> </li> </ul>"},{"location":"serial-interfaces/port-array-module-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows the port array module to receive commands and return events directly to MATLAB. The PortArrayModule plugin for Bpod/MATLAB wraps this interface. The first 6 commands are the same as for the state machine interface (though an acknowledgement byte = 1 is returned for ops B and W), and additional commands follow:</p> <ul> <li>'S' (ASCII 83): Return the current state of all ports. The module replies with the following bytes:<ul> <li>State (4 bytes) = for each port, 0 if port is open, 1 if port is bocked</li> </ul> </li> <li>'U' (ASCII 85): Start/Stop event stream. 'U' (byte 0) is followed by:<ul> <li>Byte 1: 0 to stop event stream, 1 to start</li> <li>while streaming, the module returns the following bytes for each port-in or port-out event:<ul> <li>currentTime (8 bytes; 64-bit unsigned int, units = microseconds)</li> <li>eventCode (4 bytes, one for each port)<ul> <li>0 = no event 1 = Port1In, 2 = Port1Out, 3 = Port2In,... 8 = Port4Out</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"serial-interfaces/rotary-encoder-module-serial-interface/","title":"Rotary Encoder Serial Interface","text":""},{"location":"serial-interfaces/rotary-encoder-module-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to log rotary motion and detect threshold crossings using the rotary encoder module. Requires a rotary encoder module board with firmware loaded from: https://github.com/sanworks/Bpod_RotaryEncoder_Firmware</p> <p>The Rotary Encoder Module must be connected to a free serial port on the Bpod state machine.</p> <p>Important</p> <p>There are two versions of the Rotary Encoder Module with non-overlapping feature sets. Both modules are controlled by the <code>RotaryEncoderModule</code> class. Functions specific to each version are indicated with:</p> <ul> <li> <p>Module v1 only: </p> </li> <li> <p>Module v2 only: </p> </li> </ul>"},{"location":"serial-interfaces/rotary-encoder-module-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'L' (ASCII 76): Start logging position+time data to the microSD card. <ul> <li>Resets logging position to 0, overwriting previously logged data.</li> </ul> </li> <li>'F' (ASCII 70): Finish logging position+time data to the microSD card. <ul> <li>Stops logging data. A call to 'R' (see below) must be made to return data to the PC before the next call to 'L'.</li> </ul> </li> <li>'Z' (ASCII 90): Set current rotary encoder position to zero. </li> <li>'E' (ASCII 69): Enable all position thresholds.<ul> <li>Position thresholds are disabled individually once they are crossed, generating a behavior event. Call 'E' to re-enable all of them.</li> </ul> </li> <li>'O' (ASCII 79): Start / Stop module output stream.<ul> <li>Following 'O', the module expects 1 byte:<ul> <li>1 to start the module stream</li> <li>0 to stop the module stream</li> </ul> </li> </ul> </li> <li>'#' (ASCII 35): Timestamp a byte-message and return via ongoing USB stream. (Note: Req. Firmware v2)<ul> <li>Following '#', the module expects 1 byte:<ul> <li>a message (0-255)</li> </ul> </li> </ul> </li> <li>'*' (ASCII 42): 'Push' command. If advanced thresholds were loaded to the device with 't' command (below), make them the current thresholds.</li> <li>'X' (ASCII 88): Stops streaming + logging.</li> </ul>"},{"location":"serial-interfaces/rotary-encoder-module-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows configuration of the rotary encoder module with MATLAB or Python before a trial begins. It also allows data return from the module's onboard microSD card. The <code>RotaryEncoderModule</code> class/plugin for Bpod/MATLAB wraps this interface. The first 6 commands are the same as for the state machine interface (though an acknowledgement byte = 1 is returned in each case), and additional commands follow.</p> <ul> <li>'R' (ASCII 82): Retrieve captured position data from the module's microSD card. The module replies with the following bytes:<ul> <li>nPositionsAcquired (4 bytes; 32-bit int); number of samples acquired since last call to 'L' (see above)</li> <li>for (each position)<ul> <li>a position (2 bytes; 16-bit signed int)</li> <li>a timestamp (4 bytes; 32-bit unsigned int)</li> </ul> </li> <li>Positions are signed integers in units of rotary encoder tics (1024 = 1 full rotation)</li> <li>Times are given in milliseconds</li> <li>If no data is available, 0 is returned for nPositionsAcquired.</li> </ul> </li> <li>'Q' (ASCII 81): Return the encoder's current position. The module replies with the following bytes:<ul> <li>currentPosition (2 bytes; 16-bit signed int);</li> <li>units = rotary encoder tics (1024 / full rotation)</li> </ul> </li> <li>'P' (ASCII 80): Set current rotary encoder position. 'P' (byte 0) is followed by:<ul> <li>Bytes 1-2: a 16-bit signed integer indicating the new position.<ul> <li>units = rotary encoder tics (1024 / full rotation).</li> <li>Negative values are permitted, but their absolute value must not exceed wrapPoint (see 'W' below).</li> </ul> </li> <li>The rotary encoder module returns a byte (1) to confirm that it has finished setting the current position.</li> </ul> </li> <li>'S' (ASCII 83): Start/Stop streaming position and time measurements to the USB port. 'S' (byte 0) is followed by:<ul> <li>streamingEnabled (1 byte): 0 to stop USB streaming, 1 to start USB streaming. Also see '#' command above.</li> <li>If enabled, bytes arrive at the USB serial port as follows:</li> <li>while (streamingEnabled)<ul> <li>---For firmware v1:---<ul> <li>for (each new position)<ul> <li>currentPosition (2 bytes; 16-bit signed int; units = rotary encoder tics (1024 / full rotation)</li> <li>currentTime (4 bytes; 32-bit unsigned int; units = ms)</li> </ul> </li> </ul> </li> <li>---For firmware v2:---<ul> <li>whichData (1 byte):<ul> <li>'P' (ASCII 80) if position data follows</li> <li>'E' (ASCII 69) if event data follows</li> </ul> </li> <li>IF 'P' was received (position data):<ul> <li>nPositions (1 byte): number of positions to read</li> <li>FOR each position in nPositions         - currentPosition (2 bytes; 16-bit signed int; units = rotary encoder tics (1024 / full rotation)         - currentTime (4 bytes; 32-bit unsigned int; units = ms)</li> </ul> </li> <li>IF 'E' was received (event data):         - eventOrigin (1 byte): 0 if from state machine, 1-3 reserved for events from TTL and I2C         - eventCode (1 byte): For state machine events, the \"event\" byte that followed '#' (above)             - currentTime (4 bytes; 32-bit unsigned int; units = ms)</li> </ul> </li> <li>---For firmware v3 or newer:---<ul> <li>whichData (1 byte):<ul> <li>'P' (ASCII 80) if position data follows</li> <li>'E' (ASCII 69) if event data follows</li> </ul> </li> <li>IF 'P' was received (position data):<ul> <li>currentPosition (2 bytes; 16-bit signed int; units = rotary encoder tics (1024 / full rotation)</li> <li>currentTime (4 bytes; 32-bit unsigned int; units = ms)</li> </ul> </li> </ul> </li> <li>IF 'E' was received (event data):         - eventOrigin (1 byte): 0 if from state machine, 1-3 reserved for events from TTL and I2C         - eventCode (1 byte): For state machine events, the \"event\" byte that followed '#' (above)         - currentTime (4 bytes; 32-bit unsigned int; units = ms)</li> </ul> </li> </ul> </li> <li>'V' (ASCII 86): Enable/Disable event transmission to state machine. 'V' (byte 0) is followed by:<ul> <li>eventsEnabled (1 byte): 0 to disable sending threshold events, 1 to enable.</li> <li>The rotary encoder module returns a byte (1) to confirm that it has finished enabling/disabling events.</li> </ul> </li> <li>'T' (ASCII 84): Program position thresholds (used to generate behavior events). 'T' (byte 0) is followed by:<ul> <li>nThresholds (1 byte): number of thresholds to use. This must be less than maxThresholds (defined in firmware)</li> <li>for (each threshold between 0 and nThresholds)<ul> <li>threshold (16-bit signed integer; units = rotary encoder tics (1024 / full rotation))</li> <li>The absolute value of all thresholds must be less than wrap point (see 'W' below)</li> <li>The rotary encoder module returns a byte (1) to confirm that it has finished programming the list of thresholds.</li> </ul> </li> </ul> </li> <li>'t' (ASCII 116): Program 'advanced' position thresholds. Advanced thresholds are not made current when loaded to the device, until the device receives a * command (see above). Threshold type can be type 0 (position threshold) or type 1 (threshold reached by remaining within position range for a set amount of time). 't' (byte 0) is followed by:<ul> <li>nThresholds (1 byte): number of thresholds to program</li> <li>for (each threshold between 0 and nThresholds)<ul> <li>thresholdType (1 byte): Either 0 (position threshold) or 1 (time within range)</li> </ul> </li> <li>for (each threshold between 0 and nThresholds)<ul> <li>threshold (16-bit signed integer): Position threshold. If thresholdType == 1, this is the range boundary (+/- with respect to position 0)</li> </ul> </li> <li>for (each threshold between 0 and nThresholds)<ul> <li>thresholdTimes (32-bit unsigned integer): Time for thresholdType1 (unit = increments of 100 microseconds)</li> </ul> </li> </ul> </li> <li>'W' (ASCII 87): Set wrap point (number of tics in a half-rotation). 'W' (byte 0) is followed by:<ul> <li>Bytes 1-2: a 16-bit signed integer indicating the wrapPoint.<ul> <li>units = rotary encoder tics (512 / half rotation).<ul> <li>wrapPoint is the point at which the lowest permissible negative position is wrapped to the highest permissible positive position.<ul> <li>At 512 (default), position wraps from -512 to +512 (for a total of 1024 tics per rotation).</li> <li>At 1024, two full rotations are required in either direction to wrap the current position (i.e. positions between -1024 and +1024 are permissible).</li> <li>wrapPoint can be used to allow thresholds more distant than 1 rotation away from the start point (position 0).</li> </ul> </li> </ul> </li> </ul> </li> <li>The rotary encoder module returns a byte (1) to confirm that it has finished setting the wrapPoint.</li> </ul> </li> <li>'I' (ASCII 73): Set 1-character prefix for module output stream. 'I' (byte 0) is followed by:<ul> <li>prefix (1 byte): a prefix-byte sent before each 16-bit position in the output data stream<ul> <li>The prefix should match the data format expected by the receiving module</li> <li>The rotary encoder module returns a byte (1) to confirm that it has finished setting the prefix.</li> </ul> </li> </ul> </li> <li>';' (ASCII 59): Enable / disable specific event thresholds. ';' (byte 0) is followed by:<ul> <li>1 byte whose bits indicate whether each threshold up to nThresholds is enabled (1) or disabled (0) (for nThresholds, see 'T' command)</li> </ul> </li> </ul>"},{"location":"serial-interfaces/valve-module-serial-interface/","title":"Valve Module Serial Interface","text":""},{"location":"serial-interfaces/valve-module-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to control 8 solenoid valves, using the Bpod Valve Driver Module.</p> <p>Requires a valve module board with firmware loaded from:</p> <ul> <li>https://github.com/sanworks/Bpod_ValveDriver_Firmware</li> </ul> <p>The valve module board must be connected to a serial port on the state machine module.</p>"},{"location":"serial-interfaces/valve-module-serial-interface/#command-interface","title":"Command Interface","text":"<ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'O' (Byte 79): Opens a valve.<ul> <li>'O' must be followed by:<ul> <li>A valve number (1-8) OR</li> <li>The ASCII character of a valve number ('1' - '8') = (49 - 56)</li> </ul> </li> </ul> </li> <li>'C' (Byte 67): Closes a valve<ul> <li>'C' must be followed by:<ul> <li>A valve number (1-8) OR<ul> <li>The ASCII character of a valve number ('1' - '8') = (49 - 56)</li> </ul> </li> </ul> </li> </ul> </li> <li>'B' (Byte 66): Sets the state of multiple valves<ul> <li>'B' must be followed by a byte. The 8 bits of the byte indicate valve states, for instance:<ul> <li>1 = binary 00000001: valve 1 open, all others closed</li> <li>22 = binary 00010110: valves 2, 3 and 5 open, all others closed</li> </ul> </li> </ul> </li> <li>All other bytes: Toggles state of valve<ul> <li>If byte 1-8, toggles state of valve 1-8</li> <li>If ASCII character of '1' to '8' (49-56), toggles state of numeric equivalent valve (1-8)</li> </ul> </li> </ul>"},{"location":"serial-interfaces/valve-module-serial-interface/#examples","title":"Examples","text":"<p>Open and close valve 2 from the Arduino Serial Terminal:</p> <p>At the terminal, type 'O2', then 'C2'</p> <p>Open and close valve 2 from an ArCOM serial object in MATLAB: <pre><code>D = ArCOMObject('COM43', 115200);\nD.write('O2', 'uint8');\nD.write('C2', 'uint8');\nclear D\n</code></pre></p> <p>Open and close valve 2 from the Bpod state machine <pre><code>LoadSerialMessages('ValveModule1', {['O' 2], ['C' 2]}); % Set serial messages 1 and 2\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'OpenValve', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'CloseValve'},...\n'OutputActions', {'ValveModule1', 1}); % Sends serial message 1\nsma = AddState(sma, 'Name', 'CloseValve', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'end'},...\n'OutputActions', {'ValveModule1', 2}); % Sends serial message 2\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\n</code></pre></p> <p>This code is a loop that runs 8 times. On each iteration, it creates and runs a state machine with 2 states. The 2 states use the \"toggle\" op codes to open and close a valve. This code assumes all valves are initially closed.</p> <pre><code>for i = 1:8\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'OpenValve', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'CloseValve'},...\n'OutputActions', {'ValveModule1', i}); % Toggle valve i Open\nsma = AddState(sma, 'Name', 'CloseValve', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'end'},...\n'OutputActions', {'ValveModule1', i}); % Toggle valve i Closed\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\nend\n</code></pre>"},{"location":"serial-interfaces/waveplayer-serial-interface/","title":"WavePlayer Serial Interface","text":""},{"location":"serial-interfaces/waveplayer-serial-interface/#description","title":"Description","text":"<p>Allows the state machine or PC to play analog waveforms using the analog output module.</p> <p>Requires a 4-channel analog output module board with firmware loaded from: - https://github.com/sanworks/Bpod_AnalogOutput_Firmware/tree/master/AnalogOutputModule_4ch/BpodWavePlayer</p> <p>OR, an 8-channel analog output module board with firmware loaded from: - https://github.com/sanworks/Bpod_AnalogOutput_Firmware/tree/master/AnalogOutputModule_8ch/BpodWavePlayer</p> <p>The analog output module must be connected to a serial port on the state machine module.</p>"},{"location":"serial-interfaces/waveplayer-serial-interface/#state-machine-command-interface","title":"State Machine Command Interface","text":"<p>The state machine command interface consists of bytes sent from the Bpod state machine to the WavePlayer module to start and stop playback.</p> <ul> <li>Byte 255 (reserved): Returns module info to state machine</li> <li>'P' (ASCII 80): Plays a waveform.<ul> <li>In standard trigger mode (default), 'P' (byte 0) must be followed by two bytes:<ul> <li>Byte 1: A byte whose bits indicate which channels to trigger (i.e. byte 5 = bits: 101 = channels 1 and 3).</li> <li>Byte 2: A byte indicating the waveform to play on the channels specified by Byte 1. NOTE: This byte uses 0-indexing.</li> </ul> </li> <li>In trigger profile mode, 'P' (byte 0) must be followed by 1 byte:<ul> <li>Byte 1: The trigger profile to play (1-64)</li> </ul> </li> </ul> </li> <li>'&gt;' (ASCII 62): Plays a list of waveforms specified for each channel<ul> <li>REQUIRES FIRMWARE v5 OR NEWER</li> <li>'&gt;' (byte 0) must be followed by one byte for each output channel on the device.<ul> <li>Byte 1: A byte indicating the waveform to trigger on channel 1. Use 255 for no waveform.</li> <li>...</li> <li>Byte 4: A byte indicating the waveform to trigger on channel 4.</li> <li>NOTE: The waveform bytes use 0-indexing, so if you loaded a waveform to the device in MATLAB with W.loadWaveform(Wave, 1), the wave is known to WavePlayer's Arduino firmware as wave 0.</li> </ul> </li> <li>A byte must be specified for every physical output channel. Use 255 for 'no waveform'.</li> <li>On State Machine r2 or newer with firmware v23, the '&gt;' op can be output from a single state for the 4-channel module as 5 bytes are available per serial message. Earlier machines, or state machine r2 with earlier firmware have only 3 bytes per serial message, so the 5 bytes for the '&gt;' op must be broken across states. Consider using Trigger Profile mode in this case to save 100\u00b5s of latency.</li> </ul> </li> <li>'!' (ASCII 33): Sets a fixed voltage on a subset of channels.<ul> <li>REQUIRES FIRMWARE v5 OR NEWER</li> <li>'!' (Byte 0) must be followed by:<ul> <li>Byte 1: Bits of channels to set (e.g. 3 = 00000011, to set channels 1 and 2)</li> <li>Bytes 2-3: 16-bit value encoding the voltage.</li> <li>If sent from the PC, the module returns an acknowledgement byte (1)</li> </ul> </li> </ul> </li> <li>'X' (ASCII 88): Stop all playback</li> </ul>"},{"location":"serial-interfaces/waveplayer-serial-interface/#serialusb-command-interface","title":"SerialUSB Command Interface","text":"<p>The SerialUSB command interface allows configuration of the WavePlayer module from MATLAB or Python before a trial begins. The WavePlayer plugin for Bpod/MATLAB wraps this interface. The first two commands are the same as for the state machine interface, and additional commands follow.</p> <ul> <li>'P' (ASCII 80): Plays a waveform.<ul> <li>In standard trigger mode (default), 'P' (byte 0) must be followed by two bytes:<ul> <li>Byte 1: A byte whose bits indicate which channels to trigger (i.e. byte 5 = bits: 101 = channels 1 and 3).</li> <li>Byte 2: A byte indicating the waveform to play on the channels specified by Byte 1 (zero-indexed).</li> </ul> </li> <li>In trigger profile mode, 'P' (byte 0) must be followed by 1 byte:<ul> <li>Byte 1: The trigger profile to play (1-64)</li> </ul> </li> </ul> </li> <li>'X' (ASCII 88): Stop all playback.</li> <li>'L' (ASCII 76): Load a waveform. 'L' (byte 0) is followed by:<ul> <li>Byte 1: The waveform to load (0-63). Note: In the WavePlayer plugin, these are corrected for MATLAB's indexing (1-64).</li> <li>Bytes 2 - 5: The number of samples in the waveform expressed as a 32-bit integer (1-1,000,000).</li> <li>Bytes 6 - (6+(2*nSamples)): The waveform. Each byte is a 16-bit integer coding for a voltage in the currently selected output range.</li> <li>The WavePlayer module returns a byte (1) to confirm that it has finished reading the last sample.</li> </ul> </li> <li>'R' (ASCII 82): Set the output range (default = +/-5V). 'R' (byte 0) is followed by:<ul> <li>Byte 1: The range index. Range indexes are:<ul> <li>0: 0V to +5V</li> <li>1: 0V to +10V</li> <li>2: 0V to +12V</li> <li>3: -5V to +5V</li> <li>4: -10V to +10V</li> <li>5: -12V to +12V</li> </ul> </li> <li>The WavePlayer module returns a byte (1) to confirm that it has finished setting the range.</li> <li>NOTE: The waveforms are stored on the device in bits. The bits are computed for the current range. When you change the output range of the device, the waveforms already loaded will be compressed or expanded in amplitude. The WavePlayer plugin (MATLAB) re-loads every waveform on the device, following a range update, to enforce accurate playback of the waveform voltages.</li> </ul> </li> <li>'S' (ASCII 83): Set the sampling period (units = microseconds, default = 100; sampling rate = 10kHz). 'S' (byte 0) is followed by:<ul> <li>Bytes 1-4: Sampling period in microseconds (32-bit integer)</li> <li>The WavePlayer plugin (MATLAB) exposes sampling rate to the user, and computes sampling period before transmitting.</li> <li>If Loop mode is active, loop durations will be scaled with the sampling period as they are expressed in samples internally. They will need to be re-computed and re-transmitted (see next op, 'O')</li> </ul> </li> <li>'O' (ASCII 79): Set loop mode and loop duration. 'O' (byte 0) is followed by:<ul> <li>Bytes 1-4 (or 1-8 for 8-channel module): Loop mode bytes. Each byte represents a channel: 1 if using loop mode, 0 if not.</li> <li>Bytes 5-21 (or 9-41): Duration of looped playback on trigger for each channel (expressed in samples) as a 32-bit integer.<ul> <li>Note: Because loop duration is expressed in samples, it must be re-loaded following sampling rate changes (see op above, 'S')</li> </ul> </li> </ul> </li> <li>'V' (ASCII 86): Set Bpod state machine event reporting. 'V' (byte 0) is followed by:<ul> <li>Bytes 1-4 (or 1-8 for 8-channel module): Each byte represents a channel. 1 to report the channel's events, 0 if not.</li> <li>Events are returned as bits to indicate each channel's playback start OR stop:<ul> <li>If channel 1 started (or stopped) playback on the current cycle, a byte (1) is returned to the state machine.</li> <li>If channels 1 and 3 started (or stopped) playback simultaneously, (5) is returned since channels 1 and 3 in binary = 1 0 1 = 5.</li> </ul> </li> </ul> </li> <li>'T' (ASCII 84): Set trigger mode. 'T' (byte 0) is followed by:<ul> <li>Byte 1: The trigger mode index:<ul> <li>0 = Standard mode ('P' command is followed by channel bits and waveform ID)</li> <li>1 = Trigger profile mode ('P' command is followed by a profile index uploaded previously with 'F' command (below)).</li> <li>A trigger profile specifies which waveforms to play on which channels.</li> </ul> </li> </ul> </li> <li>'F' (ASCII 70): Load trigger profile. 'F' (byte 0) is followed by:<ul> <li>Bytes 1-64: The waveform (1-64) OR 255 (no waveform) to play on channel 1 for each of 64 trigger profiles.</li> <li>Bytes 65:(65+(64*nChannels)): The waveform to play for each profile on channels 2:nChannels</li> </ul> </li> <li>'N' (ASCII 78): Retrieve current parameters. Nothing follows byte 'N'. The module replies with the following sequence of bytes:<ul> <li>nChannels (1 byte); number of output channels</li> <li>maxWaves (2 bytes; 16-bit int); maximum number of waveforms supported</li> <li>triggerMode (1 byte); current trigger mode (see 'T' above)</li> <li>triggerProfileEnable (1 byte); 0 = standard trigger mode, 1 = trigger profile mode</li> <li>maxTriggerProfiles (1 byte); maximum number of trigger profiles supported</li> <li>rangeIndex (1 byte); index of the currently selected range (see 'R' above)</li> <li>timerPeriod (4 bytes; 32-bit int); sampling period (in microseconds)</li> <li>sendBpodEvents (1 byte per channel); 0 = off, 1 = bpod event reporting (see 'V' above)</li> <li>loopMode (1 byte per channel) 0 = off, 1 = on (see 'O' above)</li> <li>loop duration (4 bytes per channel; 32-bit ints) duration of loop playback in samples (see 'O' above)</li> </ul> </li> <li>'H' (ASCII 72): Load hardware information. REQUIRES FIRMWARE v5 OR NEWER. 'H' (byte 0) is followed by:<ul> <li>hardwareVersion (1 byte); The major hardware version number</li> <li>circuitVersion (1 byte): The circuit board revision number</li> </ul> </li> </ul>"},{"location":"serial-interfaces/waveplayer-serial-interface/#examples","title":"Examples","text":"<p>Play waveform# 4 on output channel 1 from an ArCOM serial object in MATLAB:</p> <pre><code>D = ArCOMObject('COM43', 115200);\nD.write(['P' 1 3], 'uint8');\nclear D\n</code></pre> <p>Play waveform# 4 on output channel 1 from the Bpod state machine:</p> <pre><code>LoadSerialMessages('WavePlayer1', {['P' 1 3]});  % Set serial message 1\nsma = NewStateMachine();\nsma = AddState(sma, 'Name', 'PlaySound', ...\n'Timer', 0.1,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {'WavePlayer1', 1}); % Sends serial message 1\nSendStateMachine(sma);\nRawEvents = RunStateMachine;\n</code></pre>"},{"location":"user-guide/","title":"General concepts","text":""},{"location":"user-guide/#state-matrix","title":"State matrix","text":""},{"location":"user-guide/#whats-that","title":"What's that?","text":"<p>Each Bpod trial is programmed as a virtual finite state machine. This ensures precise timing of events - for any state machine you program, state transitions will be completed in less than 100 microseconds - so inefficient coding won't reduce the precision of events in your data.</p>"},{"location":"user-guide/#introduction-to-the-bpod-state-machine","title":"Introduction to the Bpod state machine","text":"<ul> <li>Each state describes Bpod's outputs (Valves, LEDs, BNC channels, wire terminals, serial ports, etc.).</li> <li>Events detected by Bpod's inputs can be set to trigger transitions between specific states.</li> </ul> <p>Here is a simple finite state machine, describing a binary switch that controls a bulb with variable brightness:</p> <pre><code>stateDiagram\ndirection LR\nonstate: On state\\nBrightness 100\noffstate: On state\\nBrightness 0\nonstate --&gt; offstate: Switched on\noffstate --&gt; onstate: Switched off</code></pre> <ul> <li>Each state contains a name (\"On state\" or \"Off state\"), a hardware description (\"Brightness: X\"), and transition events (\"Switched on/off\")</li> </ul> <p>Here is the same diagram presented as a state matrix, written in proper syntax for Bpod:</p> <pre><code>sma = NewStateMatrix();         % Initializes a new, empty state \n% matrix, and assigns it to the variable \"sma\".\nsma = AddState(sma, 'Name', 'OnState', ...  % Adds a new state called \"OnState\" \n% to the matrix. \n'Timer', 0,...                          % Sets the internal timer of \n% \"On state\" to 0 seconds. \n'StateChangeConditions', {'Port1In', 'OffState'},...  % Causes a transition \n% to \"Off state\" (not yet defined) if a \"Port1In\" event occurs. \n'OutputActions', {'PWM1', 255});           % Outputs for \"On state\". PWM1 is\n% Port 1's PWM channel, value set to max LED brightness \n% (range = 0-255). \nsma = AddState(sma, 'Name', 'OffState', ... % Adds a state called \"Off state\". \n% PWM1 = 0, \"Port1Out\" returns to\n% first state. \n'Timer', 0,...\n'StateChangeConditions', {'Port1Out', 'OnState'},...\n'OutputActions', {'PWM1', 0});\n</code></pre>"},{"location":"user-guide/#bpod-console","title":"Bpod Console","text":"<p>Information on using the Bpod Console can be found here.</p>"},{"location":"user-guide/advanced-user-guide/","title":"Advanced user guide","text":""},{"location":"user-guide/advanced-user-guide/#navigating-bpod_gen2-repository","title":"Navigating Bpod_Gen2 repository","text":"<p>The Bpod_Gen2 repository contains all of that MATLAB code required to run Bpod.  The Sanworks repository list has other items such as firmware and CAD files.</p> <pre><code>Analysis/                       # Currently doesn't contain much\nAssets/                         # Images/items for graphical display\nExamples/ \n    Example Calibration Files/  # Liquid &amp; sound calibration .mat files\n    Example Settings Files/     # Settings structure .mat files\n    Firmware/                   # Arduino firmware\n    Protocols/                  # Entire protocols\n    State Machines/             # State machine construction snippets\nFunctions/\n    ...\n    Modules/                    # Class files for modules\n    Plugins/                    # Functions like BpodParameterGUI\n</code></pre>"},{"location":"user-guide/advanced-user-guide/#end-of-session-performance-summaries","title":"End-of-session performance summaries","text":"<p>Rodent behavior often takes places in the context of multiple sessions and days of training. At the conclusion of a session, it is possible to generate a summary of both the current session, but also performance across multiple sessions.</p> <pre><code>% retrieve current file's path\n[behaviour_folder, sessiondata_filename] = fileparts(BpodSystem.Path.CurrentDataFile);\nsession_history = struct;\nsessiondatas = dir(fullfile(behaviour_folder, '*.mat'));\nfor file = 1:numel(sessiondatas)\nSessionData = load(fullfile(sessiondatas(file).folder, sessiondatas(file).name), 'SessionData');\nif SessionData.nTrials &lt; 50  % there would be multiple exclusion criteria\ncontinue  % skip this session\nend\n% append relevant parameters into a data structure\nsession_history(end+1).name = sessiondatas(file).name;\nsession_history(end) = calculate_parameters(SessionData);;\nend\nplot_session_parameters(session_history)\n</code></pre>"},{"location":"user-guide/advanced-user-guide/#dead-time","title":"Dead time","text":"<p>\"Dead time\" is the time between the state machine exiting its final state and a new state beginning.</p> <p>The three main sources of dead-time are: - <code>SaveBpodData</code> slowing down because of increased size of <code>BpodSystem.Data</code> - Update of plots becoming inefficient - Calculations involving trial parameters growing in size</p>"},{"location":"user-guide/advanced-user-guide/#measuring-dead-time","title":"Measuring dead time","text":"<p>The <code>tic</code> and <code>toc</code> functions in MATLAB provide a easy way of measuring time between two lines of code.</p>"},{"location":"user-guide/advanced-user-guide/#addressing-dead-time","title":"Addressing dead time","text":"<p>If <code>SaveBpodData</code> is taking a long time, then data saves could be performed every n trials using a modulo (e.g.<code>if mod(currentTrial, n) == 0</code>).</p> <p>Updating a plot after each trial without causing unnecessary usage of computing power requires some knowledge of axes objects. If your plot involves the usage of <code>hold on</code>, it is possible that the plotting process will slow down due to overlaying of multiple versions of the same plot (if your plotting code does so). Similarly, erasing and then recalculating the entire plot could also cost some time. Instead, updating the existing plot with new data points is the fastest method.</p> <p>Calculation of trial parameters should be straight forward, but errors/inefficiently written code may result in longer-than-necessary time to compute new trial parameters.</p>"},{"location":"user-guide/advanced-user-guide/#bpodtrialmanager-vs-runstatemachine","title":"<code>BpodTrialManager</code> vs <code>RunStateMachine</code>","text":"<p>To address this users could use <code>BpodTrialManager</code> instead of the <code>RunStateMachine</code> approach. In short, the difference is that <code>RunStateMachine</code> result in MATLAB being unable to operate while the state machine is active, while <code>BpodTrialManager</code> does not. However, <code>BpodTrialManager</code> is slightly more complex and requires more careful construction of the trial loop.</p> <p>The difference in terms of hanging states of MATLAB are shown in the sequence diagrams below:</p> <pre><code>---\ntitle : Using RunStateMachine\n---\nsequenceDiagram\n    loop\n\u00a0 \u00a0 MATLAB-&gt;&gt;MATLAB: create sma\n\n\u00a0 \u00a0 MATLAB-&gt;&gt;StateMachine: SendStateMachine(sma)\n\n\u00a0 \u00a0 MATLAB-&gt;&gt;StateMachine: RunStateMachine()\n\n\u00a0 \u00a0 activate StateMachine\n\n\u00a0 \u00a0 Note over MATLAB: Hanging\n\n\u00a0 \u00a0 StateMachine-&gt;&gt;MATLAB: return RawEvents\n\n\u00a0 \u00a0 deactivate StateMachine\n\n\u00a0 \u00a0 MATLAB-&gt;&gt;MATLAB: metrics, plots, saving\n\u00a0 \u00a0 end</code></pre> <pre><code>---\ntitle : Using BpodTrialManager\n---\nsequenceDiagram\n\n\u00a0 \u00a0 MATLAB-&gt;&gt;MATLAB : create sma\n\n\u00a0 \u00a0 MATLAB-&gt;&gt;StateMachine : TrialManager.startTrial(sma)\n\n\u00a0 \u00a0 activate StateMachine\n\n\u00a0 \u00a0 loop\n\n\u00a0 \u00a0 \u00a0 \u00a0 MATLAB-&gt;&gt;MATLAB : create sma\n\n\u00a0 \u00a0 \u00a0 \u00a0 Note over MATLAB : Hanging\n\n\u00a0 \u00a0 \u00a0 \u00a0 StateMachine-&gt;&gt;MATLAB : RawEvents = TrialManager.getTrialData\n\n\u00a0 \u00a0 \u00a0 \u00a0 deactivate StateMachine\n\n\u00a0 \u00a0 \u00a0 \u00a0 MATLAB-&gt;&gt;StateMachine : TrialManager.StartTrial(sma)\n\n\u00a0 \u00a0 \u00a0 \u00a0 activate StateMachine\n\n\u00a0 \u00a0 \u00a0 \u00a0 MATLAB-&gt;&gt;MATLAB : metrics, plots, saving\n\n\u00a0 \u00a0 end\n\u00a0 \u00a0 deactivate StateMachine</code></pre>"},{"location":"user-guide/advanced-user-guide/#global-timers","title":"Global timers","text":""},{"location":"user-guide/advanced-user-guide/#synchronization-signals","title":"Synchronization signals","text":"<p>Clocks on different hardware may read different times at the same moment, and drift apart over time due to differences in the oscillating pieces used to track time. Synchronization signals between systems allows time differences in timekeeping to be addressed.</p> <p>Bpod r0.5 had a dedicated synchronization line</p>"},{"location":"user-guide/advanced-user-guide/#scanimage","title":"ScanImage","text":"<p>ScanImage is a control software for two-photon microscopes.</p>"},{"location":"user-guide/advanced-user-guide/#liquid-delivery","title":"Liquid delivery","text":""},{"location":"user-guide/advanced-user-guide/#calibration","title":"Calibration","text":""},{"location":"user-guide/advanced-user-guide/#managing-clogged-valves","title":"Managing clogged valves","text":""},{"location":"user-guide/advanced-user-guide/#solenoid-vs-pinch-valve","title":"Solenoid vs pinch valve","text":""},{"location":"user-guide/advanced-user-guide/#trial-type-coding","title":"Trial type coding","text":""},{"location":"user-guide/advanced-user-guide/#randomized-pre-allocation","title":"Randomized pre-allocation","text":""},{"location":"user-guide/advanced-user-guide/#blocks","title":"Blocks","text":""},{"location":"user-guide/advanced-user-guide/#within-session-modification","title":"Within-session modification","text":""},{"location":"user-guide/advanced-user-guide/#bpodparametergui","title":"<code>BpodParameterGUI</code>","text":"<p>Construction of the settings structure for appropriate display by <code>BpodParameterGUI</code> requires some finessing.</p> <p>Developing a settings GUI that makes use of the features such as dropdown boxes may require some testing in emulator mode on your local device.</p>"},{"location":"user-guide/advanced-user-guide/#state-matrix-construction-patterns","title":"State matrix construction patterns","text":""},{"location":"user-guide/advanced-user-guide/#construction-in-protocol-function-vs-dedicated-function","title":"Construction in protocol function vs dedicated function","text":"<p>If a state matrix is particularly complex, it might be useful to compartmentalize its construction into a dedicated function. This enables:</p> <p>Development and troubleshooting of a state matrix is more easily performed using a separate file. Take for example the following: <pre><code>% a structure could be generated in the trial loop or manually in a debugging file\nactions = struct;\nactions.stimulus_time = 1;\nactions.stimpoke = {'Port1In', 'LeftLick'};\nactions.stimulus_action = {'BNCState', 1};\n% state matrix construction becomes one-liner\nsma = buildSMA(actions)\n% function could be its own m-file\nfunction sma = buildSMA(actions)\nsma = NewStateMatrix();\nsma = AddState('Name', 'Stimulus',\n'Timer', actions.stimulus_time,\n'StateChangeConditions', {'Tup', 'Decision', actions.stimpoke{:}},\n'OutputActions', actions.stimulus_action)\nend\n</code></pre></p> <p>In the above example, the protocol m-file calls <code>buildSMA()</code> using an <code>actions</code> structure that's built within the trial loop, but the user can also manually define the actions when testing changes to the state matrix.</p>"},{"location":"user-guide/advanced-user-guide/#managing-changing-trial-types","title":"Managing changing trial types","text":""},{"location":"user-guide/advanced-user-guide/#protocol-function-design-approaches","title":"Protocol function design approaches","text":""},{"location":"user-guide/advanced-user-guide/#training-stages-multiple-files-or-single-file","title":"Training stages: multiple files or single file?","text":"<p>Rodent training sometimes involves multiple stages or phases, where the parameters of the task and the state matrix change.</p> <p>The question is: does a user maintain multiple versions of a protocol, like Task1, Task2, Task3; or, does the user maintain a single file with the contingencies built in. Hopefully the answer is obviously a single file.</p> <p>But why? Version control and consistency are much easier to maintain in experiments defined in single files.</p> <ul> <li>Version control</li> <li>Complexity of <code>if</code> statements</li> </ul> <p>A task or phase switch can be used in the protocol file, ultimately storing that information in <code>BpodSystem.Data.TaskInfo.Task = task</code>. </p>"},{"location":"user-guide/advanced-user-guide/#minimizing-modification-of-protocol-m-file-by-using-arguments","title":"Minimizing modification of protocol m-file by using arguments","text":"<p>A bad practice for dealing with changing parameters during training is to modify the m-file directly to reflect what a specific rodent requires. Instead, it is better to make the use explicitly request what they want (without modifying the m-file directly). </p> <p>One way to handle this is <code>inputParser</code>, MATLAB's argument handling class. </p> <p>Normally, <code>inputParser</code> is used in a function to parse <code>varargin</code>. <code>varargin</code> (variable number of arguments in) is any number of inputs into a function, and the <code>inputParser</code> can break that apart and identify where the user has specified keyword values.</p> <pre><code>function test_parser(varargin)\np = inputParser();\np.addRequired('taskname')\np.addOptional('weight', [])\np.addParameter('ITI', 3)\np.parse(varargin{:})\ndisp(p.Results)\nend\n</code></pre> <p>For example the following would meet the syntax requirements. <pre><code>test_parser('roger', 28.1, 'ITI', 3)\n</code></pre></p> <p>The <code>addParameter()</code> method creates an optional parameter that has a default value is left unspecified. </p> <ul> <li>Adding useful additional information into <code>BpodSystem.Data</code></li> </ul> <p>The following code demonstrates one approach to capturing user inputs during session startup:</p> <pre><code>% Example of asking user for parameters\n% A good candidate for turning into a function\nquestion_msg = sprintf(\"Run protocol for %s...\\nInput parameters: \",BpodSystem.GUIData.SubjectName);\nwhile true % loop through until user meets input criteria or exits\nanswer = input(question_msg, 's');\nif isequal(answer, 'exit')  % If you just put in exit it will quit the loop.\nfprintf(\"Quit protocol\\n\")\nreturn\nend\nvarargin = strsplit(answer,' '); % Format text to expected varargin\ntry\np.parse(varargin{:})\nbreak\ncatch % if the arguments don't meet formatting criteria\nfprintf(\"Entry not recognised: \")\ndisp(varargin)\ncontinue  % ask for loop again\nend\nend\n</code></pre> <p>Rodent/subject specific parameters like task stage, weight, or even <code>maxTrials</code> can be defined using <code>inputParser</code>.</p> <p>Currently it is not possible to run a task using <code>RunProtocol</code> from the Command Window with additional arguments to feed into the protocol function.</p>"},{"location":"user-guide/advanced-user-guide/#settings-setup-procedure","title":"Settings setup procedure","text":"<p>If the user chooses to use an <code>inputParser</code> approach, then this goes before the construction of the settings structure because the arguments may define default starting values, or the inclusion/exclusion of certain parameter options in the GUI.</p> <pre><code>userinputs = parse_user_inputs();\nS = create_settings_struct(userinputs);\n</code></pre>"},{"location":"user-guide/advanced-user-guide/#using-git-and-github-for-bpod-and-protocols","title":"Using Git and GitHub for Bpod and protocols","text":"<p>Git is a version control system, and GitHub is an online management service for maintaining Git repositories.</p>"},{"location":"user-guide/advanced-user-guide/#protocols","title":"Protocols","text":"<p>Protocols have various benefits </p> <p>Version control makes developing new features for protocols easier. For example, imagine we want to change the code that generates trial types (between 1 and 2) from random sampling to a different sampling system. Rather than modify the file on the rig computer and risk breaking things and interrupting the schedule, with GitHub we can work on the protocol files on our a personal computer (perhaps making use of emulator mode). The user should create (\"checkout\") a new branch (e.g. 'develop') which contains all of the changes made, insulating it from <code>main</code>. The user can then work on the modified code on their own timeline until it appears ready to merge into <code>main</code>.</p> <p>All the while, GitHub is receiving the code.</p> <p>When the user and the rig have a spare moment, the user switches the rig to the <code>develop</code> branch to test its functionality</p>"},{"location":"user-guide/advanced-user-guide/#bpod","title":"Bpod","text":""},{"location":"user-guide/advanced-user-guide/#setting-up-and-using-bpod-on-a-single-rig-with-multiple-users-and-protocols","title":"Setting up and using Bpod on a single rig with multiple users and protocols","text":"<p>In some labs and on some rigs, it may be common for different users to use the same rig with different behavioral protocols that have different hardware requirements.</p>"},{"location":"user-guide/advanced-user-guide/#managing-changing-connections-into-state-machine","title":"Managing changing connections into state machine","text":""},{"location":"user-guide/advanced-user-guide/#using-multiple-portsreward-delivery-approaches","title":"Using multiple ports/reward delivery approaches","text":""},{"location":"user-guide/advanced-user-guide/#managing-user-specific-folders-files-and-functions","title":"Managing user-specific folders, files, and functions","text":""},{"location":"user-guide/advanced-user-guide/#general-troubleshooting","title":"General troubleshooting","text":"<ul> <li>Failure to connect to Bpod</li> <li>No water delivery</li> <li>Modules fail to connect</li> <li>Failure to trigger external hardware</li> </ul>"},{"location":"user-guide/advanced-user-guide/#dealing-with-sessiondata","title":"Dealing with <code>SessionData</code>","text":""},{"location":"user-guide/advanced-user-guide/#accessing-and-understanding-rawevents","title":"Accessing and understanding <code>RawEvents</code>","text":"<p>Both the <code>RawEvents</code> and <code>RawData</code> subfields contain the information returned from the state machine following completion of a trial. However, <code>RawData</code> is in an unprocessed format while <code>RawEvents</code> contains the same information but in a more human interpretable format -- for this reason is it recommended to work with <code>RawEvents</code>.</p> <p><code>RawEvents</code> contains the subfield <code>Trial</code>, where <code>length(SessionData.RawEvents.Trial) == SessionData.nTrials</code>. Within each cell is a structure with subfields <code>States</code> and <code>Events</code>. <code>States</code> contains a subfield for each state defined in the state matrix (even if it was not entered into), which then has an array of times, of size nEntries x 2. If the state was not entered into, then the array is <code>[nan, nan]</code> <code>Events</code> has a subfield for each event which was encountered during the trial, which then has an array of times, of size 1 x nEncounters.</p> <p>A state named 'DeliverReward' is commonly used to deliver the reward following a \"hit\" trial, so:</p> <pre><code>if ~isnan(RawEvents.Trial{trialnumber}.States.DeliverReward(0))\noutcome = 'hit';\nelse\noutcome = 'miss';\nend\n</code></pre>"},{"location":"user-guide/advanced-user-guide/#building-live-plots-by-integrating-offline-and-online-visualization-methods","title":"Building live plots by integrating offline and online visualization methods","text":"<p>Depending on your experience with plotting, it may not work as you want the first time you try. Examine this pseudo-code:</p> <pre><code>classdef LivePlot\nmethods\nfunction obj = LivePlot(varargin)\nobj.hplot = scatter()  % Intialize an empty plot\nend\nfunction update(obj, values_required)\nset(obj.hplot.Parent, __)  % add values into plot handle (rather than clearing and replotting)\nend\nfunction plotSession(obj, SessionData)\n% Emulates multiple trials and plotting with existing SessionData\nfor trial = 1:SessionData.nTrials\nvalues_required = extract_required_values(SessionData, trial)\nobj.update(values_required)\nend\nend\nend\nend\n</code></pre> <p>With this class, we can create a test-run to see how the plot behaves with existing data using <code>plotSession()</code>. </p> <p>There are various considerations for readability, like how if the x-axes represents trials then it will have to be updated each time <code>update()</code> is called.</p>"},{"location":"user-guide/advanced-user-guide/#object-oriented-programming-and-data","title":"Object-oriented programming and data","text":"<p>Object-oriented programming (OOP) is an approach that integrates data and the functions used to handle that data. <code>SessionData</code> is well suited to being used in an OOP context. </p> <p>SessionData is a struct in MATLAB and a dict in Python, which are data structures that simply store the data. OOP allows functions to be attached into the data (making the method into a structure). For example, in order to performance metrics from <code>SessionData</code> a user might have a large collection of functions, the documentation and access for which can be unwieldy as the collection grows.</p> <pre><code>% Create a plot using a series of function calls\nperformance_metrics = extract_my_metrics(SessionData)\nsome_other_necessary_data = process_that_thing(SessionData)\nplot_my_metrics(performance_metrics)\n% OOP\n% The series of function calls are performed within \nSessionData.plot()\n</code></pre> <p>By putting the data and the methods for analysis together, it makes both of them very portable.</p> <p>This can be done while preserving the original access methods for <code>SessionData</code>.</p>"},{"location":"user-guide/arcom/","title":"ArCOM","text":"<p>Original site: https://sites.google.com/site/sanworksdocs/arcom?authuser=0</p> <p>Arduino Communication, or ArCOM, is a set of classes developed by Sanworks to simplify two types of data transaction:</p> <ol> <li>Arduino &lt;--USB--&gt; MATLAB/GNU Octave</li> <li>Arduino &lt;--UART--&gt; Arduino.</li> </ol> <p>It provides single-line commands on both ends to transmit and receive scalars or arrays of different data types. You can find the rationale for this in the Sanworks release announcement for ArCOM.</p> <p>Currently, ArCOM transmits scalar integers and arrays of integers:</p> <ul> <li>8-bit types<ul> <li>uint8, int8, char</li> </ul> </li> <li>16-bit types<ul> <li>uint16, int16</li> </ul> </li> <li>32-bit types<ul> <li>uint32, int32</li> </ul> </li> </ul> <p>On the MATLAB side, ArCOM wraps three serial interfaces so your code can be used with any of:  - Matlab's built-in Java-based serial interface     - The PsychToolbox IOPort serial interface (significantly faster and lower latency!)  - The GNU Octave serial interface</p> <p>ArCOM configures serial port communication settings for you on both sides automatically (byte order, RTS/request to send, etc, to match the default configurations for MATLAB and Arduino).</p> <p>ArCOM is under development, and may contain bugs. Please submit any bugs you encounter to: admin@sanworks.io</p>"},{"location":"user-guide/arcom/#examples","title":"Examples","text":"<p>Here's how you'd use ArCOM to send an unsigned 16-bit integer array from Arduino to MATLAB: </p> <p>Arduino code: <pre><code>#include \"ArCOM.h\" // Import the ArCOM library\nArCOM myUSB(SerialUSB); // Create an ArCOM wrapper for the SerialUSB interface\nunsigned short myDataArray[10] = {0}; // Create a 1x10 uint16 array\nvoid setup() {\nSerialUSB.begin(115200); // Initialize the USB serial port\nmyUSB.writeUint16Array(myDataArray,10); // Send the array to MATLAB's buffer\n}\nvoid loop() {}\n</code></pre></p> <p>MATLAB code (with ArCOM.m in the MATLAB path):</p> <pre><code>SerialPort1 = ArCOM('open', 'COM3', 115200); % Create and open the serial port\nMyData = ArCOM('read', SerialPort1, 10, 'uint16'); % Read the array from the buffer\n</code></pre> <p>Another example, sending an array of 100 signed 32-bit ints from MATLAB to Arduino, </p> <pre><code>MyData = -151340:-151241;\nArCOM('write', SerialPort1, MyData, 'int16');\n</code></pre> <p>Arduino code: <pre><code>long myDataArray[100] = {0}; // Create a 1x100 int16 array\n...\nmyUSB.readint16Array(myDataArray,10);\n</code></pre></p>"},{"location":"user-guide/arcom/#installation","title":"Installation","text":""},{"location":"user-guide/arcom/#download","title":"Download","text":"<p>License</p> <p>ArCOM is free software, copyrighted by Sanworks LLC</p> <p>(C) 2021, Sanworks LLC, Rochester, NY, USA. </p> <p>Sanworks LLC has made ArCOM available to you under the terms of GPL 3.0. </p> <p>By downloading, you affirm that you have read the terms of this license and agreed to them.</p> <p>Download from Github</p>"},{"location":"user-guide/arcom/#setup","title":"Setup","text":""},{"location":"user-guide/arcom/#arduino","title":"Arduino","text":"<ul> <li>Extract /ArCOM/Arduino Library/ArCOM.zip</li> <li>Copy the extracted folder to your Arduino libraries folder.</li> <li>Alternatively, import the .zip directly in Arduino: Sketch &gt; Include Library &gt; Add .Zip Library</li> </ul>"},{"location":"user-guide/arcom/#matlab","title":"MATLAB","text":"<ul> <li>Add /ArCOM/Matlab/ to the MATLAB path.</li> </ul>"},{"location":"user-guide/arcom/#usage","title":"Usage","text":""},{"location":"user-guide/arcom/#arduino_1","title":"Arduino","text":""},{"location":"user-guide/arcom/#matlaboctave","title":"MATLAB/Octave","text":""},{"location":"user-guide/bench-testing-bpod/","title":"Bench-testing Bpod","text":"<p>This Bench-testing procedure will verify connectivity, but will not validate reliability or detect problems with Arduino. An improved bench testing procedure will be added soon. </p>"},{"location":"user-guide/bench-testing-bpod/#setup","title":"Setup","text":"<ol> <li>Connect a BNC to bare-wire breakout (or a probe set to 1X) to an oscilloscope, and view the channel with DC coupling, 1ms per div, 5V per div. Set the trigger to \"Normal\", and the threshold to ~2.5V. Make sure all filters and persistent display features are off.</li> <li>Connect a Bpod Arduino shield to an Arduino Leonardo and upload the \"Blink-server\" sketch in /Bpod/Firmware/SerialBlinkServer. Then unplug the Leonardo and put it aside.</li> <li>Connect a Bpod mouse port and solenoid valve to a port interface board. All three should be known-good.</li> <li>Connect the interface board + valve + port to Bpod with a known-good Ethernet cable.</li> <li>Run <code>Bpod</code>; at the MATLAB command prompt</li> <li>From the Settings menu, select the \"Port\" icon, and select the port that is plugged in. All other channels should be unchecked.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#ports","title":"Ports","text":"<ol> <li>From the Bpod console, click the \"H2O\" button (\"VLV\" on Bpod 0.7+), corresponding to the connected port. The valve should open each time the button is pressed, and close when depressed. (with your mouse, click to press and click again to depress).</li> <li>From the Bpod console, click the \"LED\" button. The port light should turn on with each press, and off with each depress.</li> <li>Run the \"operant\" protocol from the console, using \"dummy subject\" and \"default settings\". Break the port photogate with an opaque object, and observe the \"poke\" icon on the console. It should turn green when the object is inside the port, and red when it is outside. The \"Last Event\" should display \"Port1In\" when the object enters, and \"Port1Out\" when it leaves.  There should be no spurious pokes on any of the ports.</li> <li>Repeat this process for the next 7 ports. Each time, update Settings &gt; Port to make sure only the connected poke is checked. If you have more than 1 port, proceed in parallel.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#sync-port-bpod-05-only","title":"Sync port (Bpod 0.5 only)","text":"<ol> <li>Connect the oscilloscope BNC wire ground to the right-most spring terminal ground. </li> <li>Run /Bpod/Functions/Example Matrices/Cycle_128_States.m. This will generate a state matrix with 128 states.</li> <li>Upload the state matrix: SendStateMatrix(sma);</li> <li>Run the state matrix: <code>RunStateMatrix</code>;</li> <li>Each time you run the state matrix, the system passes through 128 states for 1ms each.</li> <li>Touch the signal pin of the BNC probe to each pin on the RJ45 connector, accessed from the top. The left-most pin is ground, and should have no signal when you run the matrix. The next pin is bit 1, which should go high every 2ms. The next is bit 2; 4ms... and so forth until the right most pin, bit 7. If all pins have the correct signal reliably, the sync port is working.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#hardware-serial-ports-for-bpod-05","title":"Hardware serial ports (for Bpod 0.5)","text":"<ol> <li>Connect Arduino Leonardo to power, and connect an Ethernet cable between the Bpod Arduino shield and Serial port 1. Reboot Leonardo with the \"reset\" button.</li> <li>Run /Bpod/Functions/Example Matrices/TriggerSerialDevice.m</li> <li>Run SendStateMatrix(sma);</li> <li>When you run the state matrix, you should see the LED on Arduino Leonardo flash twice, indicating that byte \"2\" was received. </li> <li>Plug Leonardo into Serial port 2. When you run the state matrix, it should flash 4 times, indicating that byte \"4\" was received.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#hardware-serial-ports-for-bpod-07","title":"Hardware serial ports (for Bpod 0.7+)","text":"<ol> <li>Connect Arduino M0 to power, and connect an Ethernet cable between the Bpod Arduino shield and Serial port 1. Reboot M0 with the \"reset\" button.</li> <li>Press the \"Refresh\" button on the console GUI. A tab should appear, labeled \"EchoModule1\".</li> <li>Open the EchoModule1 tab, and type a message into the terminal. The echo module should receive it, and echo it back. </li> <li>Verify that the echo module is visible on all 3 ports.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#bnc-and-wire-terminal-outputs","title":"BNC and wire terminal outputs","text":"<ol> <li>Connect the BNC outputs to the oscilloscope, and toggle them with the BNC Override &gt; Out buttons on the Bpod console. You should see 5V when high, and 0V when low.</li> <li>Connect each wire terminal output (spring terminals 2-5 from the left) to the oscilloscope and override them from the console. You should see 3.3V when high and 0V when low.</li> </ol>"},{"location":"user-guide/bench-testing-bpod/#bnc-and-wire-terminal-inputs","title":"BNC and wire terminal inputs","text":"<ol> <li>Connect a TTL source (we use Pulse Pal) to Bpod's BNC input channel 1. </li> <li>Run the Operant protocol. </li> <li>You should see the BNC 1 icon turn green each time the BNC line is high, and \"Last Event\" should display \"BNC1High\".  </li> <li>Repeat for BNC input 2.</li> <li>To test the wire input channels (also 5V tolerant), select each one from Console &gt; Settings &gt; Port, and un-check all others. Then repeat the BNC input channel test.</li> </ol>"},{"location":"user-guide/bpod-gui/","title":"Using the Bpod console","text":""},{"location":"user-guide/bpod-gui/#bpod-files","title":"Bpod files","text":"<pre><code>Bpod Local/ # Contains user-specific files like protcols, calibrations, saved data\n    Calibration files/\n    Data/\n    Protocols/\n    Settings/    # Bpod saves \nBpod_Gen2/    # Contains files required for Bpod to run\n</code></pre> <p>Note</p> <p>The expected location for the 'Bpod Local' folder is in same folder as 'Bpod_Gen2' is located.</p>"},{"location":"user-guide/bpod-gui/#bpod-console","title":"Bpod Console","text":"<p>The Bpod Console will appear when <code>Bpod</code> is launched and the device successfully connects: </p> <p>The exact buttons displayed on the console will reflect channels and features available on your state machine version.</p> <p>The console is your starting point for running protocols with Bpod. It has 5 sections:</p> <ul> <li>Live Info<ul> <li>Displays current and previous states while running an experimental trial</li> <li>Displays the last event recorded during a trial</li> <li>Displays the start time of the current trial in the session</li> <li>Displays the status of the USB serial connection - Idle or Transfer</li> </ul> </li> <li>Manual Override<ul> <li>This section contains an array of tabs. Each tab selects a panel of - override controls for either the state machine, or a connected module.</li> <li>If no module is connected, the tab will display \"Serial N\", where N is - the number of the physical port (see Serial3 in image above)</li> <li>If a module is connected, it displays as ModuleNameN, where N is the Nth - instance of the module type found.<ul> <li>For instance, two SNES modules on module ports 2 and 3 would appear in - separate tabs as SNES1 and SNES2. </li> </ul> </li> <li>The state machine panel provides buttons to override behavior ports, BNC - and Wire interfaces.</li> <li>The module panel defaults to a serial terminal, which exchanges data - between the state machine and the selected module.</li> <li>Custom override panels for modules can be created, and stored in /Bpod/- Functions/Override Panels/</li> <li>The number of panels shown will depend on the configuration of the state - machine hardware and firmware.</li> </ul> </li> <li>Config<ul> <li>Contains four buttons: Module Refresh, Settings, Module USB configuration, System Properties</li> <li>Module Refresh (top-left) <ul> <li>Requests a self-description from connected modules</li> <li>Updates the state machine's list of valid events and outputs. </li> <li>Displays each module in a tab in the Manual Override section of the GUI</li> </ul> </li> <li>Settings (top-right)<ul> <li>Launches a menu to configure Bpod settings:</li> <li>Liquid Calibration</li> <li>Audio Calibration</li> <li>Bonsai (TCP/IP) configuration</li> <li>Behavior port enable/disable</li> <li>Flex I/O channel configuration</li> <li>Sync line configuration</li> <li>Data/settings path configuration</li> </ul> </li> <li>Module USB configuration (bottom-left)<ul> <li>Launches a UI for pairing connected modules with available USB ports The resulting paired USB ports are stored in BpodSystem.ModuleUSB.(module - name)<ul> <li>i.e. BpodSystem.ModuleUSB.WavePlayer1 could contain the value 'COM4', for - use in your protocol.</li> </ul> </li> </ul> </li> <li>System Properties (bottom-right)<ul> <li>Launches a panel that displays details of the state machine and its - modules:<ul> <li>State machine firmware and hardware versions</li> <li>List of the state machine's onboard hardware and functions</li> <li>List of connected modules containing:<ul> <li>Name</li> <li>Firmware version</li> <li>Paired USB port</li> </ul> </li> <li>List of valid event names for the state machine assembler</li> <li>List of valid output action names for the state machine assembler</li> </ul> </li> </ul> </li> <li>Clicking the \"Module Refresh\" button (above) will update the info panel</li> </ul> </li> <li>Session<ul> <li>Session contains two buttons:<ul> <li>Play/Pause (top)<ul> <li>If idle, opens the launch manager.</li> <li>If running a protocol, schedules a pause after the current trial ends.</li> </ul> </li> <li>Stop (bottom)<ul> <li>Stops a running protocol, dropping the unfinished trial's data.</li> </ul> </li> </ul> </li> </ul> </li> <li>Help<ul> <li>A help button on the console's top-right launches a web browser to view this wiki.</li> </ul> </li> </ul> <p>Additional information</p> <ul> <li>While the console is open, the state machine's indicator LED will glow green. This indicates that the state machine is ready to communicate with the Bpod software. </li> <li>If you close the Bpod console, the state machine's indicator will glow blue, to indicate that it is disconnected from the program. Running the Bpod command while the console window is open results in an error.</li> <li>The console may contain some channels that appear grayed out. These channels are not available on the state machine you have connected.</li> </ul>"},{"location":"user-guide/bpod-gui/#launch-manager","title":"Launch manager","text":"<p>The Launch Manager appears when a protocol is run from the Bpod Console.</p> <p></p> <ul> <li>Protocol panel<ul> <li>Lists the protocols in /Bpod Local/Protocols/</li> <li>Folders appear with angle brackets: . Double click the folder to navigate. <li>Selecting a protocol will display the subjects registered for the protocol in the subject panel.</li> <li>Clicking \"+\" creates a new protocol from a blank template.</li> <li>Clicking \"-\" deletes a protocol</li> <li>Clicking the \"edit\" icon launches the protocol's main .m file in the MATLAB editor.</li> <li>Subject panel<ul> <li>Lists the test subjects registered for the selected protocol. </li> <li>Clicking \"+\" adds a test subject to the list. It also creates a folder for the test subject in /Bpod Local/Data/</li> <li>Clicking \"-\" removes the test subject's folder and all of the data and settings within it.</li> <li>You will be warned before this happens, and forced to click two check-boxes confirming the deletion.</li> </ul> </li> <li>Settings panel<ul> <li>Lists the settings files in /Bpod Local/Data/TestSubject/Protocol/Settings/</li> <li>Each settings file is a .mat file, containing a struct with task parameters.</li> <li>Clicking \"+\" adds a .mat file containing an empty struct to the selected subject's settings folder.</li> <li>Clicking \"-\" removes the selected .mat file from the selected subject's settings folder.</li> <li>Clicking \"edit\" loads the struct of the selected .mat file into the local workspace. You can change parameters in the struct, and then run <code>SaveProtocolSettings(ProtocolSettings)</code> to save it to its original location.</li> <li>Clicking \"import\" allows you to copy a settings file to the list (from another test subject's folder).</li> </ul> </li> <li>Launch button<ul> <li>Once you are ready to start the protocol, click \"Launch\".</li> <li>This will run your protocol's main .m file</li> <li>The settings struct you selected will be available in your protocol workspace as: <code>BpodSystem.ProtocolSettings</code></li> </ul> </li> <p>Note</p> <p>The path to the folder may be different on your system. You can select where settings, protocols and data are stored from the Bpod console's settings menu.</p>"},{"location":"user-guide/bpod-gui/#emulator-mode","title":"Emulator mode","text":"<p>If the Bpod software can not connect to a Bpod device, it can be run in Emulator mode.</p> <ul> <li>In emulator mode, a software state machine on the computer takes the place of the Bpod device.    </li> <li>State matrices can be sent and run, and events returned without changing protocol code.</li> <li>The Bpod console shows the state of the device, and accepts manual inputs. Simply click port sensor, BNC and wire override buttons.</li> <li>The computer clock is used for timers and event timestamps. Thus, timing is far less precise than for measurements obtained with the Bpod device.</li> <li>The PsychToolboxSoundServer plugin detects when Bpod is in emulator mode, and plays sounds through the computer's default sound card.<ul> <li>In emulator mode, sounds are played with the MATLAB sound function. Performance and availability varies by platform.</li> </ul> </li> <li>Emulator mode can be forced when hardware is connected, by running Bpod('EMU')</li> <li>To exit emulator mode, ensure that the Bpod device is plugged in and restart Bpod.</li> <li>Currently, only the state machine's onboard channels are supported. If your protocol depends on Bpod modules or other external hardware, you will have to run your protocol with the hardware present.</li> </ul>"},{"location":"user-guide/bpod-gui/#liquid-calibration","title":"Liquid calibration","text":"<p>Solenoid valves connected to each behavior port (we recommend these for their fast action) can gate the gravity flow of liquid reward from an elevated reservoir to the test subject below. When writing your protocol, you might want to deliver a 5\u00b5l of liquid reward to a mouse - but how long should you open the valve to achieve this? The <code>GetValveTimes()</code> function will solve this for you, by reading from a calibration curve you create. Here's how to create and manage calibration curves:</p> <ul> <li>From the Bpod console, click \"Settings\" (wrench icon). You will see a settings menu: </li> </ul> <p></p> <ul> <li>Next, click \"Liquid reward calibration\" (the faucet icon on the far left)</li> <li>You should now see the calibration manager:</li> </ul> <p></p> <ul> <li>In the left list box, you can select one of the 8 valves to view its measurements and calibration curve in the right panels.</li> <li>The \"Plus\" button will manually add a new amount to be measured. This will appear in red as a \"Pending measurement\".</li> <li>The \"Minus\" button will permanently delete the selected measurement. <ul> <li>The \"Suggest Points\" button prompts you for a liquid amount range of interest, and automatically adds the best pending measurements: </li> </ul> </li> </ul> <p></p> <ul> <li>The \"#Pulses / measurement\" button allows you to specify how many pulses will be delivered for each measurement. Larger numbers of pulses reduce measurement error, especially when calibrating for small liquid quantities.</li> <li>The \"Measure Pending\" button delivers pulses from each valve that has a pending measurement. You should capture the water dispensed from each valve in a separate weigh boat. When dispensing is complete, the software prompts you to measure each boat on a laboratory balance, and enter the resulting liquid weights. It then updates the calibration curve.</li> <li>The \"Test curve\" button delivers 100 test pulses of a size you select from a valve you select, prompts for the resulting weight, and indicates whether the measurement is within a selected tolerance:</li> </ul> <p></p>"},{"location":"user-guide/protocol-development/","title":"Protocol development","text":"<p>To run a trial-based experiment with Bpod, you must first program a behavioral protocol in MATLAB.</p> <p>This guide will walk you through creating a simple protocol.</p> <p>Other example protocols are available in /Bpod_Gen2/Examples/Protocols.</p>"},{"location":"user-guide/protocol-development/#concepts","title":"Concepts","text":"<p>A protocol is effectively two parts:  1. Defining session parameters and initializing session hardware. 2. A loop to make the state machine activate and process the data.</p>"},{"location":"user-guide/protocol-development/#procedure","title":"Procedure","text":""},{"location":"user-guide/protocol-development/#file-setup","title":"File Setup","text":"<ul> <li>Open a new m-file in the MATLAB editor.</li> <li>Add the line function MyProtocol to the file. Here, MyProtocol is the name of your protocol.</li> <li>Save the m-file as MyProtocol.m in a folder with the same name, in /Bpod Local/Protocols/.</li> <li>Your file should now be: /Bpod Local/Protocols/MyProtocol/MyProtocol.m</li> <li>Bpod considers a protocol to be a folder containing an .m file with the same name.</li> <li>Protocol folders can be organised into subfolders within Protocols/</li> <li>Other files used exclusively by your protocol can also reside in this folder. For now, you just need the one you saved.</li> </ul> <p>Note</p> <p>When a protocol is run, Bpod will add the protocol folder into MATLAB's Path where the protocol m-file is stored.</p>"},{"location":"user-guide/protocol-development/#protocol-setup-code-that-runs-before-the-behavior-session-starts","title":"Protocol Setup (code that runs before the behavior session starts)","text":"<ul> <li>On the next line of your protocol file, add <code>global BpodSystem</code></li> <li>This makes the BpodSystem object visible in the the MyProtocol function's workspace.</li> <li>Add code to create a struct containing your task parameters. For instance, if your parameters are stimulus intensity and stimulus delay, you could write:</li> </ul> <pre><code>S = struct;\nS.RewardAmount = 0;\nS.ResponseTimeAllowed = 0;\n</code></pre> <p>When you launch a protocol from the launch manager, you can select a settings file. The settings file is simply a .mat file containing a parameter struct like the one above, which will be stored in BpodSystem.ProtocolSettings. To only use the default parameters when an empty (default) struct was selected, use:</p> <pre><code>S = BpodSystem.ProtocolSettings;\nif isempty(fieldnames(S))  S.RewardAmount = 0;\nS.ResponseTimeAllowed = 0;\nend\n</code></pre> <p>If you want to view and edit some parameters during behavior Add those parameters to the field \"GUI\":</p> <pre><code>S.GUI.TimeoutDuration = 5;\n</code></pre> <p>Initialize the Parameter GUI plugin: <pre><code>BpodParameterGUI('init', S);\n</code></pre></p> <p>Define a trial type for each possible behavioral response, and make a list of the future trial types for your session. <pre><code>% Trial Types: 1 = left, 2 = right, both sides equally probable and randomly interleaved \nTrialTypes = ceil(rand(1,1000)*2); </code></pre></p> <p>If you will deliver liquid reward to the port, determine how long the valve needs to open to dispense the intended liquid volume with GetValveTimes <pre><code>R = GetValveTimes(S.RewardAmount, [1 3]); % Return the valve-open duration in seconds for valves 1 and 3\nLeftValveTime = R(1); RightValveTime = R(2); </code></pre></p> <p>Initialize any plots and plugins for online visualization and peripheral device control. Plugins are in /Bpod/Functions/Plugins. <pre><code>BpodNotebook('init'); % Launches an interface to write notes about behavior and manually score trials\n</code></pre></p> <p>Note</p> <p>It is recommended to initialise figures at the end of the startup because if an error is encountered (e.g. failure to configure a module) after figures are created then you will be left with windows to close manually.</p>"},{"location":"user-guide/protocol-development/#main-loop-runs-once-each-trial-until-some-conditions-are-met-or-the-experimenter-stops-the-session-from-the-console","title":"Main Loop (runs once each trial until some conditions are met, or the experimenter stops the session from the console)","text":"<p>Create a loop with some condition for ending the session <pre><code>for currentTrial = 1:MaxTrials % Run the session until a maximum number of trials are complete\n</code></pre></p> <p>If you are using the ParameterGUI plugin, synchronize it (display updated parameters changed by your code, and manually override any parameters changed by the user during the previous trial) <pre><code>S = BpodParameterGUI('sync', S);\n</code></pre></p> <p>Set up the variable parts of the current trial's state matrix.  <pre><code>switch TrialTypes(currentTrial)\ncase 1\nLeftPortAction = 'Reward'; RightPortAction = 'Timeout'; Stimulus = {'PWM1', 255}; ValveCode = 1; ValveTime = LeftValveTime;\ncase 2\nLeftPortAction = 'Punish'; RightPortAction = 'Reward'; Stimulus = {'PWM3', 255}; ValveCode = 4; ValveTime = RightValveTime;\nend\n</code></pre></p> <p>Construct the current trial's state matrix using the NewStateMatrix and AddState functions: <pre><code>sma = NewStateMatrix(); % Create a blank matrix to define the trial's finite state machine\nsma = AddState(sma, 'Name', 'WaitForPoke', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port2In', 'DeliverStimulus'},...\n'OutputActions', {}); sma = AddState(sma, 'Name', 'DeliverStimulus', ...\n'Timer', 0,...\n'StateChangeConditions', {'Port2Out', 'WaitForResponse'},...\n'OutputActions', Stimulus);\nsma = AddState(sma, 'Name', 'WaitForResponse', ...\n'Timer', S.ResponseTimeAllowed,...\n'StateChangeConditions', {'Port1In', LeftPokeAction, 'Port3In', RightPokeAction, 'Tup', 'exit'},...\n'OutputActions', Stimulus); sma = AddState(sma, 'Name', 'Reward', ...\n'Timer', ValveTime,...\n'StateChangeConditions', {'Tup', 'end'},...\n'OutputActions', {'ValveState', ValveCode}); sma = AddState(sma, 'Name', 'Timeout', ...\n'Timer', S.GUI.TimeoutDuration,...\n'StateChangeConditions', {'Tup', 'exit'},...\n'OutputActions', {}); </code></pre></p> <p>Send the state matrix to the Bpod device with the SendStateMatrix function: <pre><code>SendStateMatrix(sma);\n</code></pre> Run the trial's finite state machine, and return the measured timecourse of events and states. The flow of states will be controlled by the Bpod device, and the PC/MATLAB will act as a passive observer until the trial is complete (but see soft codes) <pre><code>RawEvents = RunStateMatrix;\n</code></pre> Add this trial's raw data to a human-readable data struct using the AddTrialEvents function.</p> <p>The data struct, BpodSystem.Data, will later be saved to the current data file (automatically created based on your launch manager selections and the current time). <pre><code>BpodSystem.Data = AddTrialEvents(BpodSystem.Data, RawEvents);\n</code></pre> If you are using plugins that can add data to the data struct, call their update methods. <pre><code>BpodSystem.Data = BpodNotebook('sync', BpodSystem.Data);\n</code></pre> Add a snapshot of the current settings struct, for a record of the parameters used for the current trial. <pre><code>BpodSystem.Data.TrialSettings(currentTrial) = S;\n</code></pre> Add the current trial type. <pre><code>BpodSystem.Data.TrialTypes(currentTrial) = TrialTypes(currentTrial);\n</code></pre> Save the data struct to the current data file. <pre><code>SaveBpodSessionData;\n</code></pre> If the user has pressed the \"Pause\" button on the Bpod console, wait here until the session is resumed <pre><code>HandlePauseCondition;\n</code></pre> If the user has ended the session from the Bpod console, exit the loop. <pre><code>if BpodSystem.BeingUsed == 0\nbreak\nend\n</code></pre></p>"},{"location":"user-guide/protocol-development/#going-further","title":"Going Further","text":"<ul> <li>See /Bpod_Gen2/Protocols for other simple example protocols.</li> <li>Learn to use Global Timers and Global Counters</li> <li>Learn to use Soft Codes and Bpod Modules</li> <li>Learn to use the online plots in the /Bpod/Functions/Plugins folder.</li> <li>Set up liquid calibration for gravity flow reward delivery</li> </ul>"},{"location":"user-guide/using-bcontrol/","title":"Using BControl","text":""},{"location":"user-guide/using-bcontrol/#status","title":"Status","text":"<p>As of firmware v18, Bpod supports BControl software, developed and maintained by Brody Lab at Princeton University.</p> <p>BControl support is in public beta. Please report issues on the Sanworks support forums.</p> <p>To use BControl with Bpod hardware, you need to apply a patch to the latest BControl software. Follow these instructions:</p>"},{"location":"user-guide/using-bcontrol/#setup","title":"Setup","text":"<ol> <li>Download a fresh copy of B-control, following the instructions here (MATLAB-side instructions ONLY).</li> <li>Make a backup copy of your BControl download, in case something fails.</li> <li>If you have not already done so, install PsychToolbox.</li> <li>Load the B-control firmware variant for your state machine (from the state machine firmware repository, here).</li> <li>Open MATLAB, and from the command prompt run: <code>Bpod</code>;</li> <li>Once Bpod opens, run: <code>PatchBControl</code>;</li> <li>Follow the prompt to identify BControl's root directory, and confirm that you have made a backup copy</li> <li>The software will install a patch, allowing you to run BControl whenever Bpod is open.</li> <li>If you plan to use sound stimuli with BControl, load AudioPlayerLive firmware onto a 4-channel analog output module</li> <li>If you plan to use analog scheduled waves, load WavePlayer firmware onto a separate 4-channel analog output module</li> <li>If you added hardware modules in steps 9-10<ol> <li>Press the \"refresh\" button on the Bpod console (or restart Bpod). Detected modules should appear in tabs on the console.</li> <li>Run \"USB Pairing\" from the Bpod console (USB icon), to associate each module with its USB port.</li> </ol> </li> </ol>"},{"location":"user-guide/using-bcontrol/#running-bcontrol","title":"Running BControl","text":"<ol> <li>With Bpod open, run newstartup; dispatcher('init');</li> <li>Note for prior users: you no longer need to navigate to the BControl home directory.</li> </ol>"},{"location":"user-guide/using-bcontrol/#tips","title":"Tips","text":"<ul> <li>Choice of Bpod state machine<ul> <li>State machine v0.7-1.0 provides:<ul> <li>8 Nose pokes</li> <li>8 scheduled waves</li> <li>8 non-standard happening specs (non-standard = beyond the events in BControl's legacy state matrix)</li> <li>1 valve open at a time</li> </ul> </li> <li>State machine r2 provides:<ul> <li>4 Nose pokes</li> <li>20 scheduled waves</li> <li>20 non-standard happening specs</li> <li>4 valves open at a time</li> <li>Significantly faster USB data transmission</li> <li>Significantly more CPU available for mods</li> </ul> </li> </ul> </li> <li>Choice of computer and MATLAB<ul> <li>Required: a PC running Windows 7 or 10</li> <li>Core i7 + 16GB RAM recommended, especially if other apps (i.e. an IR camera) will run in parallel</li> <li>MATLAB r2011a - r2014a supported, r2014a strongly recommended.</li> </ul> </li> <li>Necessary Bpod Modules<ul> <li>For sound: HiFi Module HD</li> <li>For analog scheduled waves: Analog Output Module</li> </ul> </li> <li>Limitations<ul> <li>Compiled C \"on the fly\" cannot be supported</li> <li>untrigger_on_down is not currently supported</li> <li>scheduled wave refraction is not currently supported</li> </ul> </li> <li>Settings_Custom.conf<ul> <li>When running the patch, a settings_custom.conf file is auto-generated for the state machine version connected, incl. the correct path to your protocol and data folders.</li> <li>3 ports are enabled. More can be added by uncommenting the relevant DIO lines.</li> <li>2 stimulator channels are enabled: stim1, stim2. These are mapped to Bpod's BNC output channels.</li> <li>At the top of the conf file, 'use_bdata' is set to 0. If you are in Brody Lab, set this variable to 1, to use the local SQL server.</li> </ul> </li> <li>VALIDATE<ul> <li>BControl support is in public beta. Please ensure that the system is doing what you think it is, before acquiring scientific data. This means verifying event timing in your protocol (with an oscilloscope), measuring audio latency and waveform quality, the correct flow of states and events, etc.</li> </ul> </li> </ul>"},{"location":"user-guide/visual-stimulus-integration/","title":"Integrating Bpod with visual stimuli","text":""},{"location":"user-guide/visual-stimulus-integration/#psychtoolboxvideo","title":"PsychToolboxVideo","text":""},{"location":"user-guide/visual-stimulus-integration/#bonsai-integration","title":"Bonsai integration","text":"<p>Bonsai is an open source software tool for processing data streams, developed by Goncalo Lopes.</p> <p>Among many applications in behavior measurement, it can be used for live video tracking, e.g. to trigger a Bpod state change based on the test subject's position in an arena.</p> <p>Two methods exist to integrate Bpod with Bonsai, depending on your state machine model and firmware:</p>"},{"location":"user-guide/visual-stimulus-integration/#state-machine-r20-and-newer-with-firmware-v23","title":"State Machine r2.0 and newer with firmware v23","text":"<p>With Firmware v23 on Bpod State Machine 2.0 or newer, the machine creates two USB serial ports on the PC. The primary port (e.g. COM3) is used to communicate with MATLAB. The secondary \"App\" port (e.g. COM4) can be used by a third-party application to exchange events with the state machine. Bonsai can send bytes to the App serial port using the SerialWrite sink, found under 'IO.Ports' in the sink menu. Bonsai can receive bytes from the App serial port using the SerialRead source, under 'IO.Ports' in the source menu.\u00a0</p> <p>Note: From the Bpod console, click the Info (spyglass) icon to view the identity of the App serial port.</p>"},{"location":"user-guide/visual-stimulus-integration/#bonsai-bpod-state-machine","title":"Bonsai --&gt; Bpod State Machine","text":"<p>When bytes in range [0x1, 0x15] are sent from Bonsai's SerialWrite sink to the state machine's App serial port, the bytes are interpreted by the state machine as events App_SoftCode0 to App_SoftCode14. To handle these events, add them to the 'StateChangeConditions' section of a state. The following example state proceeds to the next state when byte 0x2 arrives from Bonsai:</p> <pre><code>sma = AddState(sma, 'Name', 'WaitForBonsai', ...\n'Timer', 0,...\n'StateChangeConditions', {'APP\\_SoftCode2', 'MyNextState'},...\n'OutputActions', {});\n</code></pre>"},{"location":"user-guide/visual-stimulus-integration/#bpod-state-machine-bonsai","title":"Bpod State Machine --&gt; Bonsai","text":"<p>Bytes in range 1-255 can be sent to Bonsai's SerialRead source from any state using:</p> <pre><code>ByteToSend = 3; % Send byte 0x3 to Bonsai\nsma = AddState(sma, 'Name', 'SendToBonsai', ...\n'Timer', 0,...\n'StateChangeConditions', {'Tup', 'MyNextSTate'},...\n'OutputActions', {'AppSoftCode', ByteToSend});\n</code></pre> <p>An example Bonsai program here uses the SerialRead and SerialWrite nodes to read incoming bytes from the state machine, and echo the same bytes back to the state machine generating Bpod events. Usage instructions are in the Readme file in the program folder.</p>"},{"location":"user-guide/visual-stimulus-integration/#state-machine-r05-r10-any-firmware-and-r20-with-firmware-v22","title":"State Machine r0.5 - r1.0 (any firmware), and r2.0 with firmware v22","text":"<p>Since Bonsai is a separate program and MATLAB requires ownership of the Bpod state machine's only serial port, the soft codes must be passed via a local TCP socket. The Bonsai Socket Configurator manages this socket connection by creating a TCP server within MATLAB, and confirming when Bonsai is successfully attached as a client.</p> <p>Notice: The current release should be regarded as an alpha. It works with example code as detailed below, but it is preliminary, and will be updated in a future revision with a more general solution for built-in TCP communication. Please report any bugs you encounter.</p> <p>Step 1: Launch the settings and calibration manager.</p> <ul> <li>From the Bpod console, click \"Settings\" (the wrench icon)f</li> </ul> <p></p> <ul> <li>Next, click \"Setup Bonsai Socket Connection\" (the tree icon)</li> <li>You should now see the Bonsai socket configurator:</li> </ul> <p></p> <ul> <li>Since you are creating the TCP server, you can use custom IP and Port. The defaults work fine.</li> <li>Click \"Connect\".</li> <li>In Bonsai, run an application that connects to your IP and Port. An example app is available in /Bpod/Bpod System Files/Plugins/Bonsai/App_SoftCode Example/. To demonstrate use of the app, after connecting to Bonsai, run the soft code example in /Bpod/Bpod System Files/ExampleMatrices: SoftCodeTriggeredStateChange.m. Shifting a bright light across your webcam's field of view from right to left should trigger a state change, visible as a change in port LEDs.</li> <li>If the connection was initiated successfully, the Bonsai Status should show \"Connected\" in green.</li> <li>Check \"Auto-connect on Bpod start\" to automatically connect to Bonsai when you run Bpod. Note: this will halt the Bpod launch routine until a Bonsai app connects.</li> </ul>"}]}